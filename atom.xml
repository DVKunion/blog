<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DV.K</title>
  
  
  <link href="http://blog.dvkunion.cn/atom.xml" rel="self"/>
  
  <link href="http://blog.dvkunion.cn/"/>
  <updated>2023-11-03T20:21:04.399Z</updated>
  <id>http://blog.dvkunion.cn/</id>
  
  <author>
    <name>DV.K</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蓝军视角:阿里云 RCE 战火余烬下的启示</title>
    <link href="http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/"/>
    <id>http://blog.dvkunion.cn/2023/05/25/%E9%98%BF%E9%87%8C%E4%BA%91%20RCE%20%E6%88%98%E7%81%AB%E4%BD%99%E7%83%AC%E4%B8%8B%E7%9A%84%E5%90%AF%E7%A4%BA/</id>
    <published>2023-05-25T17:11:10.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>蓝军视角: 阿里云 RCE 战火余烬下的启示</h1><!-- split --><p>2023年4月19日，Wiz Research 在文章 <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services</a> 中披露了被命名为<code>BrokenSesame</code>的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。</p><p>时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。</p><span id="more"></span><h2 id="0x01-容器提权">0x01 容器提权</h2><p>在原文中，作者分享了两个案例：ApsaraDB RDS for PostgreSQL 和  AnalyticDB for PostgreSQL。 两个案例的第一步均为容器提权：从普通账户提权至更高的权限。 在这一步中，两个案例分别用到了不同的攻击链路：</p><ul><li>cron定时任务'/usr/bin/tsar' -&gt; 高权限执行的二进制文件 -&gt; 可修改的动态链接库 -&gt; 覆盖链接库 -&gt; 定时任务出发执行获取root权限。</li><li>容器共享目录 -&gt; 业务特性导致任意文件读取（符号链接）-&gt;  获取到另一个容器的读取下权限。</li></ul><p>在这两个链路中，链路1实际上是在渗透过程中最常使用的一种攻击方式，通过注入恶意动态链接库实现账户提权。这条链路涉及到了两个关键的问题点：cron定时任务的启动权限和动态链接库权限。cron的高权限导致所有定时任务都通过高权限账户root来执行，而可修改的动态链接库权限导致覆盖动态链接库；</p><p><img src="/img/1681856311-screenshot-2023-04-18-at-15-18-07.png" alt="链路1"></p><p>针对这两个风险点，传统的HIDS文件监控即可覆盖到该层面。除此之外，对于添加进入定时任务的二进制程序，应该严格限制其权限，包括动态链接库文件。</p><p>在第二条链路中，我们发现实际上业务在设计架构模式上时，使用了共享容器的目录来实现通信；但业务代码并没有考虑符号链接的场景，导致了第二个文件下的任意文件读取。</p><p>整体来看，链路1和链路2分别属于的HIDS主机监控/黑白盒业务安全扫描的范畴，说明即使在云场景下，传统的业务安全依旧处于重要地位。</p><h2 id="0x02-容器逃逸">0x02 容器逃逸</h2><p>获取到容器root权限后，下一步便是朝着宿主机进行攻击，同样是两条链路：</p><ul><li>共享pid namespcae -&gt; 监听发现共享的挂载目录'/home/adbpgadmin' -&gt; 植入ssh/config获取容器B权限 -&gt; 通过容器B的docker.sock 逃逸至宿主机。</li><li>由提权过程中的任意文件读取获取到业务代码 -&gt; 代码审计发现命令注入 -&gt; 通过命令注入获取到特权容器的shell -&gt; 通过<code>core_pattern</code>实现容器逃逸。</li></ul><p>在这两条链路中，攻击者使用了两种不同的逃逸方式：共享namespace导致攻击者获取到更多信息、挂载docker.sock导致逃逸、特权容器复写core_pattern导致逃逸；这几种方式是云环境中比较经典的逃逸场景，使得容器绕过各种隔离限制，对容器外的宿主机或其他容器的资源进行操作。</p><p>如何对容器逃逸进行防御？传统的业务安全和主机安全并没有针对主机cgroups和namespace的防御设计；结合云原生的架构模式，可以在两个环节建设容器逃逸检测。</p><ul><li>DevSecOps安全左移，对代码仓库构建产物的IaC(基础设施即代码)进行审查，在开发阶段对可能存在逃逸风险的配置项问题进行阻断，防止出现各类逃逸问题。</li><li>运行时监测, 对于已经上线并实际运行的业务容器，实时监控逃逸特征。通过订阅内核事件，抓取可能为逃逸的行为特征，结合当前运行中的容器配置信息进行分析，综合给出是否存在逃逸风险以及是否发生逃逸事件的告警。</li></ul><p>结合这两点，可以做到对逃逸风险的有效控制，防止攻击者进一步的攻击行为。</p><h2 id="0x03-横向扩散">0x03 横向扩散</h2><p>在实现逃逸后，获取到的数据就越来越宽泛。</p><ul><li>通过k8s节点存储凭证可获取各种敏感资源如secrets、configmaps。</li><li>通过imagePullSecrets获取到了私有镜像仓库权限。</li><li>环境变量中存储了access_keys等敏感信息。</li><li>其他用户的pod信息等。</li></ul><p>可以看到，在实现了容器逃逸后，攻击者轻松从各种凭证信息实现横向扩撒，包括各类敏感资源数据、镜像仓库权限等等；这好比在传统的渗透中，从DMZ区进入到了内网环境后，发现大多主机MS-17010通杀的场景；说明对于云环境下的节点管理，仍需要加强警惕，尤其是在容器逃逸防护较弱的场景下。</p><p>针对这部分横向移动与扩散的攻击行为，可以和容器逃逸一样分为两个方面进行防护：</p><ul><li>事前防护：对镜像资产/容器资产进行扫描，保证镜像/容器内没有敏感信息以及过高的凭证信息。</li><li>事中防护：通过对集群日志审计来发现横向移动行为，快速响应并隔离问题容器。</li></ul><h2 id="0x04-综合反思">0x04 综合反思</h2><p>回顾整条攻击链，我们可以总结以下几点：</p><p><strong>传统的业务安全在云原生环境下依旧处于重要地位</strong><br>回看整个攻击过程，所有的切入点仍然是一个容器服务。虽然容器提供了相对隔离的运行环境，但传统的业务安全如：web安全所导致的问题依旧作为了云安全事件中的切入点，其地位不亚于弱口令。</p><p><strong>云环境的场景下，传统安全的危害效应将指数级放大</strong><br>云环境中的配置复杂，一旦存在了配置不当的情况，攻击者便可以轻易的将攻击从一个容器扩散到一台主机、一个集群、甚至于多个集群、整个k8s环境。此时，作为入侵的入口导致的影响指数级上升。</p><p><strong>云环境的场景下，容器逃逸是整个攻击链路的核心</strong><br>在整个攻击的步骤中，我们可以总结出：攻击者获取到一个容器的最高权限后，必须千方百计的实现逃逸来绕过各种资源限制，才能够产生更为严重的影响；因此，云环境场景下，逃逸问题是连接传统安全与云安全的关键核心。</p><p><strong>云环境对基础设施的监控、审计需求更加复杂和迫切</strong><br>云计算的特性使得基础设施的边界变得模糊，资源的动态变化增加了管理和保护的难度，同时多租户环境下的安全性和合规性风险也需要得到充分的关注和解决，带有缺陷的隔离限制将轻易的导致用户数据泄露。</p><p>同时，我们也能看到，云环境的场景下，对于蓝军防守方，提供了一个新的思路：<div color=red><strong>在面对传统安全覆盖率永远无法达到100%以及层出不穷的0day漏洞，加强对云安全防护以及逃逸检测能够有效的中断攻击链路，降低攻击危害，实现低成本/高回报率的防护。</strong></div></p><p>针对对以上的问题，牧云-云原生安全平台提供了完整的监控与检测方案，深入监控了每一个容器的生命周期，在传统的webshell、反弹shell等安全入侵能力检测上，结合云环境特点，实现了容器逃逸风险监测、集群日志审计等功能，帮助您清晰明了的掌控集群的实时安全；当发生安全事件时，黑客的恶意行为和特征将会被检测与捕捉，实时反馈到平台中。</p><p><img src="/img/16842061452391.png" alt="img.png"></p><p>除此之外，为保证供应链安全，牧云-云原生安全平台提供了定时任务机制和多种多样的资源集成，定时检测您的镜像仓库等远端资源，第一时间发现风险镜像，包括敏感信息泄漏、恶意文件、软件漏洞等问题。并通过配置可以阻断来自于该镜像的容器创建请求以及镜像构建请求，防止攻击扩散。</p><p><img src="/img/16842062957916.png" alt="资源集成"></p><p>与此同时，牧云-云原生安全还考虑了云场景下资源迭代的快速以及漏洞响应的及时性，设计了插件系统，结合开源社区安全检测能力的沉淀，能够快速赋能最新漏洞检测需求，并热更新于平台中，提供与时俱进的插拔式安全检测能力；如前一阵子出现的Minio漏洞（CVE-2023-28432），可以通过快速插入专项检测插件来实现0 day速查。</p><p><img src="/img/16842062518677.png" alt=""></p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services : <a href="https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r">https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;蓝军视角: 阿里云 RCE 战火余烬下的启示&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;2023年4月19日，Wiz Research 在文章 &lt;a href=&quot;https://www.wiz.io/blog/brokensesame-accidental-write-permissions-to-private-registry-allowed-potential-r&quot;&gt;Accidental ‘write’ permissions to private registry allowed potential RCE to Alibaba Cloud Database Services&lt;/a&gt; 中披露了被命名为&lt;code&gt;BrokenSesame&lt;/code&gt;的一系列阿里云数据库服务漏洞，向我们展示了如何从一个容器逃逸漏洞，与私有仓库写权限的组合，最终实现RCE的攻击链路。该漏洞最终可导致未授权访问阿里云客户的PostgreSQL数据库，并且可以通过在阿里巴巴的数据库服务执行供应链攻击。&lt;/p&gt;
&lt;p&gt;时隔一个月，在经过研究与复现的过程中，不由得感叹攻击者的构思巧妙；而反过来作为防守人员，我们能否在这次战役中，吸取一些教训？让我们站在蓝军的视角再看一遍完整的攻击路程。&lt;/p&gt;</summary>
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>白嫖国外主机新思路</title>
    <link href="http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://blog.dvkunion.cn/2023/02/24/%E7%99%BD%E5%AB%96%E5%9B%BD%E5%A4%96%E4%B8%BB%E6%9C%BA%E6%96%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2023-02-24T13:01:12.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>白嫖国外主机新思路</h1><!-- split --><blockquote><p>免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。</p></blockquote><span id="more"></span><h2 id="前言">前言</h2><p>近日，百川云平台发布了新的产品：牧云主机管理助手。可以帮助用户简单、轻量级的进行主机管理。</p><p><img src="/img/d946d58b-8d6b-4ddb-a7f5-50a7d749214f.png" alt=""></p><p>很快啊，在体验了一波基本功能后，发现主机助手真的很便捷：</p><ul><li>一键安装，秒级同步</li><li>家里的虚拟机再也不用通过端口转发这种粗暴的方式来提供远程使用</li><li>各云厂商的主机再也不用记IP登陆</li><li>换一台全新的电脑也能够立马投入工作，优雅的远程连接到了自己的服务器（elegant~)</li><li><strong>三台主机内还是免费使用</strong></li></ul><p>一番把玩后，作为一个白嫖怪，还是发现了一个盲点：</p><blockquote><p>牧云主机管理助手的定位是：主机管理工具。<br>那么对于白嫖怪来说，我连主机都没有，该怎么办呢？</p></blockquote><h2 id="打开格局">打开格局</h2><p>早期在关注主机白嫖这个方向时，除了各种云厂商的学生党羊毛，还曾注意到一个思路，那就是现在众多的CI平台。</p><p>随着云原生环境的不断发展，越来越多的厂商开始接受DevOps的思路，持续集成(CI)也成为了必不可缺的一个环节。通过持续集成，开发者可以快速、自动、可重复的将代码进行测试、编译、打包等步骤，从源代码生成发布版本。</p><p><img src="/img/908ac14a-013b-491d-ad24-9c67d877508a.png" alt=""></p><p>而持续集成的整个环节，都会提供一个环境供流程进行自动构建。这个执行构建的主机自然就成了我们白嫖怪的目标。</p><p>在最初的思路中，我们能够获取主机操作权限的方式，第一反应通常都是<code>ssh</code>,因此，现有的白嫖版本都是通过各种ssh模拟服务来连接到action VM环境中。（<a href="https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html">https://p3terx.com/archives/ssh-to-the-github-actions-virtual-server-environment.html</a> )</p><p>但是在实际使用中，由于ssh交互的问题，很容易导致断开连接后，整个环境丢失。使用的体验上并没有那么舒适。</p><p>结合最近出现的牧云主机管理助手，突发奇想：能否通过牧云主机助手的方式，来获取到action VM的权限呢？</p><h2 id="实际测试">实际测试</h2><p>如此，我们要做的事情就很明确了：</p><ul><li>让CI执行牧云主机助手部署的脚本</li><li>因为部署脚本是daemon模式，所以我们需要sleep来维持CI存活的状态。</li></ul><p>仅需两步，我们就可以获取到了一个免费的 E5 2vCPU/​7G RAM/​90G SSD主机。</p><p><img src="/img/f2e36e56-ad04-4d72-b3cc-592ff8109dc3.png" alt=""></p><p>为了方便使用，我将上述思路打包成了<a href="https://github.com/marketplace/actions/dvkunion-collie">Github Action</a>，详细代码可以查看 <a href="https://github.com/DVKunion/collie_tricker">Github仓库</a>, 方便开发者快速进行接入。</p><h2 id="使用场景">使用场景</h2><p>在执行Github Action时，无法登陆到实际执行的VM环境中来进行debug，检查构建失败的真正原因。</p><p>此时可以使用上述GitHub action, 通过牧云主机管理助手登陆到debug action的环境中，手动check构建失败的问题，从而避免了修改workflows来进行debug的麻烦方式。</p><p>该场景仅作为抛砖引玉，除此之外，我相信实际能够应对的场景仍有很多，而且牧云主机管理助手仍在以腹泻式进行迭代更新，欢迎大家探索和分享出更多的玩法～</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Github Action : <a href="https://github.com/marketplace/actions/dvkunion-collie">https://github.com/marketplace/actions/dvkunion-collie</a><br>1.Github仓库 : <a href="https://github.com/DVKunion/collie_tricker">https://github.com/DVKunion/collie_tricker</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;白嫖国外主机新思路&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;blockquote&gt;
&lt;p&gt;免责声明: 本文属于纯思路探讨，使用demo代码所造成的影响与作者无关。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="tools" scheme="http://blog.dvkunion.cn/categories/tools/"/>
    
    
    <category term="主机" scheme="http://blog.dvkunion.cn/tags/%E4%B8%BB%E6%9C%BA/"/>
    
    <category term="国外" scheme="http://blog.dvkunion.cn/tags/%E5%9B%BD%E5%A4%96/"/>
    
    <category term="工具" scheme="http://blog.dvkunion.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 踩坑指南</title>
    <link href="http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://blog.dvkunion.cn/2022/03/24/CodeQL-%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</id>
    <published>2022-03-24T10:02:00.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>CodeQL 踩坑指南 - Java</h1><!-- split --><p>讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。</p><span id="more"></span><h2 id="坑I-Lombok">坑I - Lombok</h2><h3 id="场景">场景</h3><p>在构建一些小型cms和自己的一些项目时，突然发现构建好的数据库内源码比实际的源码少了一大半，导致很多规则分析的flow直接断掉了，什么规则扫描结果都没有。</p><h3 id="原因">原因</h3><p>构建好的数据库文件夹下，源码是存放在src.zip下的。通过vscode的插件，将数据库添加后也可以看到构建加载后的源码。通过对比源码，发现丢失的java文件都存在lombok注解（@Data/@Sl4j)。<br><img src="media/16479334970645.jpg" alt=""></p><p>这里的原因就是由于项目使用了lombok。根据官方<a href="https://github.com/github/codeql/issues/8363">Github Issue</a>可得知，lombok 代码在编译期间使用注释处理器转换为正确的 Java 代码。这会干扰 CodeQL 分析器，该分析器会在源代码转换为有效的 Java 代码之前“查看”源代码，从而导致它跳过此类文件。</p><h3 id="解决方案">解决方案</h3><p>按照官方的思路，解决方式就是将所有文件还原为不使用lombok的方式。还原的方案主要有两种：</p><p><strong>1.通过Lombok.jar 直接还原文件</strong></p><p>在官方的<a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">Github Issue</a>提供了一种方式。</p><p>下载项目对应版本的lombok.jar(或者从External Libraries寻找下载好的依赖jar包)，运行：</p><p><code>java -jar lombok.jar delombok . -d &quot;delombok-code&quot;</code><br>这会将当前目录下的所有使用了lombok的代码还原为不使用的状态，并存放在delombok-code这个目录下。</p><p>但是在实际测试中，这种方式不会对项目内关联的代码进行还原，比如自己定义的一些TO类，在这种方式的还原下只会被还原成Object，而不是实际的TO对象。可能会对代码分析造成一定的影响。</p><p><strong>2. 使用maven-delombok</strong><br>这种方式的好处在于可以在maven build的过程中来对lombok进行还原，可以很好的解决依赖关系，不会出现上述还原为未定义的Object的场景。</p><p>在pom文件内增加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>delombok<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">addOutputDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于将所有的还原lombok指向目录/src/main/lombok，所以在maven编译的时候，我们希望编译的是lombok还原后的目录，这样codeql才能够读取整个有效的过程，所以需要修改sourceDirectory</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/lombok</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里提供一个脚本, 快速插入lombok-plugins，将脚本放置项目根目录并运行<code>python3 delombok.py ./pom.xml </code>即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delbankline</span>(<span class="params">file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [x <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines() <span class="keyword">if</span> <span class="keyword">not</span> re.search(<span class="string">r&#x27;^\s+$&#x27;</span>, x)]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        fw.writelines(lines)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">lines = f.readlines()</span><br><span class="line">f.seek(<span class="number">0</span>)</span><br><span class="line">f.truncate()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line"><span class="comment"># f.write(line.replace(&#x27;src/main/java&#x27;, &#x27;src/main/lombok&#x27;))</span></span><br><span class="line">line = line.replace(<span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main&lt;/directory&gt;&quot;</span>,</span><br><span class="line"><span class="string">&quot;&lt;directory&gt;$&#123;project.basedir&#125;/src/main/lombok&lt;/directory&gt;&quot;</span>)</span><br><span class="line">line = line.replace(<span class="string">&#x27;src/main/java&#x27;</span>, <span class="string">&#x27;src/main/lombok&#x27;</span>)</span><br><span class="line">f.write(line)</span><br><span class="line"></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 生成元素</span></span><br><span class="line">sourceDirectory = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">goal = ET.Element(<span class="string">&quot;goal&quot;</span>)</span><br><span class="line">phase = ET.Element(<span class="string">&quot;phase&quot;</span>)</span><br><span class="line">groupId = ET.Element(<span class="string">&quot;groupId&quot;</span>)</span><br><span class="line">artifactId = ET.Element(<span class="string">&quot;artifactId&quot;</span>)</span><br><span class="line">version = ET.Element(<span class="string">&quot;version&quot;</span>)</span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">sourceDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">goal.text = <span class="string">&quot;delombok&quot;</span></span><br><span class="line">phase.text = <span class="string">&quot;generate-sources&quot;</span></span><br><span class="line">groupId.text = <span class="string">&quot;org.projectlombok&quot;</span></span><br><span class="line">artifactId.text = <span class="string">&quot;lombok-maven-plugin&quot;</span></span><br><span class="line">version.text = <span class="string">&quot;1.18.4.0&quot;</span></span><br><span class="line"><span class="comment"># 打包</span></span><br><span class="line">goals = ET.Element(<span class="string">&quot;goals&quot;</span>)</span><br><span class="line">goals.append(goal)</span><br><span class="line">addOutputDirectory = ET.Element(<span class="string">&quot;addOutputDirectory&quot;</span>)</span><br><span class="line">addOutputDirectory.text = <span class="string">&quot;false&quot;</span></span><br><span class="line">sourceDirectory2 = ET.Element(<span class="string">&quot;sourceDirectory&quot;</span>)</span><br><span class="line">sourceDirectory2.text = <span class="string">&quot;src/main/java&quot;</span></span><br><span class="line">outputDirectory = ET.Element(<span class="string">&quot;outputDirectory&quot;</span>)</span><br><span class="line">outputDirectory.text = <span class="string">&quot;$&#123;project.basedir&#125;/src/main/lombok&quot;</span></span><br><span class="line">encoding = ET.Element(<span class="string">&quot;encoding&quot;</span>)</span><br><span class="line">encoding.text = <span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">configuration = ET.Element(<span class="string">&quot;configuration&quot;</span>)</span><br><span class="line">configuration.append(encoding)</span><br><span class="line">configuration.append(addOutputDirectory)</span><br><span class="line">configuration.append(sourceDirectory2)</span><br><span class="line">configuration.append(outputDirectory)</span><br><span class="line">execution = ET.Element(<span class="string">&quot;execution&quot;</span>)</span><br><span class="line">execution.append(phase)</span><br><span class="line">execution.append(goals)</span><br><span class="line">execution.append(configuration)</span><br><span class="line">executions = ET.Element(<span class="string">&quot;executions&quot;</span>)</span><br><span class="line">executions.append(execution)</span><br><span class="line">plugin = ET.Element(<span class="string">&quot;plugin&quot;</span>)</span><br><span class="line">plugin.append(groupId)</span><br><span class="line">plugin.append(artifactId)</span><br><span class="line">plugin.append(version)</span><br><span class="line">plugin.append(executions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多条件判断</span></span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">build = ET.Element(<span class="string">&quot;build&quot;</span>)</span><br><span class="line">root.append(build)</span><br><span class="line">build.insert(<span class="number">0</span>, sourceDirectory)</span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">plugins = ET.Element(<span class="string">&quot;plugins&quot;</span>)</span><br><span class="line">build.insert(<span class="number">0</span>, plugins)</span><br><span class="line">plugins.insert(<span class="number">0</span>, plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relombok</span>(<span class="params">file</span>):</span><br><span class="line"><span class="comment">#删除自带的Lombok插件</span></span><br><span class="line">tree = ET.ElementTree()</span><br><span class="line"><span class="comment"># 去掉ns0标签</span></span><br><span class="line">XML_NS_NAME = <span class="string">&quot;&quot;</span></span><br><span class="line">XML_NS_VALUE = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">ET.register_namespace(XML_NS_NAME, XML_NS_VALUE)</span><br><span class="line">tree.parse(file)</span><br><span class="line">root = tree.getroot()</span><br><span class="line">pre = (re.split(<span class="string">&#x27;project&#x27;</span>, root.tag))[<span class="number">0</span>]</span><br><span class="line">build = root.find(pre + <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> build <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">plugins = build.find(pre + <span class="string">&quot;plugins&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> plugins <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(plugins)==<span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> plugin <span class="keyword">in</span> plugins:</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> plugin:</span><br><span class="line"><span class="keyword">if</span> child.text == <span class="string">&quot;lombok-maven-plugin&quot;</span>:</span><br><span class="line">plugins.remove(plugin)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">tree.write(file, encoding=<span class="string">&quot;utf-8&quot;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    file = sys.argv[<span class="number">1</span>]</span><br><span class="line">    delbankline(file)</span><br><span class="line">    relombok(file)</span><br><span class="line">    delombok(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish!!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="坑II-扩展文件">坑II - 扩展文件</h2><h3 id="场景-2">场景</h3><p>在看官方提供的ql规则时候，有一个特殊的规则引起了注意：<a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">MyBatisMapperXmlSqlInjection.ql</a></p><p>他做的事情是扫描Mapper配置Mybatis XML的${}的SQL注入，但是在我们的源代码中，完全没有看到相关的Mybatis的Mapper XML文件。所以规则扫描一直无效。</p><h3 id="原因-2">原因</h3><p>原因归结于我们没有把对应的xml文件加入到我们的数据库中，在默认的配置中，codeql仅加载了四种xml文件，分别为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AndroidManifest.xml</span><br><span class="line">pom.xml</span><br><span class="line">struts.xml</span><br><span class="line">web.xml</span><br></pre></td></tr></table></figure><h3 id="解决方案-2">解决方案</h3><p>结局方案主要有两种方式。<br><strong>1.拆分<code>codeql database create</code></strong><br>这种方式是在官方的Github Issue 发现的，将codeql database create拆分为几个步骤，并在中间的过程增加配置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">codeql database init --source-root &lt;YourSourcePath&gt; --language java &lt;YourDBPath&gt;</span><br><span class="line">codeql database trace-command --working-dir=&lt;YourSourcePath&gt; &lt;YourDBPath&gt; &lt;BuildCommand&gt;</span><br><span class="line">codeql database index-files --language properties --include-extension .properties --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database index-files --language xml --include-extension .xml --working-dir=&lt;YourSourcePath&gt; --exclude=target &lt;YourDBPath&gt;</span><br><span class="line">codeql database finalize &lt;YourDBPath&gt;</span><br></pre></td></tr></table></figure><p><strong>2.修改<code>pre-finalize</code></strong><br>这里参考了<a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">楼兰师傅的文章</a>学到了一种新的方式。<br>上面这种方法在日常的使用中很麻烦，每次构建分析前还得运行脚本来构建。因此这种方法与方法1对比，提升了很大的便捷性。</p><p>这种方法只提供xml文件的扩展，如果需要扩展其他类型文件，还需要自己手动增加。(因为 --language 参数不同）</p><p><strong>windows:</strong><br>在codeql-cli/java/tools/pre-finalize.cmd插入<code>--include &quot;**/resources/**/*.xml&quot; ^ </code><br><img src="media/16479343916145.jpg" alt=""></p><p><strong>linux:</strong><br>在codeql-cli/java/tools/pre-finalize.sh插入<code>--include &quot;**/resources/**/*.xml&quot;</code><br><img src="media/16479342964394.jpg" alt=""></p><p><strong>加入properties扩展：</strong><br>linux为例：<br>在codeql-cli/java/tools/pre-finalize.sh的结尾找到：<code>if [ &quot;$&#123;LGTM_INDEX_PROPERTIES_FILES:-false&#125;&quot; == &quot;true&quot; ]</code><br>删除掉这个if判断，即可默认加载properties。</p><p>注意，这种方法都加入了size-limit的限制，.xml默认限制10MB，.properties默认限制5MB。</p><h2 id="坑III-分析缓慢">坑III - 分析缓慢</h2><h3 id="场景-3">场景</h3><p>在一些巨型项目中，一次构建+分析可能需要花费10-15分钟，如果在构建的过程中发现忘记加载某些文件，这个过程就要再来一次，重复几次，一天的时间就无了。</p><h3 id="原因-3">原因</h3><p>大型的项目构建速度缓慢，规则分析也很缓慢。</p><h3 id="解决方案-3">解决方案</h3><p><strong>使用mvnd 来代替mvn提速</strong><br>因为我测试的项目大部分使用mvn管理，而在codeql中，mvn默认的构建命令为：<br><code>mvn clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true </code></p><p>首先下载并安装<a href="https://github.com/apache/maven-mvnd">mvnd</a>, 官方的手册已经比较清晰。</p><p>然后修改codeql构建命令，并使用mvnd进行构建<br><code>codeql database create codeqlDB --language=java --command=&quot;mvnd clean package -f &quot;pom.xml&quot; -B -V -e -Dfindbugs.skip -Dcheckstyle.skip -Dpmd.skip=true -Denforcer.skip -Dmaven.javadoc.skip -DskipTests -Dmaven.test.skip.exec -Dlicense.skip=true -Drat.skip=true</code></p><p>如果mvnd没有配置的话，还需要使用<code>-s settings.xml</code>指定mvn的setting配置文件。</p><p>大概优化的时间在20-30s左右，不同的项目优化效果不同。</p><p><strong>规则分析参数调优</strong><br>对于经常需要用到的规则，codeql支持生成qlo的缓存文件，这样下次再分析其他数据库时，就不需要再次compile而是直接进入规则分析了。<br><code>codeql query compile --warnings=hide --fast-compilation --dump-qlo</code><br>对应目录下会生成规则同名的qlo文件。这样在下次分析这个ql时，codeql会自动找到这个qlo作为缓存，加快了compile的过程。</p><h2 id="优化I-python库">优化I - python库</h2><h3 id="场景-4">场景</h3><p>在经历上述坑点之后，我的数据库构建已经成为了一个很复杂的过程。经常需要各种脚本来辅助。脚本的代码就会出现很丑陋的:<code>os.system(&quot;codeql database xxxxxx ......&quot;)</code>, 令人难以忍受。</p><h3 id="解决方案-4">解决方案</h3><p>偶然在Github发现了一个非官方的<a href="https://github.com/AlexAltea/codeql-python">python-codeql库</a>, 封装了大量常用的codeql操作。<br>安装：<br><code>pip3 install git+https://github.com/AlexAltea/codeql-python.git</code><br>使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codeql</span><br><span class="line"></span><br><span class="line"><span class="comment"># Open databases from files or folders</span></span><br><span class="line">db = codeql.Database(<span class="string">&#x27;path/to/db.zip&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries return a CSV-like array of arrays</span></span><br><span class="line">results = db.query(<span class="string">&#x27;select &quot;Hello&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(results[<span class="number">0</span>][<span class="number">1</span>] == <span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries with external libraries are supported as well</span></span><br><span class="line">codeql.set_search_path(<span class="string">&#x27;path/to/codeql&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from BlockStmt block    </span></span><br><span class="line"><span class="string">    select block</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create temporary databases from inlined sources</span></span><br><span class="line">db = codeql.Database.from_cpp(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    int main() &#123;</span></span><br><span class="line"><span class="string">        return 1337 + 1337 + 1337;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">results = db.query(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    import cpp</span></span><br><span class="line"><span class="string">    from Literal literal where</span></span><br><span class="line"><span class="string">        literal.getType() instanceof IntType and</span></span><br><span class="line"><span class="string">        literal.getValue().toInt() = 1337</span></span><br><span class="line"><span class="string">    select literal</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(results[<span class="number">1</span>:]) == <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="优化II-部分规则Demo">优化II - 部分规则Demo</h2><p>有了坑II的支持，现在已经可以扫描如spring boot内的配置文件了。例如H2-Console的JNDI注入。</p><p>在这个规则中，检测了两个事情：</p><ol><li>是否存在com.h2database.h2这个jar.</li><li>是否开启了spring.h2.console.enabled</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.configfiles.ConfigFiles</span><br><span class="line">import semmle.code.xml.MavenPom</span><br><span class="line"></span><br><span class="line">private class H2databaseDependency extends Dependency &#123;</span><br><span class="line">  H2databaseDependency() &#123;</span><br><span class="line">    this.getAChild(&quot;groupId&quot;).getTextValue() <span class="operator">=</span> &quot;com.h2database&quot; <span class="keyword">and</span></span><br><span class="line">    this.getAChild(&quot;artifactId&quot;).getTextValue() <span class="operator">=</span> &quot;h2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ApplicationProperties extends ConfigPair &#123;</span><br><span class="line">  ApplicationProperties() &#123; this.getFile().getBaseName() <span class="operator">=</span> &quot;application.properties&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> H2databaseDependency dependency, ApplicationProperties ap</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  ap.getFile()</span><br><span class="line">      .getParentContainer()</span><br><span class="line">      .getAbsolutePath()</span><br><span class="line">      .<span class="keyword">matches</span>(dependency.getFile().getParentContainer().getAbsolutePath() <span class="operator">+</span> &quot;%&quot;) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">exists</span>( <span class="operator">|</span></span><br><span class="line">    ap.getNameElement().getName() <span class="operator">=</span> &quot;spring.h2.console.enabled&quot; <span class="keyword">and</span></span><br><span class="line">    ap.getValueElement().getValue() <span class="operator">=</span> &quot;true&quot;</span><br><span class="line">  ) <span class="keyword">and</span></span><br><span class="line">  <span class="keyword">not</span> ap.getFile().getAbsolutePath().<span class="keyword">matches</span>(&quot;%test/resources%&quot;)</span><br><span class="line"><span class="keyword">select</span> ap, &quot;该配置存在H2 Database JNDI注入漏洞&quot;</span><br></pre></td></tr></table></figure><p>这里只是抛砖引玉，有了配置文件，可以快速的对比SCA，来检查是否使用了存在漏洞的三方jar包。</p><h2 id="结尾">结尾</h2><p>暂时想到的就这些，还有一些从网络上学到的一些小东西就不丢人现眼了...如果有错误或其他的一些小tips，恳求各位师傅指点一二🙇。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Github Issue : <a href="https://github.com/github/codeql/issues/8363">https://github.com/github/codeql/issues/8363</a><br>1.Github Issue : <a href="https://github.com/github/codeql/issues/4984#:~:text=Unfortunately%20Lombok%20does%20not%20work%20with%20the%20CodeQL,the%20source%20files%20before%20running%20CodeQL%20as%20follows%3A">https://github.com/github/codeql/issues/4984#:~:text=Unfortunately Lombok does not work with the CodeQL,the source files before running CodeQL as follows%3A</a><br>2.MyBatisMapperXmlSqlInjection.ql : <a href="https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql">https://github.com/github/codeql/blob/main/java/ql/src/experimental/Security/CWE/CWE-089/MyBatisMapperXmlSqlInjection.ql</a><br>3.楼兰师傅的文章 : <a href="https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg">https://mp.weixin.qq.com/s/egjA2xFm_ziGHjJ7IxOCbg</a><br>4.mvnd : <a href="https://github.com/apache/maven-mvnd">https://github.com/apache/maven-mvnd</a><br>5.python-codeql库 : <a href="https://github.com/AlexAltea/codeql-python">https://github.com/AlexAltea/codeql-python</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;CodeQL 踩坑指南 - Java&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;讲解这东西的大师傅们太多了，不班门弄斧了，这里仅针对一些踩过的坑点提供一些自己的解决方案，希望能对一些师傅提供点帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="http://blog.dvkunion.cn/categories/Coding/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="代码审计" scheme="http://blog.dvkunion.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Harbor 未授权漏洞的背后是魔幻的荒诞主义</title>
    <link href="http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/"/>
    <id>http://blog.dvkunion.cn/2022/01/19/Harbor%20%E6%9C%AA%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%83%8C%E5%90%8E%E6%98%AF%E9%AD%94%E5%B9%BB%E7%9A%84%E8%8D%92%E8%AF%9E%E4%B8%BB%E4%B9%89/</id>
    <published>2022-01-19T13:12:11.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>Harbor 未授权漏洞的背后是魔幻的荒诞主义</h1><h2 id="前言">前言</h2><p>怎么说呢，心里五味杂陈，面对在大年前横空而来的 <code>CVE-2022-46463</code>，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇文章。突然感觉安全已经进入到了一个魔幻的荒诞主义：我们还有什么可信的东西？</p><p>大家可以当作一篇小说看看吧。</p><h2 id="事情经过">事情经过</h2><p>事情要从我的一个安全朋友说起。</p><h3 id="起因">起因</h3><p>1.16日，天高气爽，想着还有两天就要放假回家过年的心，根本无法集中在工作中，于是在摸鱼冲浪的时候，突然发现了一篇紧急通告，</p><blockquote><p>CVE-2022-46463 漏洞预警</p></blockquote><p>很快啊，赶紧点进去一看，发现是一个名为<code>harbor</code>的未授权漏洞，<strong>私有</strong> 和 <strong>公开</strong> 仓库镜像可以被未授权获取，可能导致敏感信息泄漏。</p><p>一打眼看到的漏洞评级 <code>严重</code> 吓了一激灵，并且显示<code>POC</code>已经在野利用了？还两天过年了，要是这么严重的问题，还怎么安心回家过这个团圆？</p><p>由此，开启了一段魔幻的 &quot;漏洞&quot; 修复过程。</p><h3 id="追踪">追踪</h3><p>根据互联网的信息，发现各平台预警，除<code>CVE</code>外，所有链接均指向了一个 <code>github</code> 仓库，</p><blockquote><p><a href="https://github.com/lanqingaa/123">https://github.com/lanqingaa/123</a></p></blockquote><p>在这个<code>github</code>仓库里，标记的很清楚的复现步骤啊：通过登录页面的搜索接口，可以搜索到显示为 <code>私有</code> 项目的仓库。</p><p>这还是挺吓人的，利用方式简单、影响严重，可能会导致公司几千个私有镜像被他人获取，后果不堪设想。</p><p>按照cve给出的影响范围：</p><blockquote><p>1.x &lt;= Harbor &lt;= 2.5.3</p></blockquote><p>很不幸，自家的harbor正好在范围内，看来年前又要找运维大哥去帮忙修复了。</p><h3 id="坎坷的复现">坎坷的复现</h3><p>去找运维大哥帮忙，作为安全人员，肯定先要自己搞明白了再去摇人，于是就拿着公司的harbor尝试了一下，发现好像有点不对劲： 不论我怎么搜索，从 <code>a-z</code>都只能显示<strong>公开</strong>仓库的数据，并无漏洞所描述的 <strong>私有</strong>仓库数据。</p><p>会不会是复现的步骤有问题？又重新读了一遍整体的逻辑，会不会是我们公司的仓库就没有 <strong>私有</strong> 属性的呢？</p><p>赶紧去和运维大哥确认了一下，发现的确存在 <strong>私有</strong> 镜像，可为什么这个漏洞却搜不到呢？</p><p>怀着窘迫的心在<code>harbor</code> 官方仓库不断寻找，发现，好像官方也没对这个漏洞进行相关 <code>fix</code>的提交记录哎，那预警里面的 <code>请升级到最新版本</code> 是如何得出的呢？</p><p>一定是自己功夫还不够深，一定是自己的姿势还不太对，此时的菜鸡的安全人员还没有意识到问题的严重性和魔幻性，依旧还在自身寻找问题。</p><h3 id="反转">反转</h3><p>1.17日，复现一天无果的安全人员，气急败坏只能继续摸鱼，然后发现了另一篇通告：</p><blockquote><p>关于Habor CVE-2022-46463的说明</p></blockquote><p>文章大概就是经过测试，所有版本都没有搜索到私有仓库；同时还分析了<code>search</code> api 的认证逻辑。官方手册指出 公开仓库 能够被搜索到，属于产品特性。这个CVE甚至称不上是漏洞。</p><p>事情开始变得魔幻起来了。</p><h3 id="未完待续">未完待续</h3><p>从事情开始出现反转后，便开始出现了各路声音：有人为这个漏洞就不该出现CVE的；有认为Harbor设计不合理的，就因该算Harbor的漏洞；有认为Harbor应该修改默认选项来避免出现滥用的不安全配置的，等等等等。</p><p>截止至发文今日，搜索该CVE编号，依旧能够发现大量的&quot;安全公告&quot;,无一例外都是相同的漏洞描述，相同的影响范围，相同的修复建议。</p><p>我们仍未知道那天所看见的cve的名字。</p><h2 id="来关注漏洞">来关注漏洞</h2><p>故事讲完了，我们来实际关注下漏洞。</p><p>根据 <code>https://github.com/lanqingaa/123</code> 所描述的<code>poc</code>, <code>harbor</code> v1 v2版本均存在该问题，但是自己观察会发现，该作者在v1的截图中的确搜到了显示为 <code>private</code> 的仓库：<br><img src="/img/16740212582611.jpg" alt=""></p><p>但是在 v2 的版本中，他给出的结果却是 <code>public</code> 仓库。<br><img src="/img/16740213120010.jpg" alt=""></p><p>再回看漏洞描述：</p><blockquote><p>Harbor 中存在访问控制错误问题，允许攻击者无需身份验证即可访问公共和私有镜像存储库的所有信息，并拉取镜像。</p></blockquote><h3 id="理清逻辑">理清逻辑</h3><p>首先要明确一下几个点：</p><ul><li>第一，私有化仓库到底能不能像漏洞所描述的那样，被搜索发现？</li><li>第二，仅能访问到公开仓库，是否还能被称之为漏洞？</li></ul><p>如果第一点成立，那么 <code>CVE-2022-46463</code> 无疑是一个高危漏洞，未认证户通过该漏洞可以获取到了认证用户的权限，明显的越权问题。</p><p>如果第一点不成立，也就是该接口只能获取到公开仓库的情景下，问题自然而然的来到了第二点：如果仅能够访问到公开仓库的信息，是否还存在风险呢？</p><p>在讨论第二点的同时，我们还需要预先讨论一个问题：</p><ul><li>公开仓库的概念到底是面向所有认证用户还是所有用户？</li></ul><p>带着这几个问题，我们亲自去复现一波这个魔幻的 <code>CVE-2022-46463</code></p><h3 id="复现">复现</h3><h4 id="v2">v2</h4><p>因为目前harbor的release多数为v2, 就先使用v2的版本进行了复现：</p><p>首先我们用权限账户登陆，可以看到仓库存在 private/public两种项目。<br><img src="/img/16740218044242.jpg" alt=""></p><p>其中，私有的library内存在如下镜像。</p><p><img src="/img/16740218419115.jpg" alt=""></p><p>我们退出账户，尝试去搜索：<br><img src="/img/16740218684380.jpg" alt=""></p><p>毫无结果，再尝试搜索一下公开镜像：<br><img src="/img/16740218947330.jpg" alt=""><br>确实获取到了列表信息。<br><img src="/img/16740219359533.jpg" alt=""></p><p>总结: v2仅能够搜索到公开镜像。</p><h4 id="v1">v1</h4><p>在测试无果的情况下，想到：会不会是v1和v2的版本存在差异呢？</p><p>于是我们来尝试，使用和<code>https://github.com/lanqingaa/123</code> 作者完全一致版本的v1进行尝试：<br><img src="/img/16740185412406.jpg" alt=""></p><p>与v2相同，我们先创建私有的仓库，然后上传测试镜像：</p><p><img src="/img/16740220897858.jpg" alt=""><br><img src="/img/16740221142173.jpg" alt=""><br>然后退出登录，尝试搜索私有仓库：<br><img src="/img/16740185766211.jpg" alt=""><br>无果，再尝试搜索下公开的 <code>library</code> 仓库<br><img src="/img/16740221399539.jpg" alt=""><br>？？？ 的确出现了私有仓库，但是仔细看？是在管理面板内为<code>public</code>权限的<code>library</code><br><img src="/img/16740221754902.jpg" alt=""><br>为了更有效的说明这个事情，我们再创建个公开仓库：<br><img src="/img/16740222082857.jpg" alt=""><br>然后退出登录，再次搜索：<br><img src="/img/16740222537273.jpg" alt=""><br>结果两个公开仓库都被搜索出来了，而且还标注着<code>private</code></p><p>.......看到这里的各位，应该能猜测这是一个什么问题了。</p><h2 id="个人观点">个人观点</h2><p>经过复现，我想大家也知道这个 <code>CVE-2022-46463</code> 到底是个如何的漏洞了：通过该接口，能够搜索到所有的公开仓库。</p><p>对于第一点，已经没有讨论的必要了，问题来到第二点：仅能搜索到公开仓库，到底还是不是一个漏洞。</p><p>在判断是否是个漏洞之前，需要先达成两点共识：</p><ul><li>public 镜像，到底是面对所有用户，还是所有的认证用户。</li><li>到底什么才叫做漏洞</li></ul><p>个人认为，harbor很明显的认为 public 镜像是针对所有用户。可以从官方的手册上搜索到public 的概念，也可以类比 dockerhub 私有镜像和公开镜像的概念。因此我个人认为，public 的定义并无任何问题。</p><p>而至于：什么是漏洞，我想引介《我的安全世界观》中的观点：</p><blockquote><p>程序的目的是为了实现业务功能<br>程序的实现可能额外实现了些其他的功能<br>这些其他的功能影响到安全，就可以被称漏洞。<br>其中，影响安全才是定义的关键。</p></blockquote><p>来看这个api的设计，harbor的定位就是想要搜索到所有的 public 镜像，程序完美的实现了目的，且没有搜索到额外的private镜像。 程序没有做超出业务功能的事情；同时在官方的手册里，清晰明了的定义着什么是<code>public</code>权限。</p><p>除此外，我们再来看影响：搜索到公开仓库，会对企业带来什么样的影响，有怎样的安全隐患。</p><p>在该漏洞所描述中，公开仓库可能会“导致信息泄露”，获取到镜像信息。</p><p>我们知道，镜像其实就是一个打包好的分层的文件系统。那么对于获取到这个文件系统的人来说，他可以获取到这个镜像内部的任何信息。</p><p>如果说是由于harbor 的原因导致的这部分信息泄漏，那么即使是公开的镜像，harbor 也应该为这个事情负责。而事实是，任何获取到这个文件系统的人，都能够获取到harbor 所展示出的这部分信息。 这样来讲，harbor只是个搬运工而已，仅仅展示了一些任何人都能够读到的数据而已。导致信息泄露的，应该是归属于 <strong>“镜像安全”</strong> 的范畴。</p><p>因此，我们应该把漏洞中所描述的“敏感信息泄漏”，视作是镜像安全问题，而并非harbor 应用本身。漏洞的原因是在于镜像夹杂了不应该被打包进去的数据。该问题并不关心你是用的是harbor 仓库还是portus 仓库，还是dockerhub 仓库，他就是这个镜像本身携带的问题。</p><p>唯一能被视为漏洞影响点的，就是在于，用户如果想获取有哪些镜像的这个信息，原本只能够通过猜测或已知的镜像名称，通过pull 的方式获取到镜像本身。在未知镜像名的条件下是比较困难批量获取到更多信息的，只能尝试暴力猜解。而公开仓库搜索提供了这样一个便利的入口来展示当前能获取的镜像列表，对攻击者提供了帮助。</p><p>这样，问题又回到了第二个点。public 仓库面向所有用户而非认证用户，是否存在问题。</p><p>当业务功能存在部分风险时，那么应该告知并警惕用户使用的方式，正确使用该功能。我们来看下harbor是如何做的：<br><img src="/img/16740177839330.jpg" alt=""><br><img src="/img/16740178868992.jpg" alt=""><br>在项目创建页面，harbor清楚的描述着 什么叫做public仓库，告知了： &quot;无需login即可docker pull&quot;。同时，公开仓库还是一个非默认选项，默认创建的仓库都是私有的。我实在想不出还有什么别的方式能够来&quot;帮助&quot; 用户 建设意识上的安全问题。</p><p>就好比 php exec函数，你不能说exec可能会执行恶意命令，就直接说php存在漏洞，而直接不允许了业务使用该函数。exec本身并不是漏洞，但当你使用的方式不正确时，的确会造成一定的安全风险。这个比喻模型同样可以适用于 <code>CVE-2022-46463</code>。</p><h2 id="综合评估">综合评估</h2><p>最终，我们为这个&quot;漏洞&quot;（如果非要说是的话，毕竟有了CVE编号）做一个客观的评估。</p><h3 id="漏洞描述">漏洞描述</h3><p>Harbor api search 允许未认证的用户搜索仓库内存在的 公开仓库，若将私有业务镜像放置于公开仓库，可能存在信息泄漏风险。</p><h3 id="漏洞级别">漏洞级别</h3><p>中危偏低，无需紧急修复，但仍需引起注意，排查仓库权限设置是否正确。</p><h3 id="漏洞修复建议">漏洞修复建议</h3><p>官方最新版本仍存在上述特性，升级修复属于无稽之谈。</p><h4 id="对于无public需求的用户">对于无public需求的用户</h4><p>直接全部设置为私有项目即可。</p><h4 id="对于仍需public功能但又担心风险的用户">对于仍需public功能但又担心风险的用户</h4><p>可以手动创建一个全局用户，然后将这个用户添加到所有项目中，最后将所有项目设置为私有。</p><p>这么做可能会导致，原本可以直接获取到的镜像信息，现在都需要使用该账户进行认证后获取，可能会对您的自动化业务(如 CI/CD) 产生影响。</p><p>除此之外，您也可以考虑从根源解决问题。该漏洞最大的安全隐患在于 敏感信息的泄漏。而这些风险来自于没有进行过安全检查的公开镜像。因此，可以使用云安全工具进行检测，如：使用 <a href="https://rivers.chaitin.cn/app/veinmind">Veinmind-SaaS</a> 版本对harbor仓库进行扫描，支持云探针扫描方式，无需部署探针，实现快速一键式解决公开镜像的安全问题：<br><img src="/img/16740240275239.jpg" alt=""><br>也可以选择轻量级的 <a href="https://github.com/chaitin/veinmind-tools">Veinmind-Tools</a> 对您重点关注的镜像，一一进行人工排查，保证您的镜像安全。<br><img src="/img/20220415144819.gif" alt=""></p><p>除此以外，对于仍认为 <code>public</code> 仓库应该在登陆后才能够被访问的用户，可以选择非harbor的同级别产品如<a href="http://port.us.org/documentation.html">portus</a>，所有的仓库必须在登陆后才有权限访问，即使是public仓库。</p><h2 id="最后">最后</h2><p>整个CVE 从最初的大家都无法复现却存在编号的漏洞，到有人站出来说根本不应该称之为漏洞，再到认为Harbor的设计不合理，没有做到所谓的“尽可能的安全设置作为默认设置”，到最后的呼吁不要仅关注漏洞本身，而是要更关注客户的安全，为客户负责的角度。 这个&quot;漏洞&quot;属实在2022年的年终 荒诞而又魔幻的 结束了这荒诞而又魔幻一年。</p><p>从安全的角度来想，我不理解为什么这样的一个&quot;漏洞&quot;，如此简单粗暴的过程，无官方的fix记录，仅有一堆雷同式的公告，却鲜有不同的声音。</p><p>从产品的角度上来想，我觉得这类的安全问题，并不是一个产品上能够 cover 的事情，而是用户意识上的安全。类比弱口令，如果我们真的认为，默认复杂的密码就可以解决弱口令的问题，而没有关注用户自身意识的安全建设，那么对于安全意识较差的用户来讲，他甚至可能会觉得默认密码过于复杂而吐槽产品，然后自行将密码修改为了弱口令。为什么一个开源的产品，明确写的特性，明确写的功能提示，还需要为用户的安全意识建设买单？</p><p>手机很好用，但你总担心手机屏幕的屏保图片会被别人偷窥到你的隐私，你很担心，因为你把有银行卡密码的图片作为了屏保，说这个手机要是屏幕保护不会被偷窥就好了，手机做的还是不够好啊。</p><p>有没有一种可能，当大家都意识到屏幕保护就是要给别人看的时候，就不会把隐私的图片，设置为屏幕保护了？我们作为专业人员要做的，是告诉用户，用密码做屏幕保护，这么做不安全，提高用户的意识，而不是和用户一起诟病手机这产品为什么不去做一个只有我自己能看到屏幕保护的功能，去对线开源社区去争执一个特性到底是否是漏洞。</p><p>见贤思齐焉，见不贤而内自省也。不论这个CVE最终会如何收尾，不论这个事情会走向何种结局，对于使用了harbor的用户，看到了这个CVE, 都应该思考一下，对于public的理解是否正确，自家使用的harbor会不会同样存在安全隐患；是否需要考虑镜像安全的检测来加强防护。</p><p>最后也希望，大家能对开源社区多一些包容，多站在互相的角度进行思考，多把精力集中到一些有价值的事情上去。安全和产品，从来不应是对立面，也永远不会是对立面。</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Veinmind-SaaS : <a href="https://rivers.chaitin.cn/app/veinmind">https://rivers.chaitin.cn/app/veinmind</a><br>1.Veinmind-Tools : <a href="https://github.com/chaitin/veinmind-tools">https://github.com/chaitin/veinmind-tools</a><br>2.portus : <a href="http://port.us.org/documentation.html">http://port.us.org/documentation.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Harbor 未授权漏洞的背后是魔幻的荒诞主义&lt;/h1&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;怎么说呢，心里五味杂陈，面对在大年前横空而来的 &lt;code&gt;CVE-2022-46463&lt;/code&gt;，以及一通测试复现后，面对着电脑屏幕久久说不出话来，于是便有了这篇</summary>
      
    
    
    
    <category term="Bugs" scheme="http://blog.dvkunion.cn/categories/Bugs/"/>
    
    
    <category term="云安全" scheme="http://blog.dvkunion.cn/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    <category term="漏洞跟踪" scheme="http://blog.dvkunion.cn/tags/%E6%BC%8F%E6%B4%9E%E8%B7%9F%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>给学弟学妹的一封信</title>
    <link href="http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://blog.dvkunion.cn/2020/06/22/%E7%BB%99%E5%AD%A6%E5%BC%9F%E5%AD%A6%E5%A6%B9%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/</id>
    <published>2020-06-22T20:09:12.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>给学弟学妹的一封信</h1><p><i>2020-6-22</i><br>我毕业了......</p><hr><h2 id="b-0x00-序-b"><b>0x00 -- 序</b></h2><!-- split --><p>首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。</p><p>写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个<b>学妹</b><del>(和学弟)</del>会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。</p><p>希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡</p><span id="more"></span><blockquote><p>P.S. 写完了之后我发现我的废话真的是很多，所以在这里加一个课代表的座位总结一下每个章节的重点，供后辈们有选择性的进行阅读，珍惜各位的时间。</p><ul><li><a href="#0x0A">0x01 我的大学四年生活详情</a></li><li><a href="#0x0B">0x02 大学四年期间的一些个人感悟和心得</a></li><li><a href="#0x0C">0x03  Q&amp;A 一些常见问题</a></li><li><a href="#0x0D">0x04 个人的一些建议</a></li><li><a href="#0x0F">0x05 祝福语</a></li></ul></blockquote><h2 id="b-id-0x0A-0x01-我的四年-b"><b id=0x0A>0x01 -- 我的四年</b></h2><p>现在想想四年的时间真的是过的很快，2016年刚入学校时候第一个感觉是略有失望，因为学校太小哈哈哈哈哈我总以为大学起码要大一点才能突显和高中的不同。其实总的来说我们学校地理位置还是很优越的，毕竟不是哪个学校都能紧挨着一个湖，离火车站一站地铁、市中心3站地铁的优越位置。╮(╯_╰)╭</p><p>大一刚入学，我是彻底的玩了一年，毕竟经过了恶心的高中终于解放了，所以大一基本没什么好说的，参加各种社团活动，各种团建，爽是真的爽，但是欠下的债总要还的。</p><p>到了大二才算是准备看一看自己能够做些什么了，大二也是我参加各种活动最多的一年。从参加蓝桥杯为契机，到参加电子设计竞赛，再到大创、数学建模、ACM区域赛(我太菜了都不好意讲出来)，直到最后的CTF竞赛。基本算是学校本院内能够参加的一些竞赛我都在这一年内去尝试了一遍(也就是尝试了一遍而已，基本都是成功参与(´Ａ｀。))。有好处也有坏处吧，好处是我就和逛菜市场一样转了一大圈最后才买到自己想要的萝卜，但总归是买到了，而且在这个过程中也学到了不少新鲜的东西。坏处就是浪费了整整一年的时间，才发现了自己喜欢和想要去做什么。</p><p>我一直是电子系专业的，但是实在是对各种电路打不起兴趣，也尝试去参加电子设计大赛试试能不能改观一下对这个专业的印象，然后并没有什么卵用，喜欢就是喜欢，不喜欢就是不喜欢。当时在大一结束也考虑不如直接就转专业去计算机系，然后纠结的考虑了很久之后觉得要重修的课比较多，同时还比较年轻，有自信觉得就算在电子系也能兼顾两边进行学习....(〒︿〒)我也不知道我哪来的自信(其实就是懒不想补课)。然后就错过了最佳的转专业的机会，到了大二专业课开课后就十分的难过了.....信号系统真不是人学的。(QAQ)</p><p>也是因为大二和学长(钱学长)交流之下，我确定了不去参加考研。当时的眼光还仅限于在学校之内，接触到、了解到的事物还仅限于学校之内。在大二升大三的暑假和学长的交流下才了解到出了校门之后，外界使用的一些技术、都有哪些工作、工作都是干些什么的。这也是当时学长给我的最好的建议，如果已经决定不考研的话，能尽早出来感受一下工作的分为就尽早感受，这样你能很快的了解到，互联网这个行业到底是一个什么样子的，而不是仅在学校这个像庇护所一样的圈子内一直坐着等着。</p><p>于是大三就是我走出舒适圈的一个转折点，因为不是计算机专业，计算机网络、Linux等等基础性的东西我都仅是一知半解，没有一个体系化的知识框架，再加上我个人的自制力比较差，自学可能就是三天打鱼两天晒网最后不了了之了，我报了一个外部的培训班，算是从宏观面上整体的对基础性的知识有一个体系化的学习和了解。同时也充分利用学校的资源，蹭了几节胡老师的计算机网络的课，也得到了不少的收获。</p><p>总的来说，大三是我在确定了自己的方向后，开始针对这个方向需要的一些技能和要求进行专业性的学习。也是最痛苦的还债的一年。基本上是周一周五先要照顾自己专业的课程，有空课去计算机系蹭一下课，周末两天要坐地铁到南大附近上课培训，基本是没有什么休息的时间了。晚上回来之后还要去更新笔记，如果有操作的一些东西尽量都要自己动手去操作一遍。这样度过了一个难熬的学期。</p><p>然后就到了大三的寒假，准备开始尝试投递简历找一份实习了。第一次投简历也是很愁人，怎么做简历、怎么找公司信息、怎么准备笔试面试...都没有做过，也不知道怎么去准备。也不知道自己的技能有没有符合招聘的标准、能不能胜任岗位的工作、会不会太菜了被面试官笑话等等等等...相对来说投简历的确会十分焦虑，每天期待着自己的邮箱多一个小红点，然后发现收到的邮件是：很抱歉，您不符合我们的岗位要求。心态直接炸裂......</p><p>但最终还是找到了一家在南京本地的实习机会。出来实习之后就真的发现，工作和学校里就有着很大的区别。基本上很少有时间来给你去进一步的沉淀自己的知识积累，工作就是把你以前所有积累的东西拿出来用一用了，你沉淀了多少东西，就能在工作中产生多大的价值。</p><p>也是因为有了这一段宝贵的实习经历，让我在后面的正式应届招聘里有了一张强力的底牌，也是最后我认为能拿到offer的关键一点。<b>所以如果你确定是不考研准备工作，那么务必！务必！要找一个有价值的实习工作。  </b></p><p>总的来说我的四年大学生活，其实真的就是只有三年，第一年用来娱乐享受；第二年参加各种竞赛，认识了各种各样有趣的人和朋友，参加到了计协大家庭，给了我很多前进的动力；第三年用来艰苦奋斗，开始为自己喜欢的事情做好充足的准备；第四年的时候就已经很少在学校了。</p><p>时间是真的过的很快的，我的大学四年也大概就是这个样子。</p><h2 id="b-id-0x0B-0x02-个人心得-b"><b id=0x0B>0x02 -- 个人心得</b></h2><p>如果说要让我来谈一下大学四年间生活的一些感悟和心得，那我觉得最重要的就是，<b>在大学期间加入了自己喜欢的圈子，认识了一群有趣的人。</b>我一直很感激能加入了计协，从一开始的C代码都写不好的菜鸡，被郭佬吉佬带到能称为计协技术部部长：计协有大一黝黑平头、满嘴火车炮但是认真教你写代码的郭佬(狗头)、陪我在机房一起熬到9点多的杜杜、一起准备比赛的吴同学、专业知识丰富的吉佬等等；也很感激在参与众多竞赛遇到的各路大神，像在数模认识的陆大佬、蒋神，他们的逻辑思维和数学能力给了我不少启发，还有我的数模队友，漂亮的写手李小姐姐、专业严谨的冯同学、以及提供给我不少工作经验的郑同学；以及在其他竞赛里遇到的在其他领域突出的一些大佬。在和大佬的交流和生活之中会不自然的被他们影响，朝着他们学习。所以我很感激通过各种方式能够认识这些优秀的人，从他们身上或多或少的学习到一些东西。</p><p>除此之外，我觉得在我大学生活中同样起到很大帮助的是和<b>正确的</b>老师多沟通。老师往往能给我们很多的经验和处理问题的方法，具有很高的参考价值。多和好老师<b>(纳姐)</b>多多沟通，听一听老师的建议往往对你迷惑的时候会很有帮助。</p><p>再要回想的话，也就是能感谢在大三坚持下来的自己吧。刚入门的时候真的是什么也不会、什么也做不出来。研究一个东西一星期最后什么结果也没有，能在这种绝望的情况下一次又一次的坚持下来，沉淀出到现在的一些东西，可能换做现在的我是已经做不到了的。</p><h3 id="b-id-0x0C-0x03-Q-A-一些问题-b"><b id=0x0C>0x03 -- Q&amp;A 一些问题</b></h3><p><b><font color = "red">Q：到底是应该考研还是工作？ </font></b></p><p><b>Me:</b> 这问题在大二暑假就很折磨我，我想一般处在这个时间节点的同学都有着这个问题，我到底是应该考研还是应该准备工作？还是应该着手两方面同时准备？</p><p>在大二之前，我是没有什么想法的，对社会上有哪些工作岗位、工作具体都是做些什么的都不了解，对考研也只有一个是升学的概念。眼看已经大二升大三了，准备考研的同学都开始准备要复习了，我却还没决定好到底是考研还是工作。然后就在一个偶然的机遇下和已经工作的学长聊了聊，给了我不少的启发，然后就奔向&quot;愉快&quot;的工作了。</p><p>至于我个人，我依旧是这个看法：考研和工作，应该取决于你到底想要做什么？考研能让你有一张更具有竞争力的王牌，能够让你在未来的竞争中能从大众的筛选线脱颖而出；同时考研给了你更多的缓冲期，你可以用更多的时间去积累、沉淀你的知识和技能。而工作，锻炼的更多的是你的综合能力。因为企业招聘应届生通常看中的更多是这个人的可塑性，所以更考察你接受新事物的能力、学习能力、以及和工作同事、上级的沟通能力、执行能力，最后还要求你的技能要能够符合岗位基本需求，相比考研更像是开始应用你这些年积攒下的知识财富。</p><p>通过对这两个不同路线的描述，你要考虑的是未来的你想要做一些什么？ 未来是想要进入大厂，在技能上做一些研究？还是想要接触最前端的技术，做一些人工智能、大数据分析等等听起来很上流的工作？还是准备搞科研，读博士，或者是就是想做一个码农，搞开发？根据你想要做的事情的不同，你要选择那条路也就一清二楚了。要说的是，这两条路没有什么好坏之分，没有什么哪一条比另一条会更好这一种说法，只要你能确认，你是因为自己想要做的事情需要我考研(或工作)，而不是因为跟随大家&quot;好多同学都考研(工作)了我也去考研吧(工作吧)&quot;这种想法，我觉得就没有任何问题。</p><p><b><font color = "red">Q：计算机专业出身到底能做些什么事情？</font></b></p><p><b>Me:</b>说实话对于这个问题我只能以我现在的菜鸡视野来给你们解答，因为我也是一个刚入职场的小白。一般来说，互联网行业从服务对象上来分类分为甲方和乙方：甲方通常指提出需求的一方，而乙方就是来实现甲方爸爸需求的一方。按照这种分类，公司的职能体系也会有所不同，招聘的岗位也会有所不同。</p><p>技术岗位通常会比较偏向技术，需要有一定的专业技术能力，如开发岗，包含各种各样的语言开发：java、python、go、c++等等，岗位顾名思义就是进行产品代码开发；还有运维岗：这个岗位偏向IT技术一些，需要对电脑的常识和硬件有一定了解，日常负责维护机房、监控一些服务的运行状态等等。大一点的公司运维岗会分的很细，有专门负责网络的网络工程师、负责维护和监控服务器的运维工程师，负责数据库维护的DBA等等；再大一点的公司可能会有架构师的岗位，负责设计公司某个项目的整体框架：使用哪些技术栈、要用什么语言、什么协议进行通信，数据库的选型等等；除了这些之外还有很多很多的岗位：测试岗，测试开发岗、自动化岗位等等等等。很多公司还会按照自己的需求去招聘一些公司特有的岗位。</p><p>如果你还不知道自己想做什么，不妨去各大大型互联网公司的官方招聘网站上，看一下招聘的岗位和岗位需求描述。你能够很快的知道，大公司里面有什么样的岗位、使用什么样的技术，后面在学习的时候可以针对性的在这个方面进行研究学习。</p><p><b><font color = "red">Q：XXX竞赛有价值吗？值得参加吗？</font></b></p><p><b>Me:</b> 如果你是一位大一或大二的同学，不论你提问的竞赛是什么，我都会告诉你，有价值！参与就完事了。但是如果你已经大三或步入大四了，那么我觉得你就要考虑一下，这个竞赛到底是做什么的，对我到底能不能起到一些帮助。因为在大一和大二，你是有大把的时间来进行不断地尝试，来遇见各式各样的人，竞赛会成为一个很好的平台来帮助你丰富完善你的大学生活；而大三大四你已经要开始为马上到来的远征准备冬粮，时间是十分宝贵的，你能在这个冬天存多少粮食，在未来的考研战场或是面试战场上你就有多少的底气去拼。所以每一个选择都要问一下自己，是否还需要这样做了。对于大三和大四的同学，我觉得不仅仅是要考虑竞赛这个问题，对于一些其他的活动，都应该以这样的一个角度去思考了。因为到了这个节点时间真的是很不够用了。以工作为例，大三上学期的寒假最好就可以去尝试投递简历、尝试找一份实习的工作，大三下的暑假就已经是秋招了。<b>千万不要以为秋招是大四暑假毕业才开始的!!!!!</b>而且很多大厂的秋招和春招都会有提前批，使你的准备时间更少。时间还是非常宝贵的。</p><p><b><font color = "red">Q：怎么准备春招/秋招？</font></b></p><p><b>Me:</b> 首先准备春招/秋招，你需要一份简历。对自己没有那么足的自信的同学，我建议你需要一份自己的简历模板。什么意思呢？就是你需要按照不同公司对岗位的描述，来修改你的简历，有针对性的投递，这样成功率往往会成功很多；对自己经历和技能很满意的，也可以直接做一份通用式的简历，然后直接拿出来用就可以了。简历没有什么具体的要求，它类似于一份自我介绍，让对方企业以最快的方式了解你这个人。一般来说要包含你的个人信息、学校经历(觉得自己成绩不错的同学也可以在简历里提一下，突出你自己的优势)、实习或工作经历等。<b>简历很重要，往往后面的面试过程，面试官都是根据你的简历里面写的内容进行提问的，所以不要为了满足岗位要求而写了一堆虚假的信息。</b></p><p>一般来说 春招 是 秋招的一些补充，往往秋招没有招满的企业会继续在春招发布招聘启事，或事招聘一些实习岗位。<b>所以春招是寻找实习的最佳机会。</b>一般春招是从寒假的年后开始，2-3月份的样子，当然像腾讯阿里等等通常都会提前开启招聘通道，需要自己去关注。</p><p>秋招就是正式的应届招聘了，一般秋招在6-8月份开始，近些年出现的提前批等等导致其实在4月、5月就已经有一些秋招的信息了。这些招聘信息你可以在一些应届招聘的网站如：牛客网、实习僧等等找到统一的招聘启事，偶尔还有有内推的帖子；但最正规的途径还是去这个公司的官网。找到一个名称类似于人才招聘的链接，然后一般大厂都会有专门的校招页面。可以在这里面去寻找本年度该公司需要的人才。这样做同样也有一个好处：你的简历是直接推送到对方企业的，而不是经过那些第三方平台的存储，可以减少你个人信息泄漏的风险。</p><p>我当时的方法是：通过牛客网等等提供的统一招聘信息，知道了有哪些公司在进行招聘，然后通过谷歌去找到他们官网，在他们的官网获取到更详细的信息后进行投递。</p><p>春招秋招的大体流程都是差不多的，投递简历，等待简历筛选，通知笔试/面试，参加一面/二面/三面......最后如果都通过了进入HR面，和你谈论你的薪资定位以及公司的福利待遇，如果没什么问题就会给你发放offer进行签订，招聘的流程基本就完成了，剩下的就是等毕业后拿着毕业证、学位证去公司报道就可以了。</p><p>在投递简历的时候我个人的建议是：多尝试！不要怕失败，因为失败最多就是收不到回复邮件或是收到了拒绝邮件....(´Ａ｀。)多被拒绝几次就习惯了，但是对你个人来说是你自己的一次宝贵的经验！而且，说不定你多投递的这一家，丫就成功了呢？(,,・ω・,,)人如果没有梦想，那和咸鱼有什么区别？</p><p>最后放一张我当年投递简历做的表，真的是一段艰苦却很有价值的岁月。</p><p><img src="/img/WX20200630-152324%402x.png" alt="投递的一部分截图"></p><p>我暂时就想到这些问题，如果还有其他的问题，也可以在QQ上联系我，如果我知道的都会尽力去帮你解答。</p><h2 id="b-id-0x0D-0x04-个人的一些建议-b"><b id=0x0D>0x04 -- 个人的一些建议</b></h2><p>(*´∀`)~♥其实说实话我不太喜欢给别人建议，因为我觉得每个人的情况都不相同，所以很多选择或是方法并不能对所有人都起到作用，而且我也不是什么很有价值的前辈，只是一个比你们早几年结束了学习生活和你们一样的菜鸡(╥﹏╥)。所以这一块大家也就是听听就好，觉得有用的话就参考一下下就可以。</p><p>首先是大学生活方面，一定不要浪费了大学的这四年生活，因为这是你去学习、去了解一些东西的最好的时间段，同时还有一群人能陪你一起去学习进步。等到工作或是读研之后，时间就变得十分紧迫了，接触和学习的范围也变得狭窄了，仅限于自己工作的内容或是研究的内容了。所以大学四年的时光一定要好好的珍惜。</p><p>其次是学习的一些方法，一定要做好沉淀和积累，可以是以笔记的形式，我个人更推荐已博客这种形式，提倡开源和分享精神。可以是一个小的知识点，也可以是一整块大的知识体系框架。在刚开始的时候可能没有什么感觉。等你坚持了一段时间你会发现，原来已经有了这么多的东西。同时这也是你复习和避免未来忘记的好帮手，我现在有些命令还需要查我以前的博客才能想起来怎么用......</p><p>最后是心态上的一些建议。大三那一年真的是忙碌的一年，上完专业课再去别的班级蹭课，周末再自己一个人做好几站的地铁去遥远的南大，和一群其他学校的陌生人一起听课。赶上投递的简历又总被pass，找不到工作，真的是精神很压抑的一阵。所以多和自己的小伙伴聊聊天，适当的也要学会自己缓解自己身上的压力，如果没法调节好自己的心态你会发现所有的事情都会变得越来越糟。和有可能你刚被上一个面试官嘲笑完，就要马上进行下一轮面试，你不能把刚才的情绪带到一段新的对话当中。抽时间可以去玄武湖走一走，转换一下心情，熬过去这一段最痛苦的时光就是柳暗花明。</p><h2 id="b-id-0x0F-0x05-祝福语-b"><b id=0x0F>0x05  -- 祝福语</b></h2><p>在离开学校的最后，留给学弟学妹们几句祝愿吧。</p><p>愿你们都能够学业有成，拿到自己想要学校或公司的offer。</p><p>愿你们都拥有似锦前程，在喜欢的未来做着自己喜欢的事情。</p><p>愿你们都怀着感恩之心，行程千里不忘恩师(纳姐)滴水之恩。♥(´∀` )人</p><p>愿你们都沐浴到幸运女神的眷属，在未来不要遇到太多的艰苦和歧途。</p><p>愿你们有一天都能与重要的人相逢。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;给学弟学妹的一封信&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2020-6-22&lt;/i&gt;&lt;br&gt;
我毕业了......&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;b-0x00-序-b&quot;&gt;&lt;b&gt;0x00 -- 序&lt;/b&gt;&lt;/h2&gt;
&lt;!-- split --&gt;
&lt;p&gt;首先这篇文章可能会有点长，但是如果是你现在是大二、大三或者准大四的同学，并且正对未来处于一个迷茫的状态，你可以尝试耐住性子去读完剩下的部分。大一的同学有兴趣也可以看一下，没兴趣就关掉赶紧去享受你美好的大一生活（手动狗头）。&lt;/p&gt;
&lt;p&gt;写这篇文章纯粹是因为突然意识到，已经2020年了，拿到了毕业证的我已经毕业了。由于今年的特殊原因，没有毕业典礼，也没有回校拍毕业照和参加最后的见面会，第二天还要继续上班工作，就像什么也没有发生一样，空空的总觉得缺少了一些仪式感。也是刚好想到最近有几个&lt;b&gt;学妹&lt;/b&gt;&lt;del&gt;(和学弟)&lt;/del&gt;会和我咨询关于未来规划和工作的一些事情，所以想还是尽力去留下一些什么，也算是自己给自己做一个完结性质的毕业典礼吧。&lt;/p&gt;
&lt;p&gt;希望能给大二大三以及准大四的学弟学妹们一些有用的帮助吧，虽然我也是咸鱼一条。｡ﾟヽ(ﾟ´Д`)ﾉﾟ｡&lt;/p&gt;</summary>
    
    
    
    <category term="essay" scheme="http://blog.dvkunion.cn/categories/essay/"/>
    
    
    <category term="随笔" scheme="http://blog.dvkunion.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Metasploit渗透测试魔鬼训练营笔记</title>
    <link href="http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.dvkunion.cn/2019/01/30/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5%E6%B8%97%E9%80%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2019-01-30T22:30:00.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>Metasploit渗透测试魔鬼训练营渗透笔记</h1><p><i>2019-1-30</i></p><p><a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">Metasploit渗透测试魔鬼训练营渗透.pdf</a></p><!-- split --><p>日常写点什么<br>寒假开始一周多，想把这本搞了快半年的书彻底的读完。<br>写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。<br>也附带的写一下遇到的坑点和心得吧。<br>调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。</p><span id="more"></span><p><i>2019-2-13</i></p><p>读到中间部分感觉这本书还是有点年代感了，有些工具已经不再支持甚至不能够使用了，然而强迫症又想把所有的都做完...很难受。<br>后面部分可能会过的快一点...</p><hr><h2 id="b-第一章-b"><b>第一章</b></h2><p>在这一章主要是介绍 Metasploit 以及渗透测试的基本流程和名词定义。</p><p><b>第一章小结：</b></p><blockquote><p>1.什么是渗透测试?<br>2.渗透测试标准?<br>3.渗透测试流程?<br>4.渗透测试核心?<br>5.Metasploit是什么?<br>6.Metasploit发展史?<br>7.Metasploit主要6模块?<br>8.Metasploit安装和启动?</p></blockquote><p><b>什么是渗透测试?</b><br><b>渗透测试(Penetration Testing)</b>是一种模拟恶意攻击者的技术方法，对安全系统进行测试攻击，取得访问控制权，并发现安全隐患的一种安全测试与评估方法。这些渗透测试者一般称为渗透工程师。</p><p>渗透测试一般分为两种，即<b>黑盒测试</b>和<b>白盒测试</b><br>黑盒测试：设计一个对客户一无所知的渗透攻击<br>白盒测试：拥有客户组织所有知识情况下的渗透测试<br>灰盒测试：将以上两种测试方法结合的渗透测试</p><p><b>安全业界的开源测试手段：</b></p><table><thead><tr><th>名称</th><th>简写</th><th>简述</th></tr></thead><tbody><tr><td>安全测试方法开源手册</td><td>OSSTMM</td><td>提供物理安全、人类心理学、数据网络、无线通信、电讯通信五类渠道的测试用例</td></tr><tr><td>网络安全测试指南</td><td>NIST SP 800-42</td><td>美国国家标准与研究院(NIST)所讨论</td></tr><tr><td>十大web应用安全项目</td><td>OWASP TOP 10</td><td>针对高风险的web领域</td></tr><tr><td>渗透测试执行标准</td><td>PTES</td><td>广泛应用的一个执行标准：<a href="http://www.pentest-standard.org">PTES</a></td></tr></tbody></table><p><b>渗透测试过程环节：</b></p><table><thead><tr><th>id</th><th>阶段名称</th><th>英文名称</th><th>执行动作</th></tr></thead><tbody><tr><td>1</td><td>前期交互阶段</td><td>Pre-engagement Interactions</td><td>定制渗透测试的范围、目标、限制条件、服务合扩谱图同等</td></tr><tr><td>2</td><td>情报搜集阶段</td><td>Intelligence Gathering</td><td>通过信息搜集获取更大关于目标组织网络拓扑、系统配置等信息</td></tr><tr><td>3</td><td>威胁建模阶段</td><td>Threat Modeling</td><td>通过信息搜集的信息进行讨论分析最可行的攻击手段</td></tr><tr><td>4</td><td>漏洞分析阶段</td><td>Vulnerability Analysis</td><td>寻找漏洞攻击点，进行漏洞的挖掘</td></tr><tr><td>5</td><td>渗透攻击阶段</td><td>Exploitation</td><td>实施渗透攻击获取目标控制权</td></tr><tr><td>6</td><td>后渗透攻击阶段</td><td>Post Exploitation</td><td>总结攻击途径</td></tr><tr><td>7</td><td>报告阶段</td><td>Reporting</td><td>撰写报告，将完整的渗透过程进行总结，并提出补救方案</td></tr></tbody></table><blockquote><p>渗透阶段一般包含7个阶段，由主要核心的5部渗透和开头的服务交互再加上最后的报告。</p></blockquote><p><b>安全漏洞生命周期：</b></p><blockquote><p>A BUG's Life</p></blockquote><p>渗透测试的目的：找出系统中存在的安全漏洞，并实施渗透攻击。<br>安全系统漏洞(Vulnerability)：指信息系统中存在的缺陷或不适当的配置。<br>渗透代码(Exploit)：利用安全漏洞来造成入侵或是破坏效果的程序。<br>安全漏洞的生命周期：<br>1&gt; 安全漏洞研究与挖掘:包括代码审计，逆向工程，Fuzz测试。<br>2&gt; 渗透代码开发与测试:开发验证概念性的代码(POC)，来进行漏洞的验证<br>3&gt; 安全漏洞和渗透代码在封闭团队中流传<br>4&gt; 安全漏洞和渗透代码开始扩散<br>5&gt; 恶意程序出现并传播<br>6&gt; 渗透代码/恶意程序大规模传播并危害互联网<br>7&gt; 渗透攻击代码/攻击工具/恶意程序消亡</p><p>在上述2-5的流程中出现的漏洞一般被称为“0day”<br>恶意程序传播后称作“1day”</p><blockquote><p>要记得什么是0day等...不然根本同不懂大佬门在说什么</p></blockquote><p><b>漏洞披露方式：</b><br>1&gt; 完全公开披露<br>2&gt; 负责人的公开披露<br>3&gt; 进入底下经济产业链<br>4&gt; 小范围利用直至被动披露</p><p><b>漏洞资源库：</b></p><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>cnnvd</td><td><a href="http://www.cnnvd.org.cn">www.cnnvd.org.cn</a></td></tr><tr><td>乌云漏洞库</td><td><a href="http://www.wooyun.org">www.wooyun.org</a></td></tr><tr><td>metasploit</td><td><a href="http://www.metasploit.com/modules">www.metasploit.com/modules</a></td></tr><tr><td>Exploit-db</td><td><a href="http://www.exploit-db.com">www.exploit-db.com</a></td></tr><tr><td>PacketStorm</td><td><a href="http://packetstormsecurity.org">packetstormsecurity.org</a></td></tr><tr><td>SecurityFocus</td><td><a href="http://www.securityfocus.com/bi">www.securityfocus.com/bi</a></td></tr><tr><td>SecurityReason</td><td><a href="http://securityreson.com/exploit_alert/">securityreson.com/exploit_alert/</a></td></tr><tr><td>SecurityVulns</td><td><a href="http://securityvylns.com/exploits/">securityvylns.com/exploits/</a></td></tr><tr><td>1337days</td><td><a href="http://1337day.com">1337day.com</a></td></tr></tbody></table><p><b>Metasploit 历史简介：</b></p><p>初级阶段：HD Moore 在 2003 年成立<br>2003年10月，发布了第一个基于Perl的Metaslpoit版本V1.0，仅有11个渗透攻击模块。<br>2004年4月，发布了MetaslpoitV2.0，此时已经包含18个渗透攻击模块和27个攻击载荷模块。<br>2004年8月，在BlackHat大会上发布了MetaslpoitV2.2，进入了飞速发展的时代。<br>2007年5月，进行了长达18个月的代码移植，发布了MetaslpoitV3.0版本，支持177个渗透模块，104个攻击模块以及30个辅助模块。<br>2009年，MetaslpoitV3.3已经发展到796个模块，41.9万行代码。<br>2009年，Metaslpoit被Rapid7收购，之后推出express以及pro版本。<br>2011年8月,MetaslpoitV4.0发布，引入了后渗透模块。</p><p><b>Metasploit框架：</b><br>Metasploit主要由五部分组成。</p><p>1&gt; 基础文件库:位于源码根目录下libraries目录下，有三个部分：rex、framework-core、framework-base。<br>rex：框架的基础组件，如：网络包装套接字、日志系统、PostgreSQL支持等<br>framework-core：负责与上层的模块插件的交互接口<br>framework-base：扩展framework-core，用于调用自身模块和集成模块</p><blockquote><p>我做测试时候使用的是kali自带的metasploit，并没有发现这三个部分的文件，其主目录位于/usr/share/metasploit-frame下。</p></blockquote><p>2&gt; 模块：由Metasploit框架所搭载实行渗透测试功能的部分。主要有6个部分：辅助模块Aux、攻击模块Exploits、后渗透攻击模块Post、攻击载荷模块Payloads、空指令模块Nops、编码器模块Encoders。</p><blockquote><p>模块部分是Metasploit的核心，这六部分模块不在这里做介绍，在后面每部分的使用的时候进行详细的表述。</p></blockquote><p>3&gt; 插件：Metasploit支持外部插件来扩展功能，如Nessus、OpenVas漏洞扫描器插件。<br>4&gt; 接口：Metasploit提供多种外部用户接口，如控制台：msfconsole、命令行：msfcli、图形化界面：msfgui等。</p><blockquote><p>做本章作业的时候发现，msfcli不能使用。bash不存在这个命令。查了一下结果发现msfcli早就已经废弃了...用msfconsole取代。有点坑...<br><a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">原文链接</a></p></blockquote><p>5&gt; 功能程序：除了上述的四部分，Metasploit还提供一系列可执行程序，可以封装攻击荷载、多种类型的解码等。</p><p><b>第一章作业</b><br>1&gt; <font color = "Brown">通过搜索引擎、安全信息漏洞库搜索Samba服务usermap_script安全漏洞的相关信息。绘出生命周期图，标注重要时间点。</font></p><blockquote><p>度娘一下，这个漏洞应该是一个非常老旧的漏洞了...我jio着。<br>结果，哇，全是大佬们整理好的...orz...<br>揣摩一遍，还是进到CNNVD来自己看一遍吧...不然这个作业抄上了一点意义都没有了...</p></blockquote><blockquote><p>漏洞名称：Samba用户名映射脚本命令执行<br>漏洞编号：CVE-2007-2447(居然是07年的，这么近...啊也不近了，都2019了...)<br>存在版本：Samba 3.0.0 - Samba 3.0.25rc3<br>简单描述：MS-RPC功能允许远程攻击者在启用“用户名映射脚本”smb.conf选项时，通过涉及SamrChangePassword函数的shell元字符执行任意命令，并允许远程认证用户通过shell元字符执行命令<br><a href="/img/k1uVpD.md.png"><img src="/img/k1uVpD.md.png" alt="k1uVpD.md.png"></a></p></blockquote><p>2&gt; <font color = "Brown">更新Metasploit，找出攻击模块具体位置，查看一下针对不同系统的攻击模块数量。</font></p><blockquote><p>我所使用的Metaspoit版本为：metasploit v5.0.1-dev<br>总模块数量：aux：1046；exp:1851；post:321；payloads:541:encoders：44；nops:10<br>渗透攻击模块的位置位于：/usr/share/metasploit-framework/modules/<br>进入到exploits，可以发现几个明显的由操作系统命名的文件夹，Shell统计一下：</p></blockquote><p><code># ls -lR | grep &quot;^d&quot; | wc -l</code></p><blockquote><p>关于windows的攻击模块一共有47个。</p></blockquote><p>3&gt; <font color = "Brown">分别在Win和Linux下安装Metaspoit，运行并获取Linux靶机usermap_script漏洞渗透攻击，尝试植入VNC图形化远程控制工具的攻击荷载，成功获得Linux靶机上的远程控制桌面。</font></p><blockquote><p>我的win下一直都没有装Metasploit...因为...懒癌...<br>就使用kali下的做一下简单的尝试吧。kali-ip:10.10.10.128<br>靶机为Metasploitable2-ip:10.10.10.254<br>虚拟机内的连接为NAT模式。<br>首先进入msfconsole，使用samba_script模块</p></blockquote><blockquote><p><code>msf5 &gt; use multi/samba/usermap_script</code></p></blockquote><blockquote><p>使用show payloads查看攻击载荷，选定bind_netcat</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set payload cmd/unix/bind_netcat</code></p></blockquote><blockquote><p>使用show options 查看需要设置的参数<br>将IP设置为靶机</p></blockquote><blockquote><p><code>msf5 exploit(multi/samba/usermap_script) &gt; set RHOSTS 10.10.10.254</code></p></blockquote><blockquote><p>exploit!</p></blockquote><blockquote><p>可以看到msf反馈已经成功，等待输出bash命令<br><a href="/img/k1KjsJ"><img src="/img/k1KjsJ.md.png" alt="k1KjsJ.md.png"></a></p></blockquote><p>4&gt; <font color = "Brown">使用msfcli命令行接口写一个SHELL脚本，实现用户只需要输入目标Linux靶机IP就可以使用usermap_script漏洞渗透攻击模块获取远程靶机的shell访问。</font></p><blockquote><p>上面说了msfcli已经被弃用，尝试用上文博客的方法写一个脚本<br>shell的写法还不是很熟练...代码只是简单粗暴的实现了所需功能...运行下过如下<br><a href="/img/k1M8yQ"><img src="/img/k1M8yQ.md.png" alt="k1M8yQ.md.png"></a><br>贴上代码<br><a href="/img/k1MGLj.md.png"><img src="/img/k1MGLj.md.png" alt="k1MGLj.md.png"></a></p></blockquote><h2 id="b-第二章-b"><b>第二章</b></h2><p>这一章主要搭建后面实现所需要的的网络拓扑环境</p><p><b>第二章小结：</b></p><blockquote><p>1.虚拟机内NAT和网桥的区别?<br>2.怎么配置IP?</p></blockquote><p>这本书需要的镜像总共为5个，统一安装在vm内。</p><table><thead><tr><th>名称</th><th>类型</th><th>模拟功能</th><th>基础操作系统</th><th>域名</th><th>IP</th></tr></thead><tbody><tr><td>Kali(原书使用BackTrack 5)</td><td>Linux攻击机</td><td>初始攻击点主机</td><td>Ubuntu</td><td><a href="http://attacker.dvssc.com">attacker.dvssc.com</a></td><td>10.10.10.128</td></tr><tr><td>OWASP BWA v0.94</td><td>Web服务靶机</td><td>门户网站服务器</td><td>Ubuntu</td><td><a href="http://www.dvssc.com">www.dvssc.com</a></td><td>10.10.10.129</td></tr><tr><td>Win2K3 Metasploitable</td><td>Windows靶机</td><td>后台服务器</td><td>Win2K3 En</td><td><a href="http://service.dvssc.com">service.dvssc.com</a></td><td>10.10.10.130</td></tr><tr><td>Linux Metasploitable</td><td>Linux 靶机</td><td>网关服务器</td><td>Ubuntu 8.04</td><td><a href="http://gate.dvssc.com">gate.dvssc.com</a></td><td>10.10.10.254(外)/192.168.10.254(内)</td></tr><tr><td>WinXP Metasploitable</td><td>Windows 靶机</td><td>内网客户端主机</td><td>WinXP En</td><td><a href="http://intranet1.dvssc.com">intranet1.dvssc.com</a></td><td>192.168.10.128</td></tr></tbody></table><p>各个镜像的配置和虚拟机的设置书上已经写得非常详细了，设置好VMnet1和VMnet8两张网卡的网段，再修改每一台主机的IP地址、Host模拟:修改靶机Host将域名和IP相对应。最终检测每一台虚拟机的互相连通性即可。</p><p>网关机192.168.10.254要打开路由转发功能net.ipv4.ip_forward,同时防火墙iptables的设置要正确。</p><p><b>第二章作业</b><br>1&gt; <font color = "Brown"> 搭建本章环境，测试连通性</font></p><blockquote><p>这个环境的搭建算是对基础的一个考验，如果网络基础非常好的话修改配置应该会应心得手，很快完成第二章的内容；其次也是对排错能力的一个考验，在实验过程中，由于我的攻击主机使用的kali，在配置网络时候没有注意到CIRD子网掩码二进制的不相同导致网络一直不相同等等问题。<br>总而言之，在这一章主要为后面的实验搭建好良好的环境：工欲善其事，必先利其器。</p></blockquote><p>2&gt; <font color = "Brown"> Vmware虚拟机的构建 </font></p><blockquote><p>这个目前还没有办法做到，等遇到了合适的渗透镜像时候会不断的加进来</p></blockquote><h2 id="b-第三章-b"><b>第三章</b></h2><p>在第三章主要讲了渗透测试的第一个步骤：信息搜集。</p><p><b>第三章小结：</b></p><blockquote><p>1.什么是外围信息收集?<br>2.什么是网络扫描?<br>3.常见的网络扫描有哪些?<br>4.Metasploit有哪些模块适用于信息侦查中?<br>5.Metasploit如何共享信息侦查的数据/成果?</p></blockquote><p>侦查：<br>目标：渗透测试目标的范围，发现渗透目标的安全漏洞与脆弱点，为后续的渗透攻击提供基础。<br>侦查包含：外围信息搜集/公开渠道信息搜集、网络扫描等。</p><h3 id="font-color-LightSkyBlue-3-1-外围信息收集-font-br"><font color = "LightSkyBlue">3.1 外围信息收集</font><br></h3><p><b>通过DNS和IP的侦查挖掘</b></p><p>1&gt; whois域名注册查询<br>msf内置：whois命令<br><a href="http://whois.chinaz.com">站长之家</a><br>2&gt; nslookup/dig 域名查询<br>nslookup:set type=A[MX(Mail Exchange)]<br>ls -d <a href="http://xxxxx.com">xxxxx.com</a><br>dig @&lt;dns服务器&gt; &lt;域名&gt;<br>3&gt; <a href="https://www.maxmind.com">IP2Location地址查询</a><br>4&gt; <a href="http://searchdns.netcraft.com">netcraft信息查询</a><br>http:toolbar.netcraft.com/site_report?url=<a href="http://www.testfire.net">http://www.testfire.net</a><br>5&gt; <a href="http://site.ip138.com/">IP2反查域名</a><br>6&gt; <a href="http://www.7c.com/">站长工具</a></p><blockquote><p>由于这本书出版的年代已经有些久远，所提供的一些工具网址不能够很好地进行运作。能达到同一目的的工具有很多，所以主要是需要了解每一个查询所能获取到哪些有用的信息。<br>whois查询：通过43端口建立tcp连接向服务器进行传送查询请求。这个功能可以查到域名下的DNS服务器、域名备案联系人、联系人邮箱、注册商地址、域名有效时间、注册时间、域名状态等等。同样通过whois反查，可以通过这一个域名所查处的邮箱、联系人、电话等等查到注册该域名的所有者所拥有的其他域名。<br>nslookup&amp;dig：这两个工具在使用的时候没有感觉出多么强大...因为我只看到了对于域名的IP解析...那直接ping一下不就好了么...orz....仔细查了一下，这两个工具更多的适用于dns服务器的查询与测试的...<br>IP2Location：这个就很显而易见了，拿到了域名IP通过IP定位一下服务器所在位置。<br>netcraft：用于子域名查询，在当前的二级域名上可以查询到多少个子域名。<br>IP2Domain：用于查询一台服务器上有多少个虚拟主机，即一个IP上绑定了多少个域名的解析。</p></blockquote><p><b>通过搜索引擎的信息搜集</b></p><p>1&gt; GoogleHacking技术<br>自动化工具：SiteDigger/Search Diggity<br><a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">SiteDigger</a><br><a href="http://www.stachliu.com">Search Diggity</a></p><blockquote><p>这两个自动化的工具原书的网址全凉了...去搜集一下这两个东西。<br>SiteDigger：安装完了...英文...应该是输入域名然后选择数据库？之后就进行搜索...<br>Search Diggity：原网址变更<a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">Search Diggity New</a> 。 帮助手册都是英文...瞬间就不想看了。<br>还是放上GHDB吧:<a href="https://www.exploit-db.com/google-hacking-database">GHDB</a></p></blockquote><p>2&gt; 测试网站目录结构<br>google:parent directory site:<br>搜索inc配置文件/bak备份文件/txt或sql数据文件<br>Metasploit:brute_dirs/dir_listing/dir_scanner暴力</p><p><code>use auxiliary/scanner/http/dir_scanner</code><br><code>set THREAD 50</code><br><code>set RHOST xxxxxxxx.com</code><br><code>exploit</code></p><blockquote><p>对于google黑语法我在百度稍微的试了一下，总感觉度娘还是拦截掉了一些东西。没有Google用起来的感觉舒服。<br>对于Metasploit,简单的测试一下：应改和御剑这类工具是一样的，用字典来不断发送请求并对返回的状态码进行统计。只是不知道这个字典和御剑比起来那个更强一点。</p></blockquote><p>3&gt; 检索特定类型文件<br>google:site:xxxx.com file type:xls</p><p>4&gt; 搜索网站中的email地址:</p><p>Metasploit:search_email_collector模块</p><p><code>use auxiliary/gather/search_email_collector</code><br><code>set DOMAIN xxxxxxxx.com</code><br><code>run</code></p><p>5&gt; 搜索sql注入的页面<br>google:site:xxxx.com inurl:login</p><p><a href="http://www.cz88.net/">纯真数据库</a><br>traceroute</p><h3 id="font-color-LightSkyBlue-3-2-主机探测、端口扫描-font-br"><font color = "LightSkyBlue">3.2 主机探测、端口扫描</font><br></h3><p><b>主机探测：</b></p><p>对网段活跃主机的探测:<br>1.ping</p><p>2.Metasploit 模块<br>modules/auaxiliary/scanner/discovery:arp_sweep、ipv6_multicast、ipv6_neighbor、ipv6_neighbor_route_advertisement、udp_probe、udp_sweep<br>arp_sweep:arp确认网段中活跃主机<br>udp_sweep:udp确认网段中活跃主机并发现服务</p><p>3.Nmap<br>metasploit集成了nmap模块,使用方法不再赘述。</p><p><b>端口扫描：</b></p><p>在Metasploit中：serach postscan可以发现端口扫描工具<br>auxiliary/scanner/portscan/sys、ack、ftpbounce、tcp、xmas</p><p><b>服务扫描：</b></p><p>metasploit：_version/_login<br>e.g. ：http_version查找网络中web服务器。</p><p>也存在着例外：mssql_ping 检测 SQL-server服务(1433)</p><p>常见检测：telnet_version、ssh_version、tnslsnr_version(1521，oracle数据库)、open_proxy(开放代理检测)</p><h3 id="font-color-LightSkyBlue-3-3-口令猜测、嗅探-font-br"><font color = "LightSkyBlue">3.3 口令猜测、嗅探</font><br></h3><p><b>常用嗅探模块：</b></p><p>ssh_login、psnuffle</p><p>ssh_login：auxiliary/scanner/ssh/ssh_login</p><p>psnuffle：auxiliary/sniffer/psnuffle</p><h3 id="font-color-LightSkyBlue-3-4-漏洞扫描-font-br"><font color = "LightSkyBlue">3.4 漏洞扫描</font><br></h3><p>自动化扫描器：nessus、OpenVAS<br>针对性扫描器：nmap<br>这一小结的三个工具放到专门的工具博文下详细记录</p><p><b>OpenVAS</b></p><p>1).配置：<br>1&gt;生成运行所需要的证书文件<br><code># openvas-mkcert -q</code><br><code># openvas-mkcert-client -q</code><br>2&gt; 升级NVT库<br><code># openvas-nvt-sync</code><br>3&gt;初始化<br><code># openvassd</code><br><code># openvasmd --migrate</code><br><code># openvasmd --rebuild</code></p><p><b>Nessus</b></p><p><b>nmap</b></p><p>nmap集成了很多的漏洞扫描脚本，在Kali内的目录为：</p><h3 id="font-color-LightSkyBlue-3-5-信息整理与共享-font-br"><font color = "LightSkyBlue">3.5 信息整理与共享</font><br></h3><p>作为这一章结尾，信息整理与共享的确值得这个重量。良好的习惯和方法能够做到事半功倍的效果。</p><p>Metasploit支持使用数据库的形式导出与导入信息搜集的内容。db_nmap可以直接将nmap的扫描结果存储到数据库中；db_import支持数种格式的扫描结果的导入。</p><p>Metasploit数据库功能需要PostgreSQL的支持，Kali已经内置。</p><p>首先需要启动数据库</p><p><code># service postgresql start</code></p><p>第一次使用数据库时候，需要初始化：</p><p><code># msfdb init</code></p><p>在postgresql中会生成msf和msf_test两表</p><p>进入到msfconsole，输入下列命令查看数据库连接状态：</p><p><code>msf -&gt; db_status</code></p><p>如果初始化数据库这一步正常的话，这里可以直接看到数据库已经连接，连接的是默认的本地msf数据库。</p><p>想要连接其他数据库时，可以使用db_connect进行连接，语法为：</p><p>db_connect 用户名:密码@服务器地址:端口 / 数据库名</p><p><code>msf -&gt; db_connect postgres:password@localhost:7337 / msf</code></p><p>同理可知，db_disconnect 断开连接。</p><p>连接到数据库后，可以使用hosts命令查看数据库是否和已正常使用。</p><p><code>msf -&gt;hosts</code></p><p>一切正常后，我们就可以使用 db_nmap 等封装命令直接将扫描结果储存在数据库中。</p><p>同样也可以将nmap扫描输出的文件使用 db_import 进行查看</p><blockquote><p>笔记：db_import 还可以识别 Acunetix、Amap、Appscan、Burp Session、Microsoft Baseline Security Analyzer 、 Nessus 、 NetSparker、NeXpose 、OpenVAS report、Retina等。<br>基本不认识几个。。。等这个结束以后慢慢补上然后进行测试。</p></blockquote><p>小组共享数据有两种方式，一是通过连接同一个数据库，二是使用MSF RPC数据库。<br>第一种方法需要配置 postgresql 的配置，使其允许远程的数据库连接请求。<br>第二种需要小组其中的一台机器使用 mfsrpcd 命令进行创建，其他小组成员通过GUI进行连接。</p><blockquote><p>此处在未来工作后再进行详细补充</p></blockquote><p><b>第三章作业</b><br>1&gt; <font color = "Brown"> 对一个你感兴趣的个人网站进行DNS、IP与位置的信息查询，找出网络运营者的联系方式，宿主服务器与所在位置等信息。撰写一份简单的调查报告</font></p><p>2&gt; <font color = "Brown"> 利用搜索引擎或相关工具对 <a href="http://testfire.net">testfire.net</a> <a href="http://www.dvssc.com">www.dvssc.com</a> 网站进行更加细致的搜索与侦查，发现更多敏感信息泄露与web安全漏洞 </font></p><p>3&gt; <font color = "Brown"> 端口扫描练习：补全表3-1 </font></p><p>4&gt; <font color = "Brown"> 漏洞扫描练习：补全表3-3 </font></p><p>5&gt; <font color = "Brown"> 数据共享练习：将3、4的扫描结果存储在数据库内 </font></p><h2 id="b-第四章-b"><b>第四章</b></h2><p>从第四章开始，进入到渗透步骤的攻击阶段，</p><p>第四章主要讲解web方面的攻击。<br>个人感觉第四章是看的最云里雾里的一章...一是所讲工具有些已经不能使用，并且工具的使用讲的较为粗略；二是结构上有点不太适应...感觉没有前几章读起来逻辑性更好一些，实战部分只挑了DVWA的四个样例；webshell代码解析倒是很详细，但是看不懂啊orz...</p><p><b>第四章小结：</b></p><blockquote><p>1.web安全引起重视的原因?<br>2.OWASP 是什么组织?其每年发布的top 10 都有哪些?<br>3.提升:web开源工具了解?<br>4.提升:kali内web安全工具了解?<br>5.通过dvwa/owasp top10 ，对各种web漏洞的原理了解，尝试编写自己的攻击模块?</p></blockquote><p><b>DMZ区：</b><br>DMZ（Demilitarized Zone）即俗称的隔离区或非军事区，与军事区和信任区相对应，作用是把WEB，e-mail，等允许外部访问的服务器单独接在该区端口，使整个需要保护的内部网络接在信任区端口后，不允许任何访问，实现内外网分离，达到用户需求。</p><p><b>web攻击迅速发展的7大理由：</b><br>1.广泛性：web应用存在于广大网络中。<br>2.技术门槛低：Lamp、IIS+ASP、.NET等。<br>3.防火墙策略可绕<br>4.安全机制不够成熟：HTTP发展处于滞后阶段。<br>5.隐蔽性：难以取证。<br>6.变化性：由于业务和服务增加或修改，可能会因为调用不当导致出现验证漏洞。<br>7.利益性：web攻击的利益丰厚</p><p><b>OWASP TOP10:</b><br>1.SQL注入：手注、盲注<br>2.跨站脚本：XSS(Cross-Site Scripting) 分为存储型XSS、反射型XSS、DOM型XSS。<br>3.跨站伪造请求：CSRF(Cross-Site Request Forgery) 是XSS的一种衍生。<br>4.会话认证管理缺陷：BASM(Broken Authenitication and Session Managament) Cookie缺陷。<br>5.安全配置错误：常用服务设置错误。<br>6.不安全的密码存储：例如明文密码，算法key未处理或保护不当。<br>7.不安全的参考对象：读取任意文件或资料。<br>8.限制URL失败：如描述，限制失败。<br>9.缺乏传输层保护：网络传输过程中被监听。缺乏SSL/TLS等保护机制。<br>10.未验证的重定向和跳转</p><p><b>web扫描工具：</b></p><p>Metasploit:辅助模块：auxiliary；渗透模块：exploit。<br>第三方：W3AF、SQLmap、wXf、XSSF、BeEF<br>开源扫描器：W3AF、Arachni、Grabber、Wapiti(sql)、Zed Attack Proxy、Skipfish、Sandcat Free Edithin(xss)、Paros、burpsuite、WATOBO(FUZZ)。</p><p><b>W3AF：</b><br>W3AF(Web Application Attack and Audit Framework)是一个综合性的扫描器。其主要分为核心模块和插件模块。<br>核心模块用于进程调度和插件使用；插件分为八类：发现、审计、搜索、攻击、输出、修改、入侵、破解。<br>W3AF也包含两种工作模式：命令行、GUI<br>同样这里不对工具进行过多赘述。详见W3AF工具讲解。</p><blockquote><p>这个工具的安装搞了我一天的时间...为了这玩意还重装了一下虚拟机...这本书对这个工具的使用不是很多，希望在后面学习使用时物有所值吧...</p></blockquote><p><b>SQLmap：</b><br>SQLmap是一款基于Python2的命令行自动注入工具。Kali自带，这里提一下在Metasploit内使用SQLmap</p><blockquote><p>2022-02-23修正：当年读这本书的时候sqlmap还不支持py3。现在早就已经支持了.....</p></blockquote><p><code>msf -&gt; use auxiliary/scanner/http/sqlmap</code><br><code>msf (sqlmap) -&gt; show options</code></p><p><b>其他：</b><br>对于书中所讲解的其他几个工具：如wXf(费了好大的力气找到的资源...)、xssf(这个更坑，据说已经停止更新和维护了，对metasploit兼容性越来越差)...由于略微的有一点年代感，在本章练习dvwa和owasp top10 中会学习近些时间比较新的或者更加实用的工具来进行代替。</p><p><b>第四章作业</b><br>1&gt; <font color = "Brown"><a href="http://xn--www-855fm2v.testfire.net">查找www.testfire.net</a> 中存在的sql注入,应用sqlmap等工具或是手动注入</font></p><p>2&gt; <font color = "Brown">添加xssf模块，完成一次存储型跨站&quot;钓鱼&quot;</font></p><p>3&gt; <font color = "Brown">通过wXf扫描wordpress和joomla两个模块进行RFI攻击</font></p><p>4&gt; <font color = "Brown">从exploit-db上找一个wordpress漏洞搭建一个漏洞环境，通过metasploit进行攻击</font></p><p>5&gt; <font color = "Brown">在DVWA中实践并理解安全配置及漏洞原理</font></p><p>6&gt; <font color = "Brown">尝试使用sqlmap进行shell注入</font></p><p>7&gt; <font color = "Brown">尝试向metasploit中加入网上的web渗透模块并搭建测试环境进行测试</font></p><h2 id="b-第五章-b"><b>第五章</b></h2><p>第五章讲述网络服务的渗透攻击，重点在于对所给实例的漏洞的分析过程的学习，这里和第六章先放一下，涉及了很多的汇编和二进制问题。<br>其主要介绍漏洞有：MS08-067、CVE-2009-1979、OSVDB-59110、</p><p>开始依旧是扫盲。</p><p><b>内存攻击：</b><br>攻击者利用软件安全漏洞构造恶意输入导致软件处理数据产生非预期错误，将数据写入特定的敏感位置从而劫持软件控制流量，执行外部代码。</p><p><b>缓冲区溢出漏洞：</b><br>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。<br>根据溢出内存位置不同，缓冲区溢出分为栈溢出和堆溢出。</p><p><b>栈溢出：</b><br>栈溢出指当写入数据超过内存分配给栈的缓冲区空间。会导致覆盖缓冲区附近的变量从而改变程序流程和结果；或是覆盖保存的函数地址修改为指定的地址；还有可能覆盖掉某个指针或者程序异常处理结构。<br>覆盖返回地址的利用方式是在函数进行调用时覆盖掉函数返回指针所指向的地址，从而达到调用shellcode的目的；<br>覆盖异常处理的利用方式</p><h2 id="b-第六章-b"><b>第六章</b></h2><p>第六章讲述的是客户端的渗透攻击。包含了常用的客户端软件如：浏览器、office、Adobe等。<br>主要的漏洞有：MS11-050、MS10-087。</p><p>同第五章，这一部分在开始学习逆向之后补齐。</p><h2 id="b-第七章-b"><b>第七章</b></h2><p>第七章讲社工，这一部分还是蛮有意思的。<br>说到社工，就不得不提凯文.米特尼克...和《欺骗的艺术》(虽然到现在我还没有看过，近期补上)。还有一本人性的弱点。</p><p>讲道理社工是一门博大精深的学问，个人觉得可以通过一些逻辑小游戏或者海龟汤故事之类的锻炼叙述一个故事或情景模拟。</p><p>从原理上来说，社会工程学（Social Engineering），是一种通过人际交流的方式获得信息的非技术渗透手段。他利用对象的心理弱点、人类的本能反应和好奇心等心理特征，进行欺骗、冒充、引诱等多种手段达成目的。</p><p>社工最重要的还是在进行之前的信息搜集。你能取得越多的信息，对于你获取信任的可能性就越大。</p><p>书中描述了一个社会工程学的环节框架：</p><p>1.信息搜集<br>2.诱导<br>3.托词<br>4.心理影响</p><p>在PC端对社工能够起到帮助的有：网络电话、木马、钓鱼网站的伪造、U盘攻击等等。</p><p><b>网络电话</b></p><p><b>木马</b><br>msfpayload</p><p><b>钓鱼</b><br>set工具</p><p><b>U盘攻击</b><br>autorun.inf<br>UItraISO<br>Hacksaw<br>Switchblade</p><h4 id="参考链接">参考链接</h4><blockquote><p>0.Metasploit渗透测试魔鬼训练营渗透.pdf : <a href="https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf">https://github.com/Urinx/Books/raw/master/metasploit/Metasploit渗透测试魔鬼训练营.pdf</a><br>1.PTES : <a href="http://www.pentest-standard.org">http://www.pentest-standard.org</a><br>2.原文链接 : <a href="https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/">https://blog.rapid7.com/2015/07/10/msfcli-is-no-longer-available-in-metasploit/</a><br>3.站长之家 : <a href="http://whois.chinaz.com">http://whois.chinaz.com</a><br>4.IP2Location地址查询 : <a href="https://www.maxmind.com">https://www.maxmind.com</a><br>5.netcraft信息查询 : <a href="http://searchdns.netcraft.com">http://searchdns.netcraft.com</a><br>6.IP2反查域名 : <a href="http://site.ip138.com/">http://site.ip138.com/</a><br>7.站长工具 : <a href="http://www.7c.com/">http://www.7c.com/</a><br>8.SiteDigger : <a href="http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx">http://www.mcafee.com/us/downloads/free-tools/sitedigger.aspx</a><br>9.Search Diggity : <a href="http://www.stachliu.com">http://www.stachliu.com</a><br>10.Search Diggity New : <a href="http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/">http://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a><br>11.GHDB : <a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a><br>12.纯真数据库 : <a href="http://www.cz88.net/">http://www.cz88.net/</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1&gt;Metasploit渗透测试魔鬼训练营渗透笔记&lt;/h1&gt;
&lt;p&gt;&lt;i&gt;2019-1-30&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Urinx/Books/raw/master/metasploit/Metasploit%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%AD%94%E9%AC%BC%E8%AE%AD%E7%BB%83%E8%90%A5.pdf&quot;&gt;Metasploit渗透测试魔鬼训练营渗透.pdf&lt;/a&gt;&lt;/p&gt;
&lt;!-- split --&gt;
&lt;p&gt;日常写点什么&lt;br&gt;
寒假开始一周多，想把这本搞了快半年的书彻底的读完。&lt;br&gt;
写一个小总结似的笔记，把书里的课后习题和镜像练习实验都一遍。&lt;br&gt;
也附带的写一下遇到的坑点和心得吧。&lt;br&gt;
调整了一下结构，把每一章的小结都放到了开始部分，希望以后复习时候可以一口气回答出这些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Reading" scheme="http://blog.dvkunion.cn/categories/Reading/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="笔记" scheme="http://blog.dvkunion.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="渗透测试" scheme="http://blog.dvkunion.cn/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://blog.dvkunion.cn/2019/01/17/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2019-01-17T21:28:48.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP状态码</h1><!-- split --><p>简单记录一下常用的http状态码表示的含义</p><span id="more"></span><h3 id="b-0x00-概念-b"><b>0x00- - 概念</b></h3><p>HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。这是表示使用HTTP协议（HyperText Transfer Protocol，超文本传输协议）客服端的请求做出反应的三位数字码。<br>HTTP状态根据开头的第一个数字分为5类。后面两个数字没有分类的作用。</p><h3 id="b-0x01-1xx-信息类状态码-b"><b>0x01- - 1xx 信息类状态码</b></h3><p>这类状态码表示服务器已经收到了请求，需要请求者继续执行操作。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switch Protrol</td><td>切换协议，根据客户端的请求切换协议，只能由下至上的切换</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行</td></tr></tbody></table><h3 id="b-0x02-2xx-成功类状态码-b"><b>0x02- - 2xx 成功类状态码</b></h3><p>这类状态码表示服务器已经接受了请求并成功地处理了请求</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成,如果201所处理的请求无法及时建立，则返回该状态码</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求,类似迅雷等下载工具的下载大文件方式</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr></tbody></table><p>206请求头部必须包含Range头信息，并有可能含有IF-Range作为条件请求。<br>响应必须包含如下的头部域：<br>　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>　　Date<br>　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。<br>　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</p><h3 id="b-0x03-3xx-重定向类状态码-b"><b>0x03- - 3xx 重定向类状态码</b></h3><p>这类状态码表示服务器需要进一步操作来完成请求。<br>用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>请非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table><h3 id="b-0x04-4xx-外部错误类状态码-b"><b>0x04- - 4xx 外部错误类状态码</b></h3><p>这类状态码通常指客户端发送的发生了错误，妨碍了服务器的处理、请求包含语法错误或无法完成请求。</p><h3 id="b-0x05-5xx-内部错误类状态码-b"><b>0x05- - 5xx 内部错误类状态码</b></h3><p>这类状态码通常指服务器在处理请求的过程出现了错误或者有异常发生。也可能是服务器意识到无法处理这个请求。<br>5xx的状态码适用于任何响应方法。</p><table><thead><tr><th>代码号</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求，一般是服务器代码出现问题</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><h3 id="b-0x06-其他状态码-b"><b>0x06- - 其他状态码</b></h3><p>208 已经报告<br>一个DAV的绑定成员被前一个请求枚举，并且没有被再一次包括。</p><p>226 IM Used<br>服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。</p><p>308 永久转移<br>这个请求和以后的请求都应该被另一个URI地址重新发送。307、308和302、301有相同的表现，但是不允许HTTP方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。</p><p>418 我是一个茶壶<br>这个代码是在1998年作为传统的IETF April Fools‘ jokes被定义的在RFC2324，超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现。RFC指定了这个代码应该是由茶罐返回给速溶咖啡。</p><p>419 认证超时<br>并不是HTTP标注的一部分，419认证超时表示以前的有效证明已经失效了。同时也被用于401未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。</p><p>420 方法失效<br>不是HTTP的标准，但是被Spring定义在HTTP状态类中当方法失时使用。这个状态码已经不推荐在Spring中使用。</p><p>420 提高你的耐心<br>也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。</p><p>428 需要前置条件<br>原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。</p><p>429 过多请求<br>用户已经发送了太多的请求在指定的时间里。用于限制速率。</p><p>431 请求头部字段太大<br>服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。</p><p>440 登陆超时（微软）<br>一个微软的扩展，意味着你的会话已经超时。</p><p>444 无响应<br>被使用在Nginx的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。</p><p>449 重试（微软）<br>一个微软的扩展。请求应该在执行适当的动作之后被重试。</p><p>450 被Windows家长控制阻塞（微软）<br>一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。</p><p>451 由于法律原因而无效（因特网草稿）<br>被定义在因特网草稿“一个新的HTTP状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是1953年dystopian的小说Fahrenheit 451就是一个非法的资源。</p><p>451 重定向（微软）<br>被用在Exchange ActiveSync中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。</p><p>客户端会假定重新执行HTTP自动发现协议去寻找更适合的服务器。</p><p>494 请求头太大（Nginx）<br>Nginx内置代码和431类似，但是是被更早地引入在版本0.9.4（在2011年1月21日）。</p><p>495 证书错误（Nginx）</p><p>Nginx内置的代码，当使用SSL客户端证书的时候错误会出现为了在日志错误中区分它和4XX和一个错误页面的重定向。。</p><p>496 没有证书（Nginx）<br>Nginx内置的代码，当客户端不能提供证书在日志中分辨4XX和一个错误页面的重定向。</p><p>497 HTTP到HTTPS（Nginx）<br>Nginx内置的代码，被用于原始的HTTP的请求发送给HTTPS端口去分辨4XX在日志中和一个错误页面的重定向。</p><p>498 令牌超时或失效（Esri）<br>由ArcGIS for Server返回。这个代码意味着令牌的超时或者是失效。</p><p>499 客户端关闭请求（Nginx）<br>被用在Nginx日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。</p><p>499 需要令牌（Esri）<br>由ArcGIS for Server返回。意味着需要一个令牌（如果没有令牌被提交）。</p><p>508 发现环路<br>服务器发现了一个无限的循环档处理请求的时候。</p><p>511 需要网络授权<br>客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。</p><p>520 未知错误<br>这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。</p><p>598 网络读取超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络读取超时在一个客户端之前的代理的后面。</p><p>599 网络连接超时异常(未知)<br>这个状态码也没有在任何RFC中指定，但是被用在微软的HTTP代理中去标注一个网络连接超时在一个客户端之前的代理的后面。</p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;HTTP状态码&lt;/h1&gt;
&lt;!-- split --&gt;
&lt;p&gt;简单记录一下常用的http状态码表示的含义&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="http://blog.dvkunion.cn/categories/Crypto/"/>
    
    
    <category term="WEB" scheme="http://blog.dvkunion.cn/tags/WEB/"/>
    
    <category term="常用编码" scheme="http://blog.dvkunion.cn/tags/%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>python3--learning--③</title>
    <link href="http://blog.dvkunion.cn/2018/10/20/python3-learning%E2%91%A2/"/>
    <id>http://blog.dvkunion.cn/2018/10/20/python3-learning%E2%91%A2/</id>
    <published>2018-10-20T08:48:03.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①<br><a href="/2018/10/19/python3-learning②/">②<br><a href="/2018/10/20/python3-learning③/">③</p><ol><li><a href="#0x07">0x07--输入输出&amp;文件操作</a><ol><li><a href="#0x07-1">输入输出</a></li><li><a href="#0x07-2">文件操作</a></li></ol></li><li><a href="#0x08">0x08--CSV数据</a></li><li><a href="#0x09">0x09--系统监测</a><ol><li><a href="#0x04-1">工具使用</a></li></ol> <!--vmstat,iostat,top,sar,dstat,ifstat--><ol start="2"><li><a href="#0x04-2">类--class</a></li></ol></li><li><a href="#0x0A">0x0A--系统监测</a><ol><li><a href="#0x05-1"></a></li><li><a href="#0x05-2"></a></li></ol></li><li><a href="#0x0B">0X0B--插件和依赖支持安装</a></li></ol><hr><div id="0x07"></div><h3 id="b-0x07-输入输出-文件操作-b"><b>0x07- - 输入输出&amp;文件操作<b></h3><div id="0x07-1"></div><h4 id="font-color-blue-输入输出-font-br"><font color = "blue">输入输出</font><br></h4><p>输入：input()<br>输出：print()<br>输出字符串：str()/repr()<br>Python的输出自带换行，当我们想要进行不换行的输出时，应使用 end 参数。</p><p><code>print(&quot;不换行输出&quot;,end=&quot;&quot;)</code></p><p>当我们想要控制输出格式时候，可以使用占位符或format参数。<br>占位符要紧跟在其后：</p><p><code>print(&quot;int %d &quot; % 1+&quot;float %.3f &quot;% 2.3)</code></p><p>而format函数则需要位置映射/关键字映射/元素映射。<br>位置映射就是指默认的一一对应，一个萝卜一个坑：</p><p><code>print(&quot;&#123;&#125;,&#123;&#125;&quot;.format('第一个萝卜','第二个萝卜'))</code></p><p>关键字映射就是指key，类似占位一样,没人占的位置就遵循位置映射规则：</p><p><code>print(&quot;&#123;Lisi&#125;,&#123;Zhangsan&#125;,&#123;&#125;&quot;.format('noname',Lisi=&quot;Lisi's&quot;,Zhangsan=&quot;Zhangsan's&quot;))</code></p><p>关键字映射无视format函数内的参数位置。<br>最后的元素映射就是将format当作一个元组用下表访问：</p><p><code>print(&quot;&#123;0[0]&#125;,&#123;0[1]&#125;&quot;.format(('first','second')))</code></p><p>format还可以进行居中(^),左对齐(&lt;),右对齐(&gt;)操作<br>格式为：</p><p><code>&#123;索引:(填充符)(对齐符)(字符宽度)&#125;</code></p><p>例如</p><p><code>print(&quot;&#123;0&#125;,&#123;1&#125;=&#123;2:*&gt;3&quot;.format(3,2,2*3))</code></p><p>对于输入，有一个一行输入多个数据的方法：</p><p><code>a, b, c = map(int, input().split())</code></p><div id="0x07-2"></div><h4 id="font-color-blue-文件操作-font-br"><font color = "blue">文件操作</font><br></h4><p>open可以返回一个file对象</p><p><code>f = open(&quot;/tmp/test.txt,&quot;w&quot;)</code></p><p>第一个参数为路径&amp;文件名，第二个参数为mode模式，分为'r'只读、'w'只写、'a'读写。</p><p>对于file对象，存在以下的方法:</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>f.read()</td><td>读取文件内容，返回str</td></tr><tr><td>f.readline()</td><td>读取文件的单独一行，遇到'\n'结束，返回str</td></tr><tr><td>f.readlines()</td><td>返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</td></tr><tr><td>f.write(str)</td><td>将一个str写入到文件内，然后返回写入字符数</td></tr><tr><td>f.tell()</td><td>返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</td></tr><tr><td>f.seek()</td><td>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符，seek(x,1) ： 表示从当前位置往后移动x个字符，seek(-x,2)：表示从文件的结尾往前移动x个字符</td></tr></tbody></table><div id="0x08"></div><h3 id="b-0x08-CSV数据-b"><b>0x08- - CSV数据<b></h3><p>     逗号分隔值(Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号)。其文件以纯文本形式存储表格数据（数字和文本）。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。<br>存在以下特征的即可称为CSV格式：</p><ol><li>1.纯文本，使用某个字符集，比如ASCII、Unicode、EBCDIC或GB2312；</li><li>2.由记录组成（典型的是每行一条记录）；</li><li>3.每条记录被分隔符分隔为字段（典型分隔符有逗号、分号或制表符；有时分隔符可以包括可选的空格）；</li><li>4.每条记录都有同样的字段序列。</li></ol><p>Python中有内置的CSV库，可以方便的帮助处理CSV数据。</p><p><a href="#head"><center><font color = "Crimson">back --返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3-learning--②</title>
    <link href="http://blog.dvkunion.cn/2018/10/19/python3-learning%E2%91%A1/"/>
    <id>http://blog.dvkunion.cn/2018/10/19/python3-learning%E2%91%A1/</id>
    <published>2018-10-19T16:07:18.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①<br><a href="/2018/10/19/python3-learning②/">②</p><ol><li><a href="#0x03">0x03--控制结构</a><ol><li><a href="#0x03-1">if</a></li><li><a href="#0x03-2">for</a></li><li><a href="#0x03-3">while</a></li><li><a href="#0x03-4">it(迭代器)</a></li></ol></li><li><a href="#0x04">0x04--函数&amp;类</a><ol><li><a href="#0x04-1">函数--def</a></li><li><a href="#0x04-2">类--class</a></li></ol></li><li><a href="#0x05">0x05--错误&amp;异常</a><ol><li><a href="#0x05-1">错误</a></li><li><a href="#0x05-2">异常</a></li></ol></li><li><a href="#0x06">0X06--Python模块的安装(以Matplotlib为例)</a></li></ol><p><a href="/2018/10/20/python3-learning③/">③</p><hr><div id="0x03"></div><h3 id="b-0x03-控制结构-b"><b>0x03- - 控制结构<b></h3><div id="0x03-1"></div><h4 id="font-color-blue-if-font-br"><font color = "blue">if</font><br></h4><p>Python 中同样使用 if 来控制条件顺序结构。<br><br><b>--格式<b></p><p>Python 中一般if的写法如下:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> judge1 :</span><br><span class="line">execution <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> judge2 :</span><br><span class="line">execution <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span> judge3 :</span><br><span class="line">execution <span class="number">3</span></span><br></pre></td></tr></table></figure><br><p><b>--常用运算符<b></p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">等于</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不等于</td></tr><tr><td style="text-align:left">x and y</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">x or y</td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left">not x</td><td style="text-align:left">逻辑非</td></tr></tbody></table><p><b>--注意<b></p><blockquote><p>P.S.<br>Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else<br>每个条件后面要使用冒号 :<br>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块<br>在Python中没有switch – case语句</p></blockquote><div id="0x03-2"></div><h4 id="font-color-blue-for-font-br"><font color = "blue">for</font><br></h4><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。<br><b>--格式<b></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> sequence :</span><br><span class="line">execution</span><br></pre></td></tr></table></figure><p>其中 var 是变量 ，sequence 是序列，如列表、字符串<br>一般情况下使用 range 函数来生成一个数列方便使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为1 2 3 4 </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为0 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>,<span class="number">3</span>) <span class="comment">#3代表步长</span></span><br><span class="line"><span class="built_in">print</span>(i) <span class="comment">#打印结果为0 3 6 9</span></span><br></pre></td></tr></table></figure><p>有了range()这个函数，我们可以配合len()轻松的遍历一个序列，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">print</span>(i,a[i])</span><br><span class="line"><span class="comment">#打印结果为：</span></span><br><span class="line"><span class="comment">#0 a</span></span><br><span class="line"><span class="comment">#1 b</span></span><br><span class="line"><span class="comment">#2 c</span></span><br><span class="line"><span class="comment">#3 d</span></span><br></pre></td></tr></table></figure><p><b>--注意<b></p><blockquote><p>P.S.<br>循环结构中可以用 pass / continue 来跳过不需要的剩余语句<br>循环结构中可以用 break 来提前结束循环</p></blockquote><div id="0x03-3"></div><h4 id="font-color-blue-while-font-br"><font color = "blue">while</font><br></h4><p><b>--格式<b><br>Python中while语句的一般如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>/<span class="literal">False</span> :</span><br><span class="line">execution </span><br></pre></td></tr></table></figure><p><b>--注意<b></p><blockquote><p>P.S.<br>Python中没有do...while循环<br>while 之后仍可以接else 语句</p></blockquote><div id="0x03-4"></div><h4 id="font-color-blue-it-font-br"><font color = "blue">it</font><br></h4><p>it -- 迭代器<br>迭代器是访问集合元素的一种方式<br>迭代器是一个可以记住遍历的位置的对象。</p><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><p>迭代器有两个基本的方法：iter() 和 next()。<br>--格式</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>) <span class="comment">#创建迭代器对象</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">next</span>()) <span class="comment">#输出迭代器下一个元素</span></span><br></pre></td></tr></table></figure><p>可以使用it来进行遍历</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment">#使用for来进行遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span>(i) </span><br><span class="line"><span class="comment">#或是用while来进行遍历</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration :</span><br><span class="line">sys.exit() <span class="comment">#结束程序</span></span><br></pre></td></tr></table></figure><!--此处还有生成迭代器和初始化迭代器--><!--记得补上--><div id="0x04"></div><h3 id="b-0x04-函数-类-b"><b>0x04- - 函数&amp;类<b></h3><div id="0x04-1"></div><h4 id="font-color-blue-函数-font-br"><font color = "blue">函数</font><br></h4><h6 id="b-1-格式-b-br"><b>1.格式<b><br></h6><p>函数是一段组织好的，可重复使用的，来实现单一或相关联功能的代码段。<br>函数能够提高代码的模块性。<br>我们可以将一些方法封装成用户自定义函数，方便在之后进行多次调用。<br>在Python中该函数的格式为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">val1 , val2</span>):</span><br><span class="line">your code</span><br><span class="line"><span class="keyword">return</span> val3</span><br></pre></td></tr></table></figure><p>其中 def 是函数声明，告诉 python 要定义一个函数<br>name 是函数标识符名称，命名规则同Python标识符的命名<br>val1,val2被称作函数的参数<br>缩进后的内容为函数体<br>return 选择性的返回一个值给调用方法，没有return 相当于返回None</p><p>例如，将a+b写成函数操作的形式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">a,b</span>):</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">d = <span class="number">3</span></span><br><span class="line">plus(c,d)</span><br></pre></td></tr></table></figure><p>输出结果为4</p><h6 id="b-2-参数-b-br"><b>2.参数<b><br></h6><p>形参：函数定义时预设的参数<br>实参：实际使用时传递给函数的参数</p><p>在Python中，形参有4中表现形式:</p><ol><li>必须参数：如上例的a,b。即在引用时必须传入的参数。</li><li>关键词参数：在引用plus函数时还可以这样赋值:<br><code>plus(a=4,b=6)</code><br>或者<br><code>plus(b=6,a=4)</code><br>关键词参数使用时不需要指定顺序</li><li>默认参数：修改plus函数的形参格式如：<br><code>def plus(a,b=6)</code><br>这样plus函数中b参数已经有了默认值6<br>如果没有传入b的值时，b参数将使用默认值6</li><li>不定长参数：当不确定参数的长度时可以使用不定长参数。修改函数：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params"> *val </span>):</span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> val:</span><br><span class="line"><span class="built_in">sum</span>+=i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line">plus(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>输出结果为15<br>加了*的参数会以元组的形式导入函数，存放所有未命名的变量参数。<br>加了**的参数以字典的形式导入。<br>单独出现*后的参数必须用关键词参数的方式传入。</p><h6 id="b-3-参数传递-b-br"><b>3.参数传递<b><br></h6><p>在Python中，类型属于对象，变量没有类型。<br>上面的plus函数中，1,3属于Num类,而变量c，d则没有类型，他仅是一个Num对象的引用（类似于指针）。<br>在之前的总结中，Python有种可变类型，3种不可变类型。当函数传递的参数类型为不可变类型时，传递方式累死c++的值传递。传递的只是变量的值，不影响变量本身。<br>举个例子说明值传递：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pass_coin</span>(<span class="params">a</span>):</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数内的a的值为&quot;</span>+<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">pass_coin(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外部实际的a的值为&quot;</span>+<span class="built_in">str</span>(a))</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内的a的值为10</span><br><span class="line">外部实际的a的值为5</span><br></pre></td></tr></table></figure><p>当函数传递的参数时可变类型时，则类似c++的引用传递（指针），如果参数被修改，那么外部实际值也会发生变化。<br>同样例如:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pass_coin</span>(<span class="params">a</span>):</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数内列表a的值为&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">pass_coin(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外部实际列表a的值为&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数内列表a的值为[1, 10, 3, 4, 5]</span><br><span class="line">外部实际列表a的值为[1, 10, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>在这个例子中我们定义了一个可变的数据类型：列表a，在调用函数时把列表下标为 1 的值改变为10，发现不仅仅是函数内部a的值发生了变化,实际的列表a 的值已经被改变。</p><div id="0x04-2"></div><h4 id="font-color-blue-类-font-br"><font color = "blue">类</font><br></h4><p>类的操作和java中基本相似。python同样支持继承，多继承，方法重写，私有属性、方法，以及运算符重载</p><div id="0x05"></div><h3 id="b-0x05-错误-异常-b"><b>0x05- - 错误&amp;异常<b></h3><div id="0x05-1"></div><h4 id="font-color-blue-错误-font-br"><font color = "blue">错误</font><br></h4><p>错误一般指python代码中的语法错误</p><div id="0x05-2"></div><h4 id="font-color-blue-异常-font-br"><font color = "blue">异常</font><br></h4><h6 id="b-1-异常信息-b-br"><b>1.异常信息<b><br></h6><p>即使语法正确，程序在运行的过程中也可能发生错误。运行期间的错误被称作异常。<br>异常的种类有很多，如常见的：ZeroDivisionError,NameError,TypeError等等。</p><h6 id="b-2-异常处理-b-br"><b>2.异常处理<b><br></h6><p>异常处理的代码格式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br></pre></td></tr></table></figure><p>except函数也可以同时处理多个异常，如：<br><code>except(RuntimeError,ZeroDivisionError):</code><br>try-except 还有一个可选的 else语句</p><h6 id="b-3-常见的Python异常类型-b-br"><b>3.常见的Python异常类型<b><br></h6><table><thead><tr><th style="text-align:left">异常名称</th><th style="text-align:left">异常描述</th></tr></thead><tbody><tr><td style="text-align:left">BaseException</td><td style="text-align:left">所有异常的基类</td></tr><tr><td style="text-align:left">SystemExit</td><td style="text-align:left">解释器请求退出</td></tr><tr><td style="text-align:left">KeyboardInterrupt</td><td style="text-align:left">用户中断执行(通常是输入^C)</td></tr><tr><td style="text-align:left">Exception</td><td style="text-align:left">常规错误的基类</td></tr><tr><td style="text-align:left">StopIteration</td><td style="text-align:left">迭代器没有更多的值</td></tr><tr><td style="text-align:left">GeneratorExit</td><td style="text-align:left">生成器(generator)发生异常来通知退出</td></tr><tr><td style="text-align:left">StandardError</td><td style="text-align:left">所有的内建标准异常的基类</td></tr><tr><td style="text-align:left">ArithmeticError</td><td style="text-align:left">所有数值计算错误的基类</td></tr><tr><td style="text-align:left">FloatingPointError</td><td style="text-align:left">浮点计算错误</td></tr><tr><td style="text-align:left">OverflowError</td><td style="text-align:left">数值运算超出最大限制</td></tr><tr><td style="text-align:left">ZeroDivisionError</td><td style="text-align:left">除(或取模)零 (所有数据类型)</td></tr><tr><td style="text-align:left">AssertionError</td><td style="text-align:left">断言语句失败</td></tr><tr><td style="text-align:left">AttributeError</td><td style="text-align:left">对象没有这个属性</td></tr><tr><td style="text-align:left">EOFError</td><td style="text-align:left">没有内建输入,到达EOF 标记</td></tr><tr><td style="text-align:left">EnvironmentError</td><td style="text-align:left">操作系统错误的基类</td></tr></tbody></table><div id="0x06"></div><h3 id="b-0x06-Python模块的安装-以Matplotlib为例-b"><b>0x06- - Python模块的安装(以Matplotlib为例)<b></h3><p>之前的安装缺少了部分环境导致Python最后的安装过程出现一个错误警告。导致Python3自带的Pip3未安装成功。我们重新安装一下依赖环境扩展包</p><h6 id="b-1-Python3-7-0依赖包-b-br"><b>1.Python3.7.0依赖包<b><br></h6><p><code>$ yum install -y gcc openssl* libffi libffi-devel zlib zlib-devel zlib-static readline-devel</code></p><h6 id="b-2-Matplotlib图形呈现依赖包-b-br"><b>2.Matplotlib图形呈现依赖包<b><br></h6><p><code>$ yum install -y tcl tk tk-devel</code></p><h6 id="b-3-重新安装Python3-b-br"><b>3.重新安装Python3<b><br></h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ tar -xzvf Python-<span class="number">3.7</span><span class="number">.0</span>.tgz </span><br><span class="line">$ cd Python-<span class="number">3.7</span><span class="number">.0</span>/</span><br><span class="line">$ ./configure --<span class="keyword">with</span>-ssl --<span class="keyword">with</span>-tcltk-includes=<span class="string">&quot;-I/usr/include&quot;</span> --<span class="keyword">with</span>-tcltk-libs=<span class="string">&quot;-L/usr/lib64 -ltcl8.5 -L/usr/lib64 -ltk8.5&quot;</span></span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure><p>make install 结束后，会发现不会出现第一次安装时结尾的报错而是提示success<br>可以在命令行输入<br><code>$ python3</code><br>和<br><code>$ pip3</code><br>检测是否安装成功。</p><h6 id="b-4-Pip3安装matplotlib-b-br"><b>4.Pip3安装matplotlib<b><br></h6><p><code>$ pip3 install --index-url https://pypi.douban.com/simple matplotlib</code></p><h6 id="b-5-Matplotlib基本操作-b-br"><b>5.Matplotlib基本操作<b><br></h6><p>首先调用Matplotlib<br><code>import Matplotlib.pyplot as plt</code><br>调用了pyplot模块，并将它简化为plt，这样我们在后面的使用中就可以用plt来代替较长的pyplot。<br>来画一个简单的图像:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares)   <span class="comment">#plot()绘图函数</span></span><br><span class="line">plt.show()   <span class="comment">#show()打开matplotlib查看器并显示所绘图形</span></span><br></pre></td></tr></table></figure><p>运行输出如下：<br><img src="/img/006IjVYfgy1fxp1uzaoh9j30hs0dcdg0.jpg" alt=""></p><p>我们对输出的图片加一些修饰：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares,linewidth=<span class="number">5</span>) <span class="comment">#linewidth参数调整画线粗细</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Number&quot;</span>,fontsize=<span class="number">24</span>) <span class="comment">#title方法为图片命名</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>,fontsize=<span class="number">14</span>) <span class="comment">#xlabel方法为X轴坐标命名</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>,fontsize=<span class="number">14</span>) <span class="comment">#ylabel方法为Y轴坐标命名</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>) <span class="comment">#配置参数刻度线样式。</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出变为以下形式:<br><img src="/img/006IjVYfgy1fxp1wdy1ukj30hs0dct96.jpg" alt=""><br>plot方式画出的图默认是将各个点的值连接到一起，如果想要单独画出各个点，可以使用scatter的打印方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">10</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>,labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果如下:<br><img src="/img/006IjVYfgy1fxp1hskwz3j30hs0dct8y.jpg" alt=""><br>把采样点加多，即可画出y=x*x的函数图像:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">51</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">40</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>,<span class="number">3600</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出如下:<br><img src="/img/006IjVYfgy1fxp1liowyxj30hs0dcweo.jpg" alt=""></p><p>也可以改变他的颜色：</p><blockquote><p>颜色表可以参考着单一色<br>red,blue,yellow,green,pink,black,brown,purple,orange<br><a href="https://matplotlib.org/tutorials/colors/colormaps.html">https://matplotlib.org/tutorials/colors/colormaps.html</a></p></blockquote><p>或是渐变色：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">51</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values,y_values,c=y_values,</span><br><span class="line">cmap=plt.cm.Blues,s=<span class="number">40</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Values&quot;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">60</span>,<span class="number">0</span>,<span class="number">3600</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="/img/006IjVYfgy1fxp1tah2slj30hs0dcgly.jpg" alt=""><br>这里放出常用的颜色表:<br><img src="/img/006IjVYfgy1fxp1the74jj30hu0dadjv.jpg" alt=""><br><img src="/img/006IjVYfgy1fxp1tplnlfj30hs0ddju2.jpg" alt=""><br>图片编辑完毕，记得保存一下:<br><code>plt.savefig('test.png',bbox_inches='tight') #自动保存图表，并将图表周边的空白区域裁减掉 </code></p><p><a href="#head"><center><font color = "Crimson">back -- 返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3--learning--①</title>
    <link href="http://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/"/>
    <id>http://blog.dvkunion.cn/2018/10/17/python3-learning%E2%91%A0/</id>
    <published>2018-10-17T21:34:20.000Z</published>
    <updated>2023-11-03T20:21:04.399Z</updated>
    
    <content type="html"><![CDATA[<div id="head"></div><h1>Python 3</h1><hr><h4 id="b-i-font-color-LightSkyBlue-目录-font-i-b"><b><i><font color = "LightSkyBlue">目录</font><i><b></h4><p><a href="/2018/10/17/python3-learning①/">①</p><ol><li><a href="#0x00">0x00--序</a></li><li><a href="#0x01">0x01--环境搭建</a><ol><li><a href="#0x01-1">环境安装</a></li><li><a href="#0x01-2">Python3安装</a></li></ol></li><li><a href="#0x02">0x02--基本语法</a><ol><li><a href="#0x02-1">基本规则</a></li><li><a href="#0x02-2">基本数据结构</a></li><li><a href="#0x02-3">基本运算符</a></li></ol></li></ol><p><a href="/2018/10/19/python3-learning②/">②<br><a href="/2018/10/19/python3-learning③/">③</p><hr><div id="0x00"></div><h3 id="b-0x00-序-b"><b>0x00- - 序<b></h3><center><small>2018-10-17</small></center>  <p>运维安全的学习开始，这一部分开始学习早就有所耳闻但从未真正动手开始实际使用的一种语言- - Python<br>在这里所记录的主要是在 Centos-7 环境下 Python-3.7.0 的学习</p><blockquote><p>&quot;人生苦短，我用Pyhton&quot;</p></blockquote><center><small>2018/11/29</small></center>  <p>Python3 的系统性学习暂时告一段落，重新把课件和博客进行一遍整理，作为Python3<br>的基础笔记吧。<br>总的来说Python是一门很便捷的语言，他可以为你节省大量的时间和精力，为你省去复杂繁琐的实现过程，而给予你更多的时间去思考设计的逻辑，以及你想做的事。<br>虽然说 Python 十分便捷，但总觉得对于底层的概念Python有些过于省略，对于一个内置函数还是希望在未来多多了解一下他的实现过程、复杂度；对一个库能过一遍他的源码之类的操作。<br>(。・ω・。)总之还是撒花，庆祝第一门课程形式上的完结(。・ω・。)</p><center><small>华丽的分割线</small></center><hr><div id="0x01"></div><div id="0x01-1"></div><h3 id="b-0x01-环境搭建-b"><b>0x01- - 环境搭建<b></h3><h4 id="font-color-blue-环境安装-font-br"><font color = "blue">环境安装</font><br></h4><p>首先在虚拟机安装 Centos-7 的操作系统环境，记得勾选安装图形化界面的选项方便之后的一些操作。在安装的过程中会有一个GUI图形界面的选项，勾选之后安装就可以了。<br><br>安装好系统之后我们需要将虚拟机的网络接通，这里我们主要目的在于学习与测试python3，所以直接使用了NAT模式，将Centos的网卡配置文件内的 ONBOOT = yes。</p><div id="0x01-2"></div><h4 id="font-color-blue-Python3安装-font-br"><font color = "blue">Python3安装</font><br></h4><p>进入终端，首先要在官网下载python3的安装文件。<br>创建一个文件夹来安置python3，并在该文件夹下:<br><code>$ wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</code><br><br>下载结束后解压文件<br><code>$ tar -xzvf Python-3.7.0.tgz</code><br><br>解压后进入到解压好的python目录下<br><code>$ cd Python-3.7.0/</code><br><br>安装Python<br><code>$ ./configure #编辑</code><br><code>$ make</code><br><code>$ make install</code><br><br>安装完成，终端输入python3 即可进入刚安装好的python3环境内。</p><p><img src="/img/4c06e311gy1fwblvc6lk0j20in02vmx4.jpg" alt=""></p><blockquote><p>P.S.</p><ul><li>1. 编译的过程是需要GCC\G++的C语言环境支持，如果是一台新配置 Centos 需要先配置GCC环境。( ゜- ゜)つロ</li><li>2. 下载安装解压使用root账户进行会省去很多麻烦。( ゜- ゜)つロ</li><li>3.按照上面步骤安装一般在make install时候会报一个错误，是因为其中一部分的依赖支持环境没有提前安装。部分功能会无法使用。支持环境在0x06- - Matplotlib安装与使用 中的安装部分有详细步骤。 ( ゜-<br>゜)つロ</li><li>4.干杯🍻( ゜- ゜)つロ</li></ul></blockquote><div id="0x02"></div><h3 id="b-0x02-基本语法-b"><b>0x02- - 基本语法<b></h3><div id="0x02-1"></div><h4 id="font-color-blue-基本规则-font-br"><font color = "blue">基本规则</font><br></h4><h6 id="b-1-编码-b"><b>1.编码<b></h6><ul><li>--Python 3 源码文件以 UTF-8 编码,字符串都是 unicode 字符串,</li></ul><h6 id="b-2-标识符-b"><b>2.标识符<b></h6><ul><li>--第一个字符必须是字母表中字母或下划线 _ 。</li><li>--标识符的其他的部分由字母、数字和下划线组成。</li><li>--标识符对大小写敏感。</li></ul><h6 id="b-3-保留字-b"><b>3.保留字<b></h6><p>Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword_list)</span><br></pre></td></tr></table></figure><h6 id="b-4-注释-b"><b>4.注释<b></h6><p>Python 的注释一般有三种</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以用&#x27;#&#x27;来表示一行的注释</span></span><br><span class="line">(```)</span><br><span class="line">也可以用三个单引号来注释注释块</span><br><span class="line">(```)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">或是用三个双引号来注释注释块</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h6 id="b-5-缩进-b"><b>5.缩进<b></h6><p>python内的缩进十分严格。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><h6 id="b-6-多行语句-b"><b>6.多行语句<b></h6><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠\来实现多行语句。</p><div id="0x02-2"></div><h4 id="font-color-blue-基本数据结构-font-br"><font color = "blue">基本数据结构</font><br></h4><h6 id="b-1-数字-Num-b"><b>1.数字--Num <b></h6><p>--声明</p><p><code>a = 5 #Python的数据不需要标注数据类型</code></p><p>--特性</p><blockquote><p>Num一共有四种不同的数值类型: int--整型，bool--布尔型，float--浮点型，complex--复数。</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回数字的绝对值</td></tr><tr><td>ceil(x)</td><td>返回数字的上入整数</td></tr><tr><td>exp(x)</td><td>返回e的x次幂(e^x)</td></tr><tr><td>fabs(x)</td><td>返回数字的绝对值(浮点型)</td></tr><tr><td>floor(x)</td><td>返回数字的下舍整数</td></tr><tr><td>modf(x)</td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示</td></tr><tr><td>pow(x,y)</td><td>x**y 运算后的值</td></tr><tr><td>sqrt(x)</td><td>返回数字 x 的平方根</td></tr></tbody></table><h6 id="b-2-字符串-String-b"><b>2.字符串--String <b></h6><p>--声明</p><p><code>str1 = 'hello'</code><br>或<br><code>str2 = &quot;life is too short&quot;</code><br>也可以<br><code>str3 = '''so I use python'''</code></p><p>--特性</p><blockquote><p>String 不能被改变(Immutable)<br>String 中使用特殊字符时需要使用转义字符<br>String 前面加一个r/R(Raw String)使转义字符无效，即原始字符串<br>String 切片操作和所以可以双向 如：从左往右时，下标从0开始；从右往左时，下标从-1开始。<br>String 在python中代替了char的位置。即python中不存在char 类型</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>str.title()</td><td>返回首字母大写的str</td></tr><tr><td>count(str, beg= 0,end=len(string))</td><td>返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td>find(str, beg=0 end=len(string))</td><td>检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td>max(str)/min(str)</td><td>返回字符串 str 中最大/最小的字母。</td></tr><tr><td>str.lstrip()/str.rstrip()</td><td>删除字符串字符串串首/末尾的空格</td></tr><tr><td>replace(old, new [, max])</td><td>把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td>startswith(str,beg=0,end=len(string))</td><td>检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td>str.swapcase()</td><td>将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td>str.upper()/str.lower()</td><td>转换字符串中的小写字母为大写/转换字符串中的大写字母为小写</td></tr><tr><td>str.isdecimal()</td><td>检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h6 id="3-列表-List">3.列表--List</h6><p>--声明<br><code>list = []</code></p><p>--特性</p><blockquote><p>List 元素可变(Mutable)<br>List 切片/截取同String相同，左必右开</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(list)</td><td>列表元素个数</td></tr><tr><td>max(list)/min(list)</td><td>返回列表元素最大值/最小值</td></tr><tr><td>list(seq)</td><td>将元组转换为列表</td></tr><tr><td>list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td>list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td>list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td>list.insert(index, obj)</td><td>将对象插入列表</td></tr><tr><td>list.pop([index=-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td>list.reverse()</td><td>反向列表中元素</td></tr><tr><td>list.sort(cmp=None, key=None, reverse=False)</td><td>对原列表进行排序</td></tr><tr><td>list.clear()</td><td>清空列表</td></tr><tr><td>list.copy()</td><td>复制列表</td></tr></tbody></table><h6 id="4-元组-Tuple">4.元组--Tuple</h6><p>--声明<br><code>tup = ()</code></p><p>--特性</p><blockquote><p>Tuple 元素不可变(Immutable)<br>Tuple 切片/截取同String相同，左必右开<br>Tuple 在声明时候注意:没有元素时的声明为：tup = ()；只存在一个元素时：tup = (6,)<br>Tuple 因为不可变，所以sort等函数无法使用。将Tuple转化为List即可</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(tuple)</td><td>元组元素个数</td></tr><tr><td>max(tuple)/min(tuple)</td><td>返回元组元素最大值/最小值</td></tr><tr><td>tuple(seq)</td><td>将列表转换为元组</td></tr></tbody></table><h6 id="5-集合-Set">5.集合--Set</h6><p>--声明<br><code>set = ()</code><br>或者<br><code> set = &#123;var1,var2,var3....&#125;</code></p><p>--特性</p><blockquote><p>Set 是一个无序的不重复元素序列<br>Set 元素可变(Mutable)<br>Set 为空集合时必须用()来声明</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>set.add( x )</td><td>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。</td></tr><tr><td>set.remove( x )</td><td>将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。</td></tr><tr><td>set.discard( x )</td><td>移除集合中的元素，且如果元素不存在，不会发生错误</td></tr><tr><td>union()</td><td>返回两个集合的并集</td></tr></tbody></table><h6 id="6-字典-Dictionary">6.字典--Dictionary</h6><p>--声明<br><code>dict = &#123;&#125;</code></p><p>--特性</p><blockquote><p>Dict 元素可变(Mutable)<br>Dict 键值必须是唯一的，值不必<br>Dict 值可以取任数据类型，但键必须是不可变的，如字符串，数字或元组<br>Dict 也可以看做是通过键：值对映射的集合</p></blockquote><p>--方法函数</p><table><thead><tr><th>函数名称</th><th>函数功能</th></tr></thead><tbody><tr><td>len(dict)</td><td>字典元素个数</td></tr><tr><td>str(dict)</td><td>打印字典</td></tr><tr><td>type(var)</td><td>返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr><tr><td>key in dict</td><td>如果键在字典dict里返回true，否则返回false</td></tr></tbody></table><h6 id="EOF-数据结构小结">EOF.数据结构小结</h6><p>String、List、Tuple 统称为序列。<br>Python内可变的数据结构有:List、Dictionary、Set<br>Python内不可变的数据结构有:String、Tuple、Number<br>除type()之外，还有一个isinstance(element,type)函数可以显示数据的类型。<br>其区别在于:type()不会认为子类是一种父类类型。<br>isinstance()会认为子类是一种父类类型。</p><div id="0x02-3"></div><h4 id="font-color-blue-基本运算符-font-br"><font color = "blue">基本运算符</font><br></h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 31</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -11</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 210</td></tr><tr><td>/</td><td>除 - x 除以 y</td><td>b / a 输出结果 2.1</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 1</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的21次方</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分</td><td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td></tr></tbody></table><br><p><a href="#head"><center><font color = "Crimson">back --返回</font></center><br></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;head&quot;&gt;&lt;/div&gt;
&lt;h1&gt;Python 3&lt;/h1&gt;
&lt;hr&gt;
&lt;h4 id=&quot;b-i-font-color-LightSkyBlue-目录-font-i-b&quot;&gt;&lt;b&gt;&lt;i&gt;&lt;font color = &quot;LightSkyBlue&quot;&gt;目录&lt;/font&gt;&lt;i</summary>
      
    
    
    
    <category term="Language" scheme="http://blog.dvkunion.cn/categories/Language/"/>
    
    
    <category term="脚本" scheme="http://blog.dvkunion.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
    <category term="Python3" scheme="http://blog.dvkunion.cn/tags/Python3/"/>
    
  </entry>
  
</feed>
